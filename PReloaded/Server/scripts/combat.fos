//
// FOnline: 2238
// Rotators
//
// combat.fos
//

// 21-08-2010 05:09
// 2238

// 23-07-2013 Cubik:
// poprawione obliczanie min-max dmg od bonusow crafconych broni
// naprawiony bug z niewlasciwym wyliczaniem DT/DR armorow od bonusow (wyliczane sa w dll-ce Kilgora)
// bonusy armorow przetwarzane w combat.fos: BONUS_ARMOR_CRIT_CHANCE, BONUS_ARMOR_CRIT_POWER
// pozostaЕ‚e bonusy armorow przetwarzane sa w dll-ce Kilgora


#include "_basetypes.fos"
#include "_macros.fos"
#include "combat_msg.fos"
#include "critical_table.fos"
#include "critical_failures.fos"
#include "logging_h.fos"
#include "npc_ai.fos"
#include "utils_h.fos"
#include "mapdata_h.fos"
#include "MsgStr.h"
#include "combat_h.fos"
#include "_npc_pids.fos"
#include "_colors.fos"

#define COLOR_DTEXT_BONUS       (COLOR_LGREEN)
#define COLOR_DTEXT_MALUS       (COLOR_WRED)
#define COLOR_DTEXT_ROLL        (COLOR_YELLOW)
#define COLOR_DTEXT_CAPTION     (COLOR_TEXT_WHITE)
#define COLOR_DTEXT_REGULAR     (COLOR_TEXT_DDGREEN)


import void AffectPoison(Critter& cr, int value) from "poison";
import void AffectRadiation(Critter& cr, int value) from "radiation";
import void PlaySound(Critter& cr, string& soundName) from "media";
import void PostDamage(Critter& cr) from "main";
import void QuakeScreen(Map& map) from "effects";
import void WearItem(Critter& cr, Item& item, int wearCount) from "repair";
import void WearHandsOnDeath(Critter& cr) from "repair";
import void SetMinWear(Item& item, int wearProcent) from "repair";


class AttackStruct
{
    Critter@   Attacker = null;
    Item@      RealWeapon = null;
    uint16     Hx = 0;
    uint16     Hy = 0;
    uint8      Aim = HIT_LOCATION_UNCALLED;
    bool       AimHead = false;
    bool       IsBurst = false;
    bool       BloodyMess = false;
    bool       CombatMessage = false;
    bool       IsUnarmed = false;
    int        WeaponPerk = -1;
    uint8      WeaponSubtype = 0;
    int        DmgMin = 0;
    int        DmgMax = 0;
    int        DmgType = 0;
    int        BonusDmg = 0;
    int        DmgMul = 2;
    int        DRMod = 0;
    int        DMMod = 1;
    int        DDMod = 1;
    uint       TargetId = 0;
    bool       TargetHit = false;
    bool       ShowHitAnimForce = false;
    ProtoItem@ Ammo = null;
    bool       SilentDeathEffect = false;
	uint16     ammoPid;
	uint16     weaponPid;
	int8       weaponMode; // for swing/thrust melee weapons

    void set_Aim(uint8 aim)
    {
        Aim = aim;
        AimHead = aim == HIT_LOCATION_HEAD || aim == HIT_LOCATION_EYES;
    }

    uint8 get_Aim()
    {
        return Aim;
    }

	int SelectWeaponBonus(int Int_Val_WeaponBonus)
	{
		if(valid(RealWeapon))
		{
			if(RealWeapon.Val0 == Int_Val_WeaponBonus) return  RealWeapon.Val5;
			if(RealWeapon.Val1 == Int_Val_WeaponBonus) return  RealWeapon.Val6;
			if(RealWeapon.Val2 == Int_Val_WeaponBonus) return  RealWeapon.Val7;
			if(RealWeapon.Val3 == Int_Val_WeaponBonus) return  RealWeapon.Val8;
			if(RealWeapon.Val4 == Int_Val_WeaponBonus) return  RealWeapon.Val9;
			return 0;
		}
		else return 0;
	}

}

int SelectArmorBonus(Item@ armor, int Int_Val_ArmorBonus)
{
	if(valid(armor))
	{
		if(armor.Val0 == Int_Val_ArmorBonus) return  armor.Val5;
		if(armor.Val1 == Int_Val_ArmorBonus) return  armor.Val6;
		if(armor.Val2 == Int_Val_ArmorBonus) return  armor.Val7;
		if(armor.Val3 == Int_Val_ArmorBonus) return  armor.Val8;
		if(armor.Val4 == Int_Val_ArmorBonus) return  armor.Val9;
		return 0;
	}
	else return 0;
}



void CombatAttack(Critter& cr, Critter& target, ProtoItem& weapon, uint8 weaponMode, ProtoItem@ ammo)   // Export
{
	uint8 use = _WeaponModeUse(weaponMode);
	//if(cr.IsPlayer())
	//{
		//Log(" Use mode = " + use);
		//Log(" attack.WeaponSubtype [WS_UNARMED==1] = " + attack.WeaponSubtype);
	//}
    uint8 aim = _WeaponModeAim(weaponMode);

    if(aim != HIT_LOCATION_NONE && aim != HIT_LOCATION_UNCALLED)
        PlaySound(cr, "ICSXXXX1.ACM");           // should be (?) client-side, move when possible

    Item@ realWeapon = _CritGetItemHand(cr);
    Map@  map = cr.GetMap();
    int   wpnMaxDist = _WeaponMaxDist(weapon, use);
    int   skillNum = _WeaponSkill(weapon, use);
    if(skillNum == SK_THROWING)
    {
        wpnMaxDist = MIN(wpnMaxDist, 3 * MIN(int(10), (cr.Stat[ST_STRENGTH])));
        wpnMaxDist += 6 * cr.Perk[PE_HEAVE_HO];
    }
    int    skillVal = cr.Skill[skillNum]; // skillVal wykorzystane pozniej jako: baseToHit = skillVal; oraz WearItem(cr, realWeapon, (MAX_SKILL_VAL - MIN(skillVal,200)) / 6);

	if(valid(realWeapon) && (realWeapon.Proto.ProtoId == PID_NEEDLER_PISTOL)) skillVal = MAX(cr.Skill[SK_SMALL_GUNS], cr.Skill[SK_DOCTOR]);  //25-07-2013 Cubik: podczas uzywania Needler pistola pod uwage bedzie brany max ze skilli SG i Doc do celnosci i psucia sie pistola


    uint8  weaponSubtype = (skillNum == SK_SMALL_GUNS || skillNum == SK_BIG_GUNS || skillNum == SK_ENERGY_WEAPONS /*|| skillNum == SK_DOCTOR*/) ? WS_GUN : ((skillNum == SK_THROWING) ? WS_THROWING : WS_UNARMED);
    bool   isRanged = (weaponSubtype == WS_THROWING || weaponSubtype == WS_GUN);
    bool   isUnarmed = weapon.Weapon_IsUnarmed;
    bool   isHthAttack = (weaponSubtype == WS_UNARMED);
    uint16 ammoRound = _WeaponRound(weapon, use);
    bool   wpnIsRemoved = _WeaponRemove(weapon, use);
    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    uint16 tx = target.HexX;
    uint16 ty = target.HexY;
    uint16 weapPid = weapon.ProtoId;
    uint16 ammoPid = 0;
    if(valid(ammo))
        ammoPid = ammo.ProtoId;
    bool isBurst = (ammoRound > 1); // will suffice for now
    if(isBurst)
        aim = HIT_LOCATION_UNCALLED;
    int              dmgType = _WeaponDmgType(weapon, use);

    bool             isGrenade = weaponSubtype == WS_THROWING && (dmgType == DAMAGE_TYPE_PLASMA || dmgType == DAMAGE_TYPE_EMP || dmgType == DAMAGE_TYPE_EXPLODE || dmgType == DAMAGE_TYPE_FIRE);   // like in fo2
    bool             isFlamethrower = (weapPid == PID_FLAMER) || (weapPid == PID_IMPROVED_FLAMETHROWER) || (weapPid == PID_FIRE_GECKO_FLAME_WEAPON);
    bool             isRocket = (ammoPid == PID_EXPLOSIVE_ROCKET) || (ammoPid == PID_40MM_GRENADE) || (ammoPid == PID_ROCKET_AP) || (ammoPid == PID_ROBO_ROCKET_AMMO);
	bool 			 isExplodeRocket = (ammoPid == PID_EXPLOSIVE_ROCKET) || (ammoPid == PID_40MM_GRENADE);
    bool             isShotgun = weapon.Weapon_Caliber == 11;
	bool             isBozar = weapPid == PID_BOZAR;
	bool             isLSW = weapPid == PID_LIGHT_SUPPORT_WEAPON;
    bool             isNoSpread = (isShotgun || isBozar || isLSW || weapPid == PID_LASER_SUPPORT_WEAPON || weapPid == PID_FN_FAL || weapPid == PID_FN_FAL_HPFA);

	if(ammoPid == PID_SHOTGUN_SHELLS_EMP) dmgType=DAMAGE_TYPE_EMP; // jesli uzywane ammo typu EMP to zmien dmtype broni
	if(ammoPid == PID_SHOTGUN_DRAGON_BREATH_SHELLS) dmgType=DAMAGE_TYPE_FIRE; // jesli uzywane ammo typu EMP to zmien dmtype broni

    bool             eyeDamage = cr.Damage[DAMAGE_EYE] != 0;
    int              weaponPerk = weapon.Weapon_Perk;
    bool             crIsPlayer = cr.IsPlayer();
    bool             isHit = false;
    bool             isCritical = false;
    bool             hitRandomly = false;
    uint             critfailFlags = 0;
    Critter@         realTarget;
    bool             isSneak = false;
    bool             useNormal = false;   // Used to change target during RunFlyEffect
    bool             useHex = false;      // Used to change end hex of RunFlyEffect, i.e. for thrown weapons and rockets.
    Critter@         normalTarget;        // Used as a target for weapon animations;

    //  BNW changes, to be able to have some training info, to make the dummy more useful, only allow for player and if critter is a training dummy
    //  may add option later to disable this verbose message at the dummy dialog?
    bool isDummyTraining = target.CrType >= CRTYPE_DUMMY_STAND ? (target.CrType <= CRTYPE_DUMMY_POWER_ARMOR ? true : false) : false;
    if (!cr.IsPlayer()) {
        isDummyTraining = false;
    }
    string dummyInfo;
    string dummyCaption;
    string dummyText;

    if (isDummyTraining) {
        dummyInfo = "|" + COLOR_DTEXT_BONUS + " :: Pip-boy Advanced Training Dummy Module :: \n";
    }

	int CriticalChance=0;	//01-08-2013 cubik: szansa na krytyczny strzal, wykorzsystywana w AttackDamage() do wyliczania ilosci krytycznych strzalow w burst

    array<CombatRes> results;

    int              acmod = 0;   // Used many times

    // Begin turn based combat
    if(!map.IsTurnBased() && map.IsTurnBasedAvailability())
        map.BeginTurnBased(cr);

    // Always unsneak
    if(cr.Mode[MODE_HIDE] != 0)
    {
        if(!cr.IsPlayer() || cr.GetAccess() == ACCESS_CLIENT)
            cr.ModeBase[MODE_HIDE] = 0;
        isSneak = true;
    }

    if(!target.IsPlayer() || target.GetAccess() == ACCESS_CLIENT)

        target.ModeBase[MODE_HIDE] = 0;

    cr.SetDir(GetDirection(hx, hy, tx, ty));

    int aimRoll = Random(-1, 8);
    if (cr.Trait[TRAIT_FAST_SHOT] != 0 && !isBurst && _WeaponAim(weapon, use))
        aim = CLAMP(aimRoll, 0, 8);

    // Now we change aim, if applicable
    if(aim == HIT_LOCATION_EYES && valid(cr) && (cr.Dir + 3) % 6 != target.Dir)
        aim = HIT_LOCATION_HEAD;
    else if(aim == HIT_LOCATION_EYES && valid(target))
    {
        Item@ helmet = target.GetItem(0, SLOT_HEAD);
        if(valid(helmet) && helmet.Proto.Armor_Perk == HELMET_PERK_PROTECT_EYES)
            aim = HIT_LOCATION_HEAD;
    }

    if(cr.Timeout[TO_BATTLE] < int(__TimeoutBattle))
        _SetTimeout(cr, TO_BATTLE, __TimeoutBattle);
    if(target.Timeout[TO_BATTLE] < int(__TimeoutBattle))
        _SetTimeout(target, TO_BATTLE, __TimeoutBattle);

    // Update leaderboard stats
    if(crIsPlayer)
    {
        if(weaponSubtype == WS_GUN)
            AddScore(cr, SCORE_SHOOTER, 1);
		else if(skillNum == SK_UNARMED || skillNum == SK_THROWING)
            AddScore(cr, SCORE_MELEE, 1);
        else if(skillNum == SK_UNARMED)
            AddScore(cr, SCORE_UNARMED, 1);
    }

    // Npc attack text
    if(!crIsPlayer)
        AI_TrySayCombatText(cr, COMBAT_TEXT_ATTACK);

    // Add event, always
    target.EventAttacked(cr);

    // Essential part starts here


    // Fill the main attack structure
    AttackStruct attack;
    @attack.Attacker = cr;
    @attack.RealWeapon = realWeapon;
    attack.Hx = hx;
    attack.Hy = hy;
    attack.set_Aim(aim);
    attack.IsBurst = isBurst;
    attack.BloodyMess = cr.Trait[TRAIT_BLOODY_MESS] != 0;
    attack.CombatMessage = true;
    attack.IsUnarmed = (weaponSubtype == WS_UNARMED);
    attack.WeaponPerk = (isUnarmed && weapon.Weapon_UnarmedArmorPiercing) ? WEAPON_PERK_PENETRATE : weaponPerk;
    attack.WeaponSubtype = weaponSubtype;
    attack.DmgMin = _WeaponDmgMin(weapon, use);
    attack.DmgMax = _WeaponDmgMax(weapon, use);
    attack.DmgType = dmgType;
    attack.BonusDmg = 0;

    if(valid(realWeapon))
    {
        wpnMaxDist += attack.SelectWeaponBonus(BONUS_WEAPON_MAX_RANGE);
    }

	attack.weaponMode=weaponMode;
	attack.weaponPid=weapon.ProtoId;

	//Log(" weaponPid = " + weapon.ProtoId);


    // baseToHit used for all targets, adjusted for distance and other target-dependent qualities every time it is necessary
    int baseToHit = skillVal;
    if (isDummyTraining) {
        dummyInfo += "|" + COLOR_DTEXT_CAPTION + " Chance to Hit :: ";
        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " Base To Hit = |"  + COLOR_DTEXT_BONUS + " " + baseToHit;
    }
    if (eyeDamage) {
        baseToHit -= 25;
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Eye Damage = |" + COLOR_DTEXT_MALUS + " -25";
        }
    }
    if (!isUnarmed)
    {
        if(cr.Trait[TRAIT_ONE_HANDER] != 0) {
            baseToHit += (FLAG(weapon.Flags, ITEM_FLAG_TWO_HANDS) ? -40 : 20);
            if (isDummyTraining) {
                int twoHanderBonus = (FLAG(weapon.Flags, ITEM_FLAG_TWO_HANDS) ? -40 : 20);
                if (twoHanderBonus > 0) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Trait One Hander = |" + COLOR_DTEXT_BONUS + " " + twoHanderBonus;
                } else {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Trait One Hander = |" + COLOR_DTEXT_MALUS + " " + twoHanderBonus;
                }
            }
        }
        int handlingStrength = cr.Stat[ST_STRENGTH];
        int reqStrength = weapon.Weapon_MinStrength;
        if(cr.Perk[PE_WEAPON_HANDLING] != 0)
            handlingStrength += 2;
        if (handlingStrength < reqStrength) {
            baseToHit -= (reqStrength - handlingStrength) * 20;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , ST penalty = |" + COLOR_DTEXT_MALUS + " " + ((reqStrength - handlingStrength) * -20);
            }
        }

        if (weaponPerk == WEAPON_PERK_ACCURATE) {
            baseToHit += 20;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Weapon Perk Accurate = |" + COLOR_DTEXT_BONUS + " 20";
            }
        }
    }


    @attack.Ammo = ammo;
    uint8 crDir = cr.Dir;
    uint8 tDir  = target.Dir;

    if(isSneak && cr.Perk[PE_SILENT_DEATH] != 0 && (crDir == tDir || ((crDir + 1) % 6) == tDir || ((crDir + 5) % 6) == tDir) &&
       !isGrenade &&
       (weaponSubtype != WS_GUN || realWeapon.Proto.Weapon_Anim1 == ANIM1_PISTOL || COMBAT_WEAPON_ALLOWS_SD(realWeapon))
       )
        attack.SilentDeathEffect = true;


    if(isHthAttack)
	{
		attack.DmgMin += cr.Stat[ST_MELEE_DAMAGE];
		attack.DmgMax += cr.Stat[ST_MELEE_DAMAGE];
	}

    if (weaponSubtype == WS_GUN) {
        //  BNW change, bonus ranged damage and more ranged damage depend on CH
        //  Maybe merge into one perk later named Burst With Confidence? idk
        //  formula is: CLAMP(CH1 - CH2/2, 0, 3) where CH1 is attacker's Charisma and CH2 is target's Charisma
        int bonusFromCh = CLAMP(cr.Stat[ST_CHARISMA_EXT] - (((target.Stat[ST_CHARISMA_EXT] + 1) * 2) / 3), 0, 3);
        attack.BonusDmg += cr.Perk[PE_BONUS_RANGED_DAMAGE] * bonusFromCh + cr.Perk[PE_MORE_RANGED_DAMAGE] * bonusFromCh;
    }
    attack.DmgMul = 2;

    // Ammo
    if(valid(ammo))
    {
        attack.DRMod = ammo.Ammo_DrMod;
        attack.DMMod = ammo.Ammo_DmgMult;
        attack.DDMod = ammo.Ammo_DmgDiv;
        if(attack.DMMod == 0)
            attack.DMMod = 1;
        if(attack.DDMod == 0)
            attack.DDMod = 1;
    }

    // To check if the original target was hit:
    attack.TargetId = target.Id;

    // Here we are deciding the real toHit;
    int toHit = baseToHit + attack.SelectWeaponBonus(BONUS_WEAPON_ACCURACY);
    if (isDummyTraining && attack.SelectWeaponBonus(BONUS_WEAPON_ACCURACY) > 0) {
        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Weapon Bonus Accuracy = |" + COLOR_DTEXT_BONUS + " " + attack.SelectWeaponBonus(BONUS_WEAPON_ACCURACY);
    }
    toHit -= isHthAttack ? (GetHitAim(aim) / 2) : GetHitAim(aim);
    if (isDummyTraining) {
        if (isHthAttack) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , HtH Aim = |" + COLOR_DTEXT_MALUS + " " + (-1 * int((GetHitAim(aim) / 2)));
        } else {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Aim = |" + COLOR_DTEXT_MALUS + " " + (-1 * int(GetHitAim(aim)));
        }
    }

    // Range considerations, we are storing everything for some later use
    int distmod1 = 2;   // Used for initial weapon bonus
    int distmod2 = 0;   // Minimal distance

    if(weaponPerk == WEAPON_PERK_LONG_RANGE)
        distmod1 = 4;
    else if(weaponPerk == WEAPON_PERK_SCOPE_RANGE)
    {
        distmod1 = 5;
        distmod2 = 8;
    }

    int perception = cr.Stat[ST_PERCEPTION];
    int dist = GetDistantion(hx, hy, target.HexX, target.HexY);
    int acc = dist;
    if (isDummyTraining) {
        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Dist = |" + COLOR_DTEXT_MALUS + " " + (-1 * acc);
    }

    int accloss = (crIsPlayer ? (perception - 2) * distmod1 : (perception * distmod1));
    if (isDummyTraining) {
        //dummyInfo += ", Accloss (PE*distmod1) = " + accloss;
    }
    int sharpshooter = 2 * cr.Perk[PE_SHARPSHOOTER];
    if (isDummyTraining && sharpshooter > 0) {
        //dummyInfo += ", Sharpshooter = " + sharpshooter;
    }

    // +++ the following is to be copypasted many times, in fact it should be an inline function but AngelScript won't allow that... Yet
    if (!isHthAttack)
    {
        if (dist < distmod2) {
            acc += distmod2;
            if (isDummyTraining) {
                //dummyInfo += ", Distmod2 = " + distmod2;
            }
        } else {
            acc -= accloss;
        }
        if (-2 * perception > acc) {
            acc = -2 * perception;
            if (isDummyTraining) {
                //dummyInfo += ", New Acc = " + acc;
            }
        }
        acc -= sharpshooter;
        if (acc > 0 && eyeDamage) {
            acc *= 3;
            if (isDummyTraining) {
                //dummyInfo += ", Eye Damage Penalty New Acc = " + (-1 * acc);
            }
        }
        acc *= -4;
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Acc (after calc PE/W.Perks/Perks etc) = |" + COLOR_DTEXT_MALUS + " " + acc;
        }
        toHit += acc;
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , To Hit = |" + COLOR_DTEXT_BONUS + " " + toHit;
        }
        int blockers = map.GetCrittersPath(hx, hy, tx, ty, 0.0f, dist, FIND_LIFE, null);
        if (!target.IsKnockout())
            blockers--;
        if (isDummyTraining && blockers > 0) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Blockers count = " + blockers + ", To Hit = |" + COLOR_DTEXT_MALUS + " " + (toHit - 10 * blockers);
        }
        toHit -= 10 * blockers;
    } else {
        toHit += 8*cr.Perk[PE_SHARPSHOOTER];
        if (isDummyTraining && cr.Perk[PE_SHARPSHOOTER] > 0) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , (after Sharpshooter) To Hit = |" + COLOR_DTEXT_BONUS + " " + toHit;
        }
    }

    acmod = target.GetAC(attack.AimHead);
    if (isDummyTraining) {
        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Target AC = |" + COLOR_DTEXT_MALUS + " " + acmod;
    }
    if (valid(ammo)) {
        acmod += ammo.Ammo_AcMod;
        if (isDummyTraining) {
            if (ammo.Ammo_AcMod > 0) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , ammo AC mod = |" + COLOR_DTEXT_MALUS + " " + ammo.Ammo_AcMod;
            } else {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , ammo AC mod = |" + COLOR_DTEXT_BONUS + " " + ammo.Ammo_AcMod;
            }
        }
    }
    if (acmod > 0) {
        toHit -= acmod;
    } else {
        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Target AC and ammo AC mod ignored as their sum <= 0";
    }

    if(target.IsKnockout()) {
        toHit += 40;
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , KO bonus = |" + COLOR_DTEXT_BONUS + " 40";
        }
    }
    if(target.GetMultihex() > 0) {
        toHit += 15;
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Multihex bonus = |" + COLOR_DTEXT_BONUS + " 15";
        }
    }

//Log("Combat attack, toHit1 = "+toHit);
    if(target.Perk[PE_DODGER] > 0)
    {
        Item@ targetWeapon = _CritGetItemHand(target);
        Item@ targetWeapon2 = _CritGetItemHandExt(target);

        if( (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON && (targetWeapon.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon.Proto.Weapon_Skill_0 != SK_THROWING)) ||
            (valid(targetWeapon2) && targetWeapon2.GetType() == ITEM_TYPE_WEAPON && (targetWeapon2.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon2.Proto.Weapon_Skill_0 != SK_THROWING)) )
        {
            //Log("Dodger: bad weapon");
        }
        else
        {
            //Log("Dodger: bonus applied");
            toHit -= target.Perk[PE_DODGER]*5;
            if (isDummyTraining && target.Perk[PE_DODGER] > 0) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Dodger penalty = |" + COLOR_DTEXT_MALUS + " " + (int(target.Perk[PE_DODGER]) * -5);
            }
        }
    }
    int hitRoll = Random(1, 100);
    int sniperMargin = CLAMP(toHit - hitRoll, 0, 150);

    if (isDummyTraining) {
        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , To Hit = |" + COLOR_DTEXT_BONUS + " " + toHit;
    }
    toHit = CLAMP(toHit, 5, _MaxToHit(cr));
    if (isDummyTraining && (toHit < 5 || toHit > _MaxToHit(cr))) {
        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , CLAMP(5, 89 + CH) = |" + COLOR_DTEXT_BONUS + " " + toHit;
    }

    if (target.Perk[PE_IN_YOUR_FACE] > 0 && dist < 3) {
        Item@ targetWeapon = _CritGetItemHand(target);
        if ((!valid(targetWeapon) && dist == 1) || (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON &&
            (targetWeapon.Proto.Weapon_Skill_0 == SK_UNARMED) && _WeaponMaxDist(targetWeapon.Proto, 0) >= uint(dist)) )
        {
            toHit = MIN(toHit, 50);
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , after In Your Face = |" + COLOR_DTEXT_BONUS + " " + toHit;
            }
        }
    }
    // Main hit roll
    int margin = toHit - hitRoll;
    if (isDummyTraining) {
        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , FINAL To Hit = |" + COLOR_DTEXT_BONUS + " " + toHit + "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + hitRoll;
        if (margin >= 0) {
            dummyInfo += "|" + COLOR_DTEXT_BONUS + "  :: Hit";
        } else {
            dummyInfo += "|" + COLOR_DTEXT_MALUS + "  :: Miss";
        }
    }
    // If missed
    if (margin < 0) {
        // Not setting isHit, we try a critical failure
        if(cr.Mode[MODE_INVULNERABLE] == 0) {
            int missCritRoll = Random(1, 100);
            isCritical = ((((-margin) / 10) + ((valid(realWeapon) && realWeapon.IsDeteriorable() && !_CritHasExtMode(cr, MODE_EXT_NO_DETERIORATION)) ? ((20 * realWeapon.Deterioration) / MAX_DETERIORATION) : 0)) >= missCritRoll);
            if (isDummyTraining) {
                dummyText += "|" + COLOR_DTEXT_REGULAR + " Margin/10 = |" + COLOR_DTEXT_MALUS + " " + (-margin / 10);
                if (valid(realWeapon) && realWeapon.IsDeteriorable() && !_CritHasExtMode(cr, MODE_EXT_NO_DETERIORATION)) {
                    dummyText += "|" + COLOR_DTEXT_REGULAR + " , Weap. dur. factor = |" + COLOR_DTEXT_MALUS + " " + ((20 * realWeapon.Deterioration) / MAX_DETERIORATION) + "|" + COLOR_DTEXT_REGULAR + "  (" + realWeapon.Deterioration + " / 500)";
                }
                dummyText += "|" + COLOR_DTEXT_REGULAR + " , Final Value = |" + COLOR_DTEXT_MALUS + " " + (-margin / 10 + ((20 * realWeapon.Deterioration) / MAX_DETERIORATION) ) + "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + missCritRoll;
            }

            // Basic jinxed behaviour (upgrade to a critical failure if anyone is jinxed and a coinflip is passed)
            int jinxedRoll = Random(0, 1);
            if (!isCritical) {
                if (isDummyTraining) {
                    if (cr.Trait[TRAIT_JINXED] != 0 || cr.Perk[PE_JINXED_II] != 0) {
                        dummyText += "|" + COLOR_DTEXT_ROLL + " , Attacker JINXED Roll = |" + (jinxedRoll == 0 ? COLOR_DTEXT_MALUS : COLOR_DTEXT_BONUS) + " " + (jinxedRoll == 0 ? "Fail" : "Success" );
                    } else if (target.Trait[TRAIT_JINXED] != 0 || target.Perk[PE_JINXED_II] != 0) {
                        dummyText += "|" + COLOR_DTEXT_ROLL + " , Target JINXED Roll = |" + (jinxedRoll == 0 ? COLOR_DTEXT_MALUS : COLOR_DTEXT_BONUS) + " " + (jinxedRoll == 0 ? "Fail" : "Success" );
                    }
                }
                isCritical = (jinxedRoll == 0 &&
                              (cr.Trait[TRAIT_JINXED] != 0 || cr.Perk[PE_JINXED_II] != 0 || target.Trait[TRAIT_JINXED] != 0 || target.Perk[PE_JINXED_II] != 0));
            }
            if (isDummyTraining) {
                if (isCritical) {
                    dummyCaption += "|" + COLOR_DTEXT_CAPTION + " \nCritical miss :: ";
                } else {
                    dummyCaption += "|" + COLOR_DTEXT_CAPTION + " \nMiss :: ";
                }
            }
            dummyInfo += dummyCaption + dummyText;

            if (isCritical) {
                int roll = Random(1, 100);
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Critical Failure Roll = |" + COLOR_DTEXT_ROLL + " " + roll;
                }
                int critFailureRoll = roll - 5 * (cr.Stat[ST_LUCK] - 5);
                if (isDummyTraining) {
                    if (cr.Stat[ST_LUCK] > 5) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , LK factor = |" + COLOR_DTEXT_BONUS + " " + (-5 * (cr.Stat[ST_LUCK] - 5));
                    } else {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , LK factor = |" + COLOR_DTEXT_MALUS + " " + (-5 * (cr.Stat[ST_LUCK] - 5));
                    }
                }
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Crit. Fail Final Roll value = |" + COLOR_DTEXT_ROLL + " " + critFailureRoll;
                }

                if(critFailureRoll <= 20) {
                    critFailureRoll = 0;
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  <= 20 -> Crit. Fail Category: |" + COLOR_DTEXT_MALUS + " " + critFailureRoll;
                    }
                } else if(critFailureRoll <= 50) {
                    critFailureRoll = 1;
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  <= 50 -> Crit. Fail Category: |" + COLOR_DTEXT_MALUS + " " + critFailureRoll;
                    }
                } else if(critFailureRoll <= 75) {
                    critFailureRoll = 2;
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  <= 75 -> Crit. Fail Category: |" + COLOR_DTEXT_MALUS + " " + critFailureRoll;
                    }
                } else if(critFailureRoll <= 95) {
                    critFailureRoll = 3;
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  <= 95 -> Crit. Fail Category: |" + COLOR_DTEXT_MALUS + " " + critFailureRoll;
                    }
                } else {
                    critFailureRoll = 4;
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  > 95 -> Crit. Fail Category: |" + COLOR_DTEXT_MALUS + " " + critFailureRoll;
                    }
                }

                critfailFlags = CriticalFailureTable[5 * weapon.Weapon_CriticalFailture + critFailureRoll];
                if(critfailFlags == 0)
                    isCritical = false;
                hitRandomly = FLAG(critfailFlags, MF_HIT_RANDOMLY);
            }
        }
    }
    else     // If hit
    {
        isHit = true;
        int isCriticalRoll = Random(1, 100);
        if (isDummyTraining) {
            dummyText += "|" + COLOR_DTEXT_CAPTION + " \nChance to Crit :: ";
        }
        if (isHthAttack && cr.Perk[PE_SLAYER] != 0) {
            isCritical = true;
            if (isDummyTraining) {
                dummyText += "|" + COLOR_DTEXT_BONUS + " Slayer perk auto crit. ";
            }
        } else if (attack.SilentDeathEffect) {
            isCritical = true;
            if (isDummyTraining) {
                dummyText += "|" + COLOR_DTEXT_BONUS + " Silent Death perk auto crit. ";
            }
        } else {
            int chance = cr.Stat[ST_CRITICAL_CHANCE] + margin / 10 + (GetHitAim(aim) * (35 + 4 * cr.Stat[ST_INTELLECT])) / 100 + attack.SelectWeaponBonus(BONUS_WEAPON_CRITICAL_CHANCE) - (target.Stat[ST_LUCK] / 2);
            if (isDummyTraining) {
                dummyText += "|" + COLOR_DTEXT_REGULAR + " Base Crit Chance = |" + COLOR_DTEXT_BONUS + " " + cr.Stat[ST_CRITICAL_CHANCE];
                dummyText += "|" + COLOR_DTEXT_REGULAR + " , Margin/10 = |" + COLOR_DTEXT_BONUS + " " + margin / 10;
                dummyText += "|" + COLOR_DTEXT_REGULAR + " , Aim bonus = |" + COLOR_DTEXT_BONUS + " " + ((GetHitAim(aim) * (35 + 4 * cr.Stat[ST_INTELLECT])) / 100);
                if (GetHitAim(aim) > 0) {
                    dummyText += "|" + COLOR_DTEXT_REGULAR + "  ( Aim(|" + COLOR_DTEXT_BONUS + " " + GetHitAim(aim);
                    dummyText += "|" + COLOR_DTEXT_REGULAR + " ) * (35 + 4 * IN(|" + COLOR_DTEXT_BONUS + " " + cr.Stat[ST_INTELLECT];
                    dummyText += "|" + COLOR_DTEXT_REGULAR + " ) / 100 )";
                }
                dummyText += "|" + COLOR_DTEXT_REGULAR + " , Weap bonus = |" + COLOR_DTEXT_BONUS + " " + attack.SelectWeaponBonus(BONUS_WEAPON_CRITICAL_CHANCE);
                dummyText += "|" + COLOR_DTEXT_REGULAR + " , Target LK/2 = |" + COLOR_DTEXT_MALUS + " -" + target.Stat[ST_LUCK] / 2;
            }
            if(isHthAttack && cr.Perk[PE_CLOSE_COMBAT_MASTER] > 0) {
                chance += 15;
                if (isDummyTraining) {
                    dummyText += "|" + COLOR_DTEXT_REGULAR + " , Close Combat Master bonus = |" + COLOR_DTEXT_BONUS + " " + 15;
                }
            }

            Item@ usedArmor = _GetCritterArmor(target, attack.AimHead);
            if (valid(usedArmor)) {
                int addchance = usedArmor.Proto.Armor_CMCritChance;
				// 03-08-2013 cubik: wywalony perk spray
                //if(cr.Perk[PE_SPRAY_AND_PRAY] != 0 && (attack.Aim == HIT_LOCATION_UNCALLED || attack.Aim == HIT_LOCATION_NONE))
                //    addchance = 0;
                //else
                if (isDummyTraining) {
                    dummyText += "|" + COLOR_DTEXT_REGULAR + " , Target Armor modifier = |" + COLOR_DTEXT_MALUS + " " + usedArmor.Proto.Armor_CMCritChance;
                }

                //  TODO: BNW: fixed a bug? (to be tested) this line was missing???
                //addchance += usedArmor.Proto.Armor_CMCritChance;

                if (cr.Trait[TRAIT_FINESSE] != 0) {
                    addchance -= usedArmor.Proto.Armor_CMCritChance / 4;
                    if (isDummyTraining) {
                        dummyText += "|" + COLOR_DTEXT_REGULAR + " , Finesse factor (25% ignore) = |" + COLOR_DTEXT_BONUS + " " + (-usedArmor.Proto.Armor_CMCritChance / 4);
                    }
                }
                if ((aim != HIT_LOCATION_NONE) && (aim != HIT_LOCATION_UNCALLED) && cr.Perk[PE_SHARPSHOOTER] != 0) {
                    addchance -= usedArmor.Proto.Armor_CMCritChance / 2;
                    if (isDummyTraining) {
                        dummyText += "|" + COLOR_DTEXT_REGULAR + " , Sharpshooter factor (50% ignore) = |" + COLOR_DTEXT_BONUS + " " + (-usedArmor.Proto.Armor_CMCritChance / 2);
                    }
                }
                chance += addchance;
				chance -= SelectArmorBonus(usedArmor, BONUS_ARMOR_CRIT_CHANCE);
                if (isDummyTraining && SelectArmorBonus(usedArmor, BONUS_ARMOR_CRIT_CHANCE) > 0) {
                    dummyText += "|" + COLOR_DTEXT_REGULAR + " , Armor craft modifier = |" + COLOR_DTEXT_MALUS + " " + SelectArmorBonus(usedArmor, BONUS_ARMOR_CRIT_CHANCE);
                }
            } else {
                if (isDummyTraining) {
                    dummyText += "|" + COLOR_DTEXT_REGULAR + " , Target has no armor or broken.";
                }
            }

            //  BNW: reworked sniper perk, now it will give bonus crit chance if toHit above hitRoll, only for aimed hits, no fast shot trait
            if (!isCritical && weaponSubtype == WS_GUN && cr.Perk[PE_SNIPER] != 0 && aim != HIT_LOCATION_UNCALLED && aim != HIT_LOCATION_NONE && cr.Trait[TRAIT_FAST_SHOT] == 0) {
                int sniperCritChanceBonus = CLAMP((cr.Stat[ST_INTELLECT] * 5 - target.Stat[ST_LUCK] * 2) * sniperMargin / 150, 0, 50);
                if (isDummyTraining) {
                    dummyText += "|" + COLOR_DTEXT_REGULAR + " , Sniper Perk: Margin = |" + COLOR_DTEXT_BONUS + " " + sniperMargin;
                    dummyText += "|" + COLOR_DTEXT_REGULAR + " / 150 * (Attacker IN = |" + COLOR_DTEXT_BONUS + " " + cr.Stat[ST_INTELLECT];
                    dummyText += "|" + COLOR_DTEXT_REGULAR + "  * 5) - (Target LK = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_LUCK];
                    dummyText += "|" + COLOR_DTEXT_REGULAR + "  * 2), Sniper crit. bonus = |" + COLOR_DTEXT_BONUS + " " + sniperCritChanceBonus;
                }
                chance += sniperCritChanceBonus;
            }

            if (isDummyTraining) {
                dummyText += "|" + COLOR_DTEXT_REGULAR + " , Final chance = |" + COLOR_DTEXT_BONUS + " " + chance;
                dummyText += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + isCriticalRoll;
            }
            isCritical = (isCriticalRoll <= chance);
			CriticalChance = chance;
        }
        if (!isCritical && isUnarmed) {
            int criticalUnarmedWeaponRoll = Random(1, 100);
            isCritical = criticalUnarmedWeaponRoll <= weapon.Weapon_UnarmedCriticalBonus;
            if (isDummyTraining) {
                dummyText += "|" + COLOR_DTEXT_REGULAR + " , Unarmed crit. upgrade Weapon factor = |" + COLOR_DTEXT_BONUS + " " + weapon.Weapon_UnarmedCriticalBonus;
                dummyText += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + criticalUnarmedWeaponRoll;
            }
        }

        if (isDummyTraining) {
            if (isCritical) {
                dummyText += "|" + COLOR_DTEXT_BONUS + "  :: Critical Hit";
            } else {
                dummyText += "|" + COLOR_DTEXT_BONUS + "  :: Normal Hit";
            }
        }

        if (isDummyTraining) {
            dummyInfo = dummyInfo + dummyCaption + dummyText;
        }
    }

    if(hitRandomly)
    {
        Critter@ randomTarget = ChooseRandomTarget(map, cr, target, wpnMaxDist);
        if(valid(randomTarget))
        {
            @realTarget = randomTarget;
            tx = realTarget.HexX;
            ty = realTarget.HexY;
            attack.set_Aim(HIT_LOCATION_UNCALLED);
            realTarget.ModeBase[MODE_HIDE] = 0;           // done here to allow combat notifications later
            NotifyOops(cr, target, realTarget, results);
        }
    }
    else
        @realTarget = target;

    // Initial animations
    cr.Action(CRITTER_ACTION_USE_WEAPON, (((!isHit && isCritical && !hitRandomly) ? 1 : 0) << 8) | (aim << 4) | use, realWeapon);

    // Animations are now played, and we're updating the hit randomly status now
    bool changedTarget = (hitRandomly && (@realTarget != null));

    // Commencing critical failures
    if(!isHit && isCritical && (!hitRandomly  || @realTarget == null))
    {
        CriticalFailure(cr, weapon, use, ammo, critfailFlags, results);
        if (isDummyTraining && cr.IsPlayer()) {
            cr.Say(SAY_NETMSG, dummyInfo);
        }
        return;
    }

    if (isDummyTraining && cr.IsPlayer()) {
        cr.Say(SAY_NETMSG, dummyInfo);
    }


    // Commencing attack, various instances
    bool criticalHit = isHit && isCritical;

    if(isHthAttack)       // UNARMED AND MELEE ATTACK
    {
        if(isHit)
        {
			if (weaponSubtype==WS_UNARMED && (cr.Stat[ST_BODY_TYPE]==BT_MEN || cr.Stat[ST_BODY_TYPE]==BT_WOMEN)) cr.PlaySound((Random(0,1)==0?"HMXXXXZR.ACM":"HMXXXXZQ.ACM"), true);
			ApplyDamage(attack, realTarget, 1, criticalHit, true, results, 0);
        }
        else
        {
            if(changedTarget)
			{
				if (weaponSubtype==WS_UNARMED && (cr.Stat[ST_BODY_TYPE]==BT_MEN || cr.Stat[ST_BODY_TYPE]==BT_WOMEN)) cr.PlaySound((Random(0,1)==0?"HMXXXXZR.ACM":"HMXXXXZQ.ACM"), true);
                ApplyDamage(attack, realTarget, 1, false, false, results, 0);
				}
            else
                NotifyMiss(cr, results);
        }
    }
    else if((weaponSubtype == WS_GUN) && !isBurst && !isRocket && !isFlamethrower)       // single shot, normal
    {
        if(isHit || changedTarget)
		{
			ApplyDamage(attack, realTarget, 1, criticalHit, !changedTarget, results, 0);
		}
        else         // standard miss here
        {
            array<Critter@> critsLine;
            attack.set_Aim(HIT_LOCATION_UNCALLED);
            map.GetCrittersPath(hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, critsLine);
            int  bl = 0;
            bool anyHit = false;
            for(int i = 0, j = critsLine.length(); (i < j) && !anyHit; i++)
            {
                if(critsLine[i].Id == realTarget.Id)
                {
                    bl++;
                    continue;
                }                                                                      // skip the primary target

                // adjust tohit
                dist = GetDistantion(hx, hy, critsLine[i].HexX, critsLine[i].HexY);
                acc = dist;
                toHit = baseToHit;
                if(dist < distmod2)
                    acc += distmod2;
                else
                    acc -= accloss;
                if(-2 * perception > acc)
                    acc = -2 * perception;
                acc -= sharpshooter;
                if(acc > 0 && eyeDamage)
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = critsLine[i].GetAC(false);
                if(valid(ammo))
                    acmod += ammo.Ammo_AcMod;
                if(acmod > 0)
                    toHit -= acmod;
                toHit -= 10 * bl;
                if(critsLine[i].IsKnockout())
                    toHit += 40;
                else
                    bl++;
                if(critsLine[i].GetMultihex() > 0)
                    toHit += 15;
                toHit = CLAMP(toHit, 5, _MaxToHit(cr));
            //Log("Combat attack, toHit1 = "+toHit);
                if(critsLine[i].Perk[PE_DODGER] > 0)
                {
                    Item@ targetWeapon = _CritGetItemHand(critsLine[i]);
                    Item@ targetWeapon2 = _CritGetItemHandExt(critsLine[i]);

                    if( (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON && (targetWeapon.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon.Proto.Weapon_Skill_0 != SK_THROWING)) ||
                        (valid(targetWeapon2) && targetWeapon2.GetType() == ITEM_TYPE_WEAPON && (targetWeapon2.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon2.Proto.Weapon_Skill_0 != SK_THROWING)) )
                    {
                        //Log("Dodger: bad weapon");
                    }
                    else
                    {
                        //Log("Dodger: bonus applied");
                        toHit -= critsLine[i].Perk[PE_DODGER]*5;
                    }
                }
                toHit = CLAMP(toHit, 5, _MaxToHit(cr));
            //Log("Combat attack, toHit2 = "+toHit);
                toHit /= 3;               // after clamp
                if(Random(1, 100) <= toHit)
                {
                    NotifyOops(cr, target, critsLine[i], results);
                    @normalTarget = critsLine[i];
                    useNormal = true;
                    ApplyDamage(attack, normalTarget, 1, false, false, results, 0);
                    anyHit = true;
                }
            }
            if(!anyHit)
                NotifyMiss(cr, results);
        }
    }
    else if(isFlamethrower)       // FLAME ATTACK
    {
        // Adjust toHit if random hit
        if(changedTarget)
        {
            dist = GetDistantion(hx, hy, tx, ty);
            acc = dist;
            toHit = baseToHit;
            if(dist < distmod2)
                acc += distmod2;
            else
                acc -= accloss;
            if(-2 * perception > acc)
                acc = -2 * perception;
            acc -= sharpshooter;
            if(acc > 0 && eyeDamage)
                acc *= 3;
            acc *= -4;
            toHit += acc;
            acmod = realTarget.GetAC(false);
            if(valid(ammo))
                acmod += ammo.Ammo_AcMod;
            if(acmod > 0)
                toHit -= acmod;
            if(realTarget.IsKnockout())
                toHit += 40;
            if(realTarget.GetMultihex() > 0)
                toHit += 15;
            int blockers = map.GetCrittersPath(hx, hy, tx, ty, 0.0f, dist, FIND_LIFE, null);
            if(!realTarget.IsKnockout())
                blockers--;
            toHit -= 10 * blockers;
            toHit = CLAMP(toHit, 5, _MaxToHit(cr));
        //Log("Combat attack, toHit1 = "+toHit);
            if(realTarget.Perk[PE_DODGER] > 0)
            {
                Item@ targetWeapon = _CritGetItemHand(realTarget);
                Item@ targetWeapon2 = _CritGetItemHandExt(realTarget);

                if( (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON && (targetWeapon.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon.Proto.Weapon_Skill_0 != SK_THROWING)) ||
                    (valid(targetWeapon2) && targetWeapon2.GetType() == ITEM_TYPE_WEAPON && (targetWeapon2.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon2.Proto.Weapon_Skill_0 != SK_THROWING)) )
                {
                    //Log("Dodger: bad weapon");
                }
                else
                {
                    //Log("Dodger: bonus applied");
                    toHit -= realTarget.Perk[PE_DODGER]*5;
                }
            }
            toHit = CLAMP(toHit, 5, _MaxToHit(cr));
        //Log("Combat attack, toHit2 = "+toHit);

        }

        // Critical hit bonus, toHit can be increased over 100
        if(criticalHit)
            toHit += 20;

        // Proceed with the flame attack
        array<Critter@> critsHit(0);
        array<uint>     critsHitBullets(0);
        int len_ = 0;

        if(Random(1, 100) <= toHit)
        {
            critsHit.resize(1);
            @critsHit[0] = realTarget;
            critsHitBullets.resize(1);
            critsHitBullets[0] += 1;
            len_++;
        }

        array<Critter@> lineCentral;
        map.GetCrittersPath(hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, lineCentral);
        int             bl;

        bool            threeLines = true;

        for(int lineCount = 0, lineMax = (threeLines ? 1 : 3); lineCount < lineMax; lineCount++)
        {
            // Central line of fire
            bl = 0;           // No blockers
            for(int i = 0, j = lineCentral.length(); i < j; i++)
            {
                // Adjust tohit
                toHit = baseToHit - 10 * bl;
                dist = GetDistantion(hx, hy, lineCentral[i].HexX, lineCentral[i].HexY);
                acc = dist;
                if(dist < distmod2)
                    acc += distmod2;
                else
                    acc -= accloss;
                if(-2 * perception > acc)
                    acc = -2 * perception;
                acc -= sharpshooter;
                if(acc > 0 && eyeDamage)
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = lineCentral[i].GetAC(false);
                if(valid(ammo))
                    acmod += ammo.Ammo_AcMod;
                if(acmod > 0)
                    toHit -= acmod;
                if(lineCentral[i].IsKnockout())
                    toHit += 40;
                else
                    bl++;
                if(lineCentral[i].GetMultihex() > 0)
                    toHit += 15;
                toHit = CLAMP(toHit, 5, _MaxToHit(cr));
            //Log("Combat attack, toHit1 = "+toHit);
                if(lineCentral[i].Perk[PE_DODGER] > 0)
                {
                    Item@ targetWeapon = _CritGetItemHand(lineCentral[i]);
                    Item@ targetWeapon2 = _CritGetItemHandExt(lineCentral[i]);

                    if( (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON && (targetWeapon.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon.Proto.Weapon_Skill_0 != SK_THROWING)) ||
                        (valid(targetWeapon2) && targetWeapon2.GetType() == ITEM_TYPE_WEAPON && (targetWeapon2.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon2.Proto.Weapon_Skill_0 != SK_THROWING)) )
                    {
                        //Log("Dodger: bad weapon");
                    }
                    else
                    {
                        //Log("Dodger: bonus applied");
                        toHit -= lineCentral[i].Perk[PE_DODGER]*5;
                    }
                }
                toHit = CLAMP(toHit, 5, _MaxToHit(cr));
            //Log("Combat attack, toHit2 = "+toHit);

                if(Random(1, 100) <= toHit)
                {
                    int crIndex = FindCritterInArray(critsHit, lineCentral[i]);
                    if(crIndex == -1)
                    {
                        critsHit.resize(len_ + 1);
                        @critsHit[len_] = lineCentral[i];
                        critsHitBullets.resize(len_ + 1);
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[crIndex] += 1;
                }
            }
            // Central line of fire end
        }

        if(threeLines)
        {
            uint8  leftDir = GetOffsetDir(hx, hy, tx, ty, 89.0f);
            uint16 sx = hx;
            uint16 sy = hy;
            uint16 ex = tx;
            uint16 ey = ty;

            map.MoveHexByDir(sx, sy, leftDir, 1);
            map.MoveHexByDir(ex, ey, leftDir, 1);

            array<Critter@> lineLeft;
            map.GetCrittersPath(sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineLeft);
            int             leftStart = 0;
            int             leftLen = lineLeft.length();
            while((leftStart < leftLen) && (GetDistantion(hx, hy, lineLeft[leftStart].HexX, lineLeft[leftStart].HexY)) < 3)
                leftStart++;

            for(int i = leftStart, j = leftLen; i < j; i++)
            {
                // Adjust tohit
                dist = GetDistantion(hx, hy, lineLeft[i].HexX, lineLeft[i].HexY);
                bl = map.GetCrittersPath(hx, hy, lineLeft[i].HexX, lineLeft[i].HexY, 0.0f, dist, FIND_LIFE, null) - 1;
                toHit = baseToHit - 10 * bl;
                acc = dist;
                if(dist < distmod2)
                    acc += distmod2;
                else
                    acc -= accloss;
                if(-2 * perception > acc)
                    acc = -2 * perception;
                acc -= sharpshooter;
                if(acc > 0 && eyeDamage)
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = lineLeft[i].GetAC(false);
                if(valid(ammo))
                    acmod += ammo.Ammo_AcMod;
                if(acmod > 0)
                    toHit -= acmod;
                if(lineLeft[i].IsKnockout())
                    toHit += 40;
                if(lineLeft[i].GetMultihex() > 0)
                    toHit += 15;
                toHit = CLAMP(toHit, 5, _MaxToHit(cr));
            //Log("Combat attack, toHit1 = "+toHit);
                if(lineLeft[i].Perk[PE_DODGER] > 0)
                {
                    Item@ targetWeapon = _CritGetItemHand(lineLeft[i]);
                    Item@ targetWeapon2 = _CritGetItemHandExt(lineLeft[i]);

                    if( (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON && (targetWeapon.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon.Proto.Weapon_Skill_0 != SK_THROWING)) ||
                        (valid(targetWeapon2) && targetWeapon2.GetType() == ITEM_TYPE_WEAPON && (targetWeapon2.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon2.Proto.Weapon_Skill_0 != SK_THROWING)) )
                    {
                        //Log("Dodger: bad weapon");
                    }
                    else
                    {
                        //Log("Dodger: bonus applied");
                        toHit -= lineLeft[i].Perk[PE_DODGER]*5;
                    }
                }
                toHit = CLAMP(toHit, 5, _MaxToHit(cr));
            //Log("Combat attack, toHit2 = "+toHit);

                if(Random(1, 100) <= toHit)
                {
                    int crIndex = FindCritterInArray(critsHit, lineLeft[i]);
                    if(crIndex == -1)
                    {
                        critsHit.resize(len_ + 1);
                        @critsHit[len_] = lineLeft[i];
                        critsHitBullets.resize(len_ + 1);
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[crIndex] += 1;
                }
            }             // Left line end

            uint8 rightDir = GetOffsetDir(hx, hy, tx, ty, -89.0f);
            sx = hx;
            sy = hy;
            ex = tx;
            ey = ty;

            map.MoveHexByDir(sx, sy, rightDir, 1);
            map.MoveHexByDir(ex, ey, rightDir, 1);

            array<Critter@> lineRight;
            map.GetCrittersPath(sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineRight);
            int             rightStart = 0;
            int             rightLen = lineRight.length();
            while((rightStart < rightLen) && (GetDistantion(hx, hy, lineRight[rightStart].HexX, lineRight[rightStart].HexY)) < 3)
                rightStart++;
            for(int i = rightStart, j = rightLen; i < j; i++)
            {
                // Adjust tohit
                dist = GetDistantion(hx, hy, lineRight[i].HexX, lineRight[i].HexY);
                bl = map.GetCrittersPath(hx, hy, lineRight[i].HexX, lineRight[i].HexY, 0.0f, dist, FIND_LIFE, null) - 1;
                toHit = baseToHit - 10 * bl;
                acc = dist;
                if(dist < distmod2)
                    acc += distmod2;
                else
                    acc -= accloss;
                if(-2 * perception > acc)
                    acc = -2 * perception;
                acc -= sharpshooter;
                if(acc > 0 && eyeDamage)
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = lineRight[i].GetAC(false);
                if(valid(ammo))
                    acmod += ammo.Ammo_AcMod;
                if(acmod > 0)
                    toHit -= acmod;
                if(lineRight[i].IsKnockout())
                    toHit += 40;
                if(lineRight[i].GetMultihex() > 0)
                    toHit += 15;
                toHit = CLAMP(toHit, 5, _MaxToHit(cr));
            //Log("Combat attack, toHit1 = "+toHit);
                if(lineRight[i].Perk[PE_DODGER] > 0)
                {
                    Item@ targetWeapon = _CritGetItemHand(lineRight[i]);
                    Item@ targetWeapon2 = _CritGetItemHandExt(lineRight[i]);

                    if( (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON && (targetWeapon.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon.Proto.Weapon_Skill_0 != SK_THROWING)) ||
                        (valid(targetWeapon2) && targetWeapon2.GetType() == ITEM_TYPE_WEAPON && (targetWeapon2.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon2.Proto.Weapon_Skill_0 != SK_THROWING)) )
                    {
                        //Log("Dodger: bad weapon");
                    }
                    else
                    {
                        //Log("Dodger: bonus applied");
                        toHit -= lineRight[i].Perk[PE_DODGER]*5;
                    }
                }
                toHit = CLAMP(toHit, 5, _MaxToHit(cr));
            //Log("Combat attack, toHit2 = "+toHit);

                if(Random(1, 100) <= toHit)
                {
                    int crIndex = FindCritterInArray(critsHit, lineRight[i]);
                    if(crIndex == -1)
                    {
                        critsHit.resize(len_ + 1);
                        @critsHit[len_] = lineRight[i];
                        critsHitBullets.resize(len_ + 1);
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[crIndex] += 1;
                }
            }     // Right line end
        }         // Three lines end

        for(int i = 0, j = len_; i < j; i++)
		{
			ApplyDamage(attack, critsHit[i], 1, (realTarget.Id == critsHit[i].Id) && criticalHit, (!_IsTrueNpc(cr) && !changedTarget) || (_IsTrueNpc(cr) && critsHit[i].Id == target.Id), results, 0);
		}

        if(!changedTarget && !attack.TargetHit)
            NotifyMiss(cr, results);
    }
    else if((weaponSubtype == WS_GUN) && isBurst)       // BURST FIRE
    {
        // Adjust toHit if random hit
        if(changedTarget)
        {
            dist = GetDistantion(hx, hy, tx, ty);
            acc = dist;
            toHit = baseToHit;
            if(dist < distmod2)
                acc += distmod2;
            else
                acc -= accloss;
            if(-2 * perception > acc)
                acc = -2 * perception;
            acc -= sharpshooter;
            if(acc > 0 && eyeDamage)
                acc *= 3;
            acc *= -4;
            toHit += acc;
            acmod = realTarget.GetAC(false);
            if(valid(ammo))
                acmod += ammo.Ammo_AcMod;
            if(acmod > 0)
                toHit -= acmod;
            if(realTarget.IsKnockout())
                toHit += 40;
            if(realTarget.GetMultihex() > 0)
                toHit += 15;
            int blockers = map.GetCrittersPath(hx, hy, tx, ty, 0.0f, dist, FIND_LIFE, null);
            if(!realTarget.IsKnockout())
                blockers--;
            toHit -= 10 * blockers;
            toHit = CLAMP(toHit, 5, _MaxToHit(cr));
        //Log("Combat attack, toHit1 = "+toHit);
            if(realTarget.Perk[PE_DODGER] > 0)
            {
                Item@ targetWeapon = _CritGetItemHand(realTarget);
                Item@ targetWeapon2 = _CritGetItemHandExt(realTarget);

                if( (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON && (targetWeapon.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon.Proto.Weapon_Skill_0 != SK_THROWING)) ||
                    (valid(targetWeapon2) && targetWeapon2.GetType() == ITEM_TYPE_WEAPON && (targetWeapon2.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon2.Proto.Weapon_Skill_0 != SK_THROWING)) )
                {
                    //Log("Dodger: bad weapon");
                }
                else
                {
                    //Log("Dodger: bonus applied");
                    toHit -= realTarget.Perk[PE_DODGER]*5;
                }
            }
            toHit = CLAMP(toHit, 5, _MaxToHit(cr));
        //Log("Combat attack, toHit2 = "+toHit);
            if(realTarget.Perk[PE_IN_YOUR_FACE] > 0 && dist < 3)
            {
                Item@ targetWeapon = _CritGetItemHand(realTarget);
                if( (!valid(targetWeapon) && dist == 1) || (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON &&
                    (targetWeapon.Proto.Weapon_Skill_0 == SK_UNARMED) && _WeaponMaxDist(targetWeapon.Proto, 0) >= uint(dist)) )
                {
                    //Log("in your face!");
                    toHit = MIN(toHit, 50);
                }
            }
        //Log("Combat attack, toHit3 = "+toHit);
        }

        // Critical hit bonus, toHit can be increased over 95
        if(criticalHit)
            toHit += 20;

        // Proceed with the burst attack
        uint rounds = ammoRound;
        if(valid(realWeapon) && realWeapon.AmmoCount < rounds)
            rounds = realWeapon.AmmoCount;
        array<Critter@> critsHit(0);
        array<uint>     critsHitBullets(0);

        int len_ = 0;
        int volleyRounds = MAX((rounds / 6), 1);

        int curRounds = 0;
        for(int i = 0; i < volleyRounds; i++)
        {
            if(Random(1, 100) <= toHit)
                curRounds++;
        }

        if(curRounds != 0)
        {
            critsHit.resize(1);
            critsHitBullets.resize(1);
            @critsHit[0] = realTarget;
            critsHitBullets[0] = curRounds;
            len_++;
        }
        volleyRounds -= curRounds;

        array<Critter@> lineCentral;
        map.GetCrittersPath(hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, lineCentral);

        // This never happens
        if(lineCentral.length() == 0)
        {
            Log("ERR: lineCentral.length()==0");
            Log("  " + hx + "," + hy + "," + tx + "," + ty + "," + wpnMaxDist + (changedTarget ? "changed" : "original"));
            Log("  attacker " + cr.HexX + "," + cr.HexY);
            Log("  target: " + target.HexX + "," + target.HexY + "," + GetDistantion(cr.HexX, cr.HexY, target.HexX, target.HexY) + "," + target.Cond);
            Log("  realTarget: " + realTarget.HexX + "," + realTarget.HexY + "," + GetDistantion(cr.HexX, cr.HexY, realTarget.HexX, realTarget.HexY) + "," + realTarget.Cond);
        }

        int bl = 0;
        curRounds = 0;
        for(int i = 0, j = lineCentral.length(); (i < j) && (volleyRounds > 0); i++)
        {
            if(lineCentral[i].Id == realTarget.Id)
            {
                bl++;
                continue;
            }                                                                      // skip the primary target, but add blocker
            // Adjust tohit
            toHit = baseToHit - 10 * bl;
            dist = GetDistantion(hx, hy, lineCentral[i].HexX, lineCentral[i].HexY);
            acc = dist;
            if(dist < distmod2)
                acc += distmod2;
            else
                acc -= accloss;
            if(-2 * perception > acc)
                acc = -2 * perception;
            acc -= sharpshooter;
            if(acc > 0 && eyeDamage)
                acc *= 3;
            acc *= -4;
            toHit += acc;
            acmod = lineCentral[i].GetAC(false);
            if(valid(ammo))
                acmod += ammo.Ammo_AcMod;
            if(acmod > 0)
                toHit -= acmod;
            if(lineCentral[i].IsKnockout())
                toHit += 40;
            else
                bl++;
            if(lineCentral[i].GetMultihex() > 0)
                toHit += 15;
            toHit = CLAMP(toHit, 5, _MaxToHit(cr));
        //Log("Combat attack, toHit1 = "+toHit);
            if(lineCentral[i].Perk[PE_DODGER] > 0)
            {
                Item@ targetWeapon = _CritGetItemHand(lineCentral[i]);
                Item@ targetWeapon2 = _CritGetItemHandExt(lineCentral[i]);

                if( (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON && (targetWeapon.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon.Proto.Weapon_Skill_0 != SK_THROWING)) ||
                    (valid(targetWeapon2) && targetWeapon2.GetType() == ITEM_TYPE_WEAPON && (targetWeapon2.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon2.Proto.Weapon_Skill_0 != SK_THROWING)) )
                {
                    //Log("Dodger: bad weapon");
                }
                else
                {
                    //Log("Dodger: bonus applied");
                    toHit -= lineCentral[i].Perk[PE_DODGER]*5;
                }
            }
            toHit = CLAMP(toHit, 5, _MaxToHit(cr));
        //Log("Combat attack, toHit2 = "+toHit);
            if(lineCentral[i].Perk[PE_IN_YOUR_FACE] > 0 && dist < 3)
            {
                Item@ targetWeapon = _CritGetItemHand(lineCentral[i]);
                if( (!valid(targetWeapon) && dist == 1) || (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON &&
                    (targetWeapon.Proto.Weapon_Skill_0 == SK_UNARMED) && _WeaponMaxDist(targetWeapon.Proto, 0) >= uint(dist)) )
                {
                    //Log("in your face!");
                    toHit = MIN(toHit, 50);
                }
            }
        //Log("Combat attack, toHit3 = "+toHit);

            curRounds = 0;
            for(int k = 0; k < volleyRounds; ++k)
            {
                if(Random(1, 100) <= toHit)
                    curRounds++;
            }
            volleyRounds -= curRounds;

            if(curRounds > 0)
            {
                int crIndex = FindCritterInArray(critsHit, lineCentral[i]);
                if(crIndex == -1)
                {
                    critsHit.resize(len_ + 1);
                    @critsHit[len_] = lineCentral[i];
                    critsHitBullets.resize(len_ + 1);
                    critsHitBullets[len_] = 0;
                    crIndex = len_;
                    len_++;
                }
                critsHitBullets[crIndex] += curRounds;
            }
        }

        // Now we are shooting the rest of the bullets (=rounds-MAX(1,rounds/6))
        int shotDist = GetDistantion(hx, hy, lineCentral[0].HexX, lineCentral[0].HexY);
        int step = MAX((wpnMaxDist-11)/7, 1);
        int sideMod =  37 - MIN(shotDist/step, 7);

        ////////////////////////
        ////    1-hexing    ////

        ////    only specific weapons
        bool threeLines = !isNoSpread;   // weapon not shotgun-like
        if (shotDist == 1) {
            if ((weapPid == PID_10MM_SMG) || (weapPid == PID_HK_P90C) || (weapPid == PID_GREASE_GUN) || (weapPid == PID_TOMMY_GUN)
                    || (weapPid == PID_HK_G11) || (weapPid == PID_HK_G11E) || (weapPid == PID_LASER_SMG)) {
                threeLines = false;
            }
        }
        ////

        ////    use this to 1-hex with every weapon, and remove above
        //  bool threeLines = shotDist > 1 ? !isNoSpread : false;   // target not adjacent and weapon not shotgun-like -> use three lines, otherwise 1-hex with every weapon

        /////////////////////////////

        // Already shot: MAX(rounds/6,1);
        for(int lineCount = 0, lineMax = (threeLines ? 1 : 3); lineCount < lineMax; lineCount++)
        {
            // Rounds for central stack
            if(lineCount == 0)
            {
                volleyRounds = rounds - (((rounds + 1) * 10 / sideMod) + (rounds * 10 / sideMod));         // Second voller along the central line, always
                volleyRounds -= MAX(rounds / 6, 1);
            }
            else
            {
                if(lineCount == 1)
                    volleyRounds = (rounds + 1) *10  / sideMod;           // Left line
                else
                    volleyRounds = rounds * 10 / sideMod;                 // Right line
            }

            if(volleyRounds == 0)
                continue;     // No rounds left

            // Central line
            bl = 0;           // No blockers
            for(int i = 0, j = lineCentral.length(); (i < j) && (volleyRounds > 0); i++)
            {
                // Adjust tohit
                toHit = baseToHit - 10 * bl;
                dist = GetDistantion(hx, hy, lineCentral[i].HexX, lineCentral[i].HexY);
                acc = dist;
                if(dist < distmod2)
                    acc += distmod2;
                else
                    acc -= accloss;
                if(-2 * perception > acc)
                    acc = -2 * perception;
                acc -= sharpshooter;
                if(acc > 0 && eyeDamage)
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = lineCentral[i].GetAC(false);
                if(valid(ammo))
                    acmod += ammo.Ammo_AcMod;
                if(acmod > 0)
                    toHit -= acmod;
                if(lineCentral[i].IsKnockout())
                    toHit += 40;
                if(lineCentral[i].GetMultihex() > 0)
                    toHit += 15;
                toHit = CLAMP(toHit, 5, _MaxToHit(cr));
            //Log("Combat attack, toHit1 = "+toHit);
                if(lineCentral[i].Perk[PE_DODGER] > 0)
                {
                    Item@ targetWeapon = _CritGetItemHand(lineCentral[i]);
                    Item@ targetWeapon2 = _CritGetItemHandExt(lineCentral[i]);

                    if( (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON && (targetWeapon.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon.Proto.Weapon_Skill_0 != SK_THROWING)) ||
                        (valid(targetWeapon2) && targetWeapon2.GetType() == ITEM_TYPE_WEAPON && (targetWeapon2.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon2.Proto.Weapon_Skill_0 != SK_THROWING)) )
                    {
                        //Log("Dodger: bad weapon");
                    }
                    else
                    {
                        //Log("Dodger: bonus applied");
                        toHit -= lineCentral[i].Perk[PE_DODGER]*5;
                    }
                }
                toHit = CLAMP(toHit, 5, _MaxToHit(cr));
            //Log("Combat attack, toHit2 = "+toHit);
                if(lineCentral[i].Perk[PE_IN_YOUR_FACE] > 0 && dist < 3)
                {
                    Item@ targetWeapon = _CritGetItemHand(lineCentral[i]);
                    if( (!valid(targetWeapon) && dist == 1) || (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON &&
                        (targetWeapon.Proto.Weapon_Skill_0 == SK_UNARMED) && _WeaponMaxDist(targetWeapon.Proto, 0) >= uint(dist)) )
                    {
                        //Log("in your face!");
                        toHit = MIN(toHit, 50);
                    }
                }
            //Log("Combat attack, toHit3 = "+toHit);
                bl++;

                curRounds = 0;
                for(int k = 0; k < volleyRounds; ++k)
                {
                    if(Random(1, 100) <= toHit)
                    {
                        curRounds++;
                    }
                }
                volleyRounds -= curRounds;

                if(curRounds > 0)
                {
                    int crIndex = FindCritterInArray(critsHit, lineCentral[i]);
                    if(crIndex == -1)
                    {
                        critsHit.resize(len_ + 1);
                        @critsHit[len_] = lineCentral[i];
                        critsHitBullets.resize(len_ + 1);
                        critsHitBullets[len_] = 0;
                        crIndex = len_;
                        len_++;
                    }
                    critsHitBullets[crIndex] += curRounds;
                }
            }
            // Central line end
        }

        if(threeLines)
        {
            // Rounds for the left stack
            volleyRounds = (rounds + 1) * 10 / sideMod;

            if(volleyRounds > 0)             // Real left
            {
                uint8  leftDir = GetOffsetDir(hx, hy, tx, ty, 89.0f);
                uint16 sx = hx;
                uint16 sy = hy;
                uint16 ex = tx;
                uint16 ey = ty;

                map.MoveHexByDir(sx, sy, leftDir, 1);
                map.MoveHexByDir(ex, ey, leftDir, 1);

                array<Critter@> lineLeft;
                map.GetCrittersPath(sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineLeft);
                int             leftStart = 0;
                int             leftLen = lineLeft.length();
                while((leftStart < leftLen) && (GetDistantion(hx, hy, lineLeft[leftStart].HexX, lineLeft[leftStart].HexY)) < 3)
                    leftStart++;

                for(int i = leftStart, j = leftLen; (i < j) && (volleyRounds > 0); i++)
                {
                    // Adjust tohit
                    dist = GetDistantion(hx, hy, lineLeft[i].HexX, lineLeft[i].HexY);
                    bl = map.GetCrittersPath(hx, hy, lineLeft[i].HexX, lineLeft[i].HexY, 0.0f, dist, FIND_LIFE, null) - 1;
                    toHit = baseToHit - 10 * bl;
                    acc = dist;
                    if(dist < distmod2)
                        acc += distmod2;
                    else
                        acc -= accloss;
                    if(-2 * perception > acc)
                        acc = -2 * perception;
                    acc -= sharpshooter;
                    if(acc > 0 && eyeDamage)
                        acc *= 3;
                    acc *= -4;
                    toHit += acc;
                    acmod = lineLeft[i].GetAC(false);
                    if(valid(ammo))
                        acmod += ammo.Ammo_AcMod;
                    if(acmod > 0)
                        toHit -= acmod;
                    if(lineLeft[i].IsKnockout())
                        toHit += 40;
                    if(lineLeft[i].GetMultihex() > 0)
                        toHit += 15;
                    toHit = CLAMP(toHit, 5, _MaxToHit(cr));
                //Log("Combat attack, toHit1 = "+toHit);
                    if(lineLeft[i].Perk[PE_DODGER] > 0)
                    {
                        Item@ targetWeapon = _CritGetItemHand(lineLeft[i]);
                        Item@ targetWeapon2 = _CritGetItemHandExt(lineLeft[i]);

                        if( (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON && (targetWeapon.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon.Proto.Weapon_Skill_0 != SK_THROWING)) ||
                            (valid(targetWeapon2) && targetWeapon2.GetType() == ITEM_TYPE_WEAPON && (targetWeapon2.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon2.Proto.Weapon_Skill_0 != SK_THROWING)) )
                        {
                            //Log("Dodger: bad weapon");
                        }
                        else
                        {
                            //Log("Dodger: bonus applied");
                            toHit -= lineLeft[i].Perk[PE_DODGER]*5;
                        }
                    }
                    toHit = CLAMP(toHit, 5, _MaxToHit(cr));
                //Log("Combat attack, toHit2 = "+toHit);
                    if(lineLeft[i].Perk[PE_IN_YOUR_FACE] > 0 && dist < 3)
                    {
                        Item@ targetWeapon = _CritGetItemHand(lineLeft[i]);
                        if( (!valid(targetWeapon) && dist == 1) || (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON &&
                            (targetWeapon.Proto.Weapon_Skill_0 == SK_UNARMED) && _WeaponMaxDist(targetWeapon.Proto, 0) >= uint(dist)) )
                        {
                            //Log("in your face!");
                            toHit = MIN(toHit, 50);
                        }
                    }
                //Log("Combat attack, toHit3 = "+toHit);

                    curRounds = 0;
                    for(int k = 0; k < volleyRounds; ++k)
                    {
                        if(Random(1, 100) <= toHit)
                            curRounds++;
                    }
                    volleyRounds -= curRounds;

                    if(curRounds > 0)
                    {
                        int crIndex = FindCritterInArray(critsHit, lineLeft[i]);
                        if(crIndex == -1)
                        {
                            critsHit.resize(len_ + 1);
                            @critsHit[len_] = lineLeft[i];
                            critsHitBullets.resize(len_ + 1);
                            critsHitBullets[len_] = 0;
                            crIndex = len_;
                            len_++;
                        }
                        critsHitBullets[crIndex] += curRounds;
                    }
                }
            }             // Left line end


            // Rounds for the right stack
            volleyRounds = (rounds) * 10 / sideMod;

            if(volleyRounds > 0)
            {
                uint8  rightDir = GetOffsetDir(hx, hy, tx, ty, -89.0f);

                uint16 sx = hx;
                uint16 sy = hy;
                uint16 ex = tx;
                uint16 ey = ty;

                map.MoveHexByDir(sx, sy, rightDir, 1);
                map.MoveHexByDir(ex, ey, rightDir, 1);

                array<Critter@> lineRight;
                map.GetCrittersPath(sx, sy, ex, ey, 0.0f, wpnMaxDist - 1, FIND_LIFE_AND_KO, lineRight);
                int             rightStart = 0;
                int             rightLen = lineRight.length();
                while((rightStart < rightLen) && (GetDistantion(hx, hy, lineRight[rightStart].HexX, lineRight[rightStart].HexY)) < 3)
                    rightStart++;
                for(int i = rightStart, j = rightLen; (i < j) && (volleyRounds > 0); i++)
                {
                    // Adjust tohit
                    dist = GetDistantion(hx, hy, lineRight[i].HexX, lineRight[i].HexY);
                    bl = map.GetCrittersPath(hx, hy, lineRight[i].HexX, lineRight[i].HexY, 0.0f, dist, FIND_LIFE, null) - 1;
                    toHit = baseToHit - 10 * bl;
                    acc = dist;
                    if(dist < distmod2)
                        acc += distmod2;
                    else
                        acc -= accloss;
                    if(-2 * perception > acc)
                        acc = -2 * perception;
                    acc -= sharpshooter;
                    if(acc > 0 && eyeDamage)
                        acc *= 3;
                    acc *= -4;
                    toHit += acc;
                    acmod = lineRight[i].GetAC(false);
                    if(valid(ammo))
                        acmod += ammo.Ammo_AcMod;
                    if(acmod > 0)
                        toHit -= acmod;
                    if(lineRight[i].IsKnockout())
                        toHit += 40;
                    if(lineRight[i].GetMultihex() > 0)
                        toHit += 15;
                    toHit = CLAMP(toHit, 5, _MaxToHit(cr));
                //Log("Combat attack, toHit1 = "+toHit);
                    if(lineRight[i].Perk[PE_DODGER] > 0)
                    {
                        Item@ targetWeapon = _CritGetItemHand(lineRight[i]);
                        Item@ targetWeapon2 = _CritGetItemHandExt(lineRight[i]);

                        if( (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON && (targetWeapon.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon.Proto.Weapon_Skill_0 != SK_THROWING)) ||
                            (valid(targetWeapon2) && targetWeapon2.GetType() == ITEM_TYPE_WEAPON && (targetWeapon2.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon2.Proto.Weapon_Skill_0 != SK_THROWING)) )
                        {
                            //Log("Dodger: bad weapon");
                        }
                        else
                        {
                            //Log("Dodger: bonus applied");
                            toHit -= lineRight[i].Perk[PE_DODGER]*5;
                        }
                    }
                    toHit = CLAMP(toHit, 5, _MaxToHit(cr));
                //Log("Combat attack, toHit2 = "+toHit);
                    if(lineRight[i].Perk[PE_IN_YOUR_FACE] > 0 && dist < 3)
                    {
                        Item@ targetWeapon = _CritGetItemHand(lineRight[i]);
                        if( (!valid(targetWeapon) && dist == 1) || (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON &&
                            (targetWeapon.Proto.Weapon_Skill_0 == SK_UNARMED) && _WeaponMaxDist(targetWeapon.Proto, 0) >= uint(dist)) )
                        {
                            //Log("in your face!");
                            toHit = MIN(toHit, 50);
                        }
                    }
                //Log("Combat attack, toHit3 = "+toHit);

                    curRounds = 0;
                    for(int k = 0; k < volleyRounds; ++k)
                    {
                        if(Random(1, 100) <= toHit)
                            curRounds++;
                    }
                    volleyRounds -= curRounds;

                    if(curRounds > 0)
                    {
                        int crIndex = FindCritterInArray(critsHit, lineRight[i]);
                        if(crIndex == -1)
                        {
                            critsHit.resize(len_ + 1);
                            @critsHit[len_] = lineRight[i];
                            critsHitBullets.resize(len_ + 1);
                            critsHitBullets[len_] = 0;
                            crIndex = len_;
                            len_++;
                        }
                        critsHitBullets[crIndex] += curRounds;
                    }
                }
            }             // Right line end
        }

        for(int i = 0, j = len_; i < j; i++)
        {
			ApplyDamage(attack, critsHit[i], critsHitBullets[i], (realTarget.Id == critsHit[i].Id) && criticalHit, (!_IsTrueNpc(cr) && !changedTarget) || (_IsTrueNpc(cr) && critsHit[i].Id == target.Id), results, CriticalChance);
        }

        if(!changedTarget && !attack.TargetHit)
            NotifyMiss(cr, results);
    }
	// Burst attack end

    else if(isRocket || (weaponSubtype == WS_THROWING))   // ROCKETS, THROWING
    {
        bool exploding = isRocket || isGrenade;

        if(isHit || changedTarget)
        {
            if(exploding)
                CommenceExplosion(attack, map, tx, ty, realTarget, weapPid, criticalHit, realTarget.Id, isRocket, results, isExplodeRocket);
            else
                ApplyDamage(attack, realTarget, 1, criticalHit, !changedTarget, results, 0);
        }
        else
        {
            // Miss with missiles
            attack.set_Aim(HIT_LOCATION_UNCALLED);

            if(weaponSubtype == WS_THROWING)
                sharpshooter = 0;
            uint16          bx = 0;
            uint16          by = 0;
            uint16          pbx = 0;
            uint16          pby = 0;
            array<Critter@> critsLine;
            map.GetCrittersPath(hx, hy, tx, ty, 0.0f, wpnMaxDist, FIND_LIFE_AND_KO, critsLine, pbx, pby, bx, by);

            int  bl = 0;
            bool anyHit = false;
            for(int i = 0, j = critsLine.length(); (i < j) && !anyHit; i++)
            {
                if(critsLine[i].Id == realTarget.Id)
                {
                    bl++;
                    continue;
                }                                                                      // skip the primary target

                // Adjust tohit
                dist = GetDistantion(hx, hy, critsLine[i].HexX, critsLine[i].HexY);
                acc = dist;
                toHit = baseToHit;
                if(dist < distmod2)
                    acc += distmod2;
                else
                    acc -= accloss;
                if(-2 * perception > acc)
                    acc = -2 * perception;
                acc -= sharpshooter;
                if(acc > 0 && eyeDamage)
                    acc *= 3;
                acc *= -4;
                toHit += acc;
                acmod = critsLine[i].GetAC(false);
                if(valid(ammo))
                    acmod += ammo.Ammo_AcMod;
                if(acmod > 0)
                    toHit -= acmod;
                toHit -= 10 * bl;
                if(critsLine[i].IsKnockout())
                    toHit += 40;
                else
                    bl++;
                if(critsLine[i].GetMultihex() > 0)
                    toHit += 15;
                toHit = CLAMP(toHit, 5, _MaxToHit(cr));
            //Log("Combat attack, toHit1 = "+toHit);
                if(critsLine[i].Perk[PE_DODGER] > 0)
                {
                    Item@ targetWeapon = _CritGetItemHand(critsLine[i]);
                    Item@ targetWeapon2 = _CritGetItemHandExt(critsLine[i]);

                    if( (valid(targetWeapon) && targetWeapon.GetType() == ITEM_TYPE_WEAPON && (targetWeapon.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon.Proto.Weapon_Skill_0 != SK_THROWING)) ||
                        (valid(targetWeapon2) && targetWeapon2.GetType() == ITEM_TYPE_WEAPON && (targetWeapon2.Proto.Weapon_Skill_0 != SK_UNARMED && targetWeapon2.Proto.Weapon_Skill_0 != SK_THROWING)) )
                    {
                        //Log("Dodger: bad weapon");
                    }
                    else
                    {
                        //Log("Dodger: bonus applied");
                        toHit -= critsLine[i].Perk[PE_DODGER]*5;
                    }
                }
                toHit = CLAMP(toHit, 5, _MaxToHit(cr));
            //Log("Combat attack, toHit2 = "+toHit);

                toHit /= 3;               // After clamp
                if(Random(1, 100) <= toHit)
                {
                    tx = critsLine[i].HexX;
                    ty = critsLine[i].HexY;
                    @normalTarget = critsLine[i];
                    anyHit = true;
                }
            }

            if(anyHit)
            {
                NotifyOops(cr, target, normalTarget, results);
                useNormal = true;

                if(exploding)
                    CommenceExplosion(attack, map, tx, ty, normalTarget, weapPid, false, realTarget.Id, isRocket, results, isExplodeRocket);
                else
                    ApplyDamage(attack, normalTarget, 1, false, false, results, 0);
            }
            else
            {
                useHex = true;
                NotifyMiss(cr, results);
                if(isGrenade)
                {
                    tx = realTarget.HexX;
                    ty = realTarget.HexY;
                    int newdist = GetDistantion(hx, hy, tx, ty) + 1;
                    map.MoveHexByDir(tx, ty, Random(0, 5), Random(1, newdist / 2));
                    newdist = GetDistantion(hx, hy, tx, ty);
                    map.GetCrittersPath(hx, hy, tx, ty, 0.0f, newdist, FIND_LIFE, null, tx, ty, bx, by);
                }
                else
                {
                    if(isRocket)
                    {
                        tx = bx;
                        ty = by;
                        int newdist = GetDistantion(hx, hy, tx, ty) + 1;
                        map.MoveHexByDir(tx, ty, Random(0, 5), Random(1, newdist / 2));
                        newdist = GetDistantion(hx, hy, tx, ty);
                        map.GetCrittersPath(hx, hy, tx, ty, 0.0f, newdist, FIND_LIFE, null, tx, ty, bx, by);
                    }
                    else
                    {
                        tx = pbx;
                        ty = pby;
                    }
                }

                if(exploding)
                    CommenceExplosion(attack, map, tx, ty, null, weapPid, false, realTarget.Id, isRocket, results, isExplodeRocket);
            }
        }         // Miss
    }
    else
        cr.Say(SAY_NETMSG, "ERR: weapon PID=" + weapPid + " not handled, please send bug report.");

    // Send combat messages
    FlushResults(results);

    // Stuff like animations and effects

    // Shoot
    if(_WeaponEffect(weapon, use) != 0)
    {
        if(useHex)
            map.RunFlyEffect(_WeaponEffect(weapon, use), cr, null, hx, hy, tx, ty);      // yeah, the target can be null (see: grenades, rocket launcher)
        else
            map.RunFlyEffect(_WeaponEffect(weapon, use), cr, (useNormal ? normalTarget : realTarget), hx, hy, tx, ty);
    }

    if(ammoRound > 0 && valid(realWeapon) && cr.Mode[MODE_UNLIMITED_AMMO] == 0)
    {
        if(realWeapon.AmmoCount <= ammoRound)
            realWeapon.AmmoCount = 0;
        else
            realWeapon.AmmoCount -= ammoRound;
        realWeapon.Update();
    }

    if(valid(realWeapon))
    {
        if(realWeapon.IsDeteriorable() && !_CritHasExtMode(cr, MODE_EXT_NO_DETERIORATION))
            WearItem(cr, realWeapon, (MAX_SKILL_VAL - MIN(skillVal,200)) / 6);

        // One time weapon, erase current and push next (if exist)
        if(wpnIsRemoved && cr.Mode[MODE_UNLIMITED_AMMO] == 0)
        {
            bool placeOnHex = (skillNum == SK_THROWING && !isGrenade);
            if(realWeapon.IsStackable())
            {
                // Place on hex
                if(placeOnHex)
                    map.AddItem(tx, ty, weapPid, 1);

                // Remove one item
                if(realWeapon.GetCount() > 1)
                    realWeapon.SetCount(realWeapon.GetCount() - 1);
                else
                    DeleteItem(realWeapon);
            }
            else
            {
                MoveItem(realWeapon, 0, map, tx, ty);
            }
        }
    }

    // Npc miss text
    if(!attack.TargetHit)
    {
        if(!target.IsPlayer())
            AI_TrySayCombatText(target, COMBAT_TEXT_MISS);
        target.Action(CRITTER_ACTION_DODGE, 0, null);       // Todo: type front/back
    }
}





void ApplyDamage(AttackStruct& attack, Critter& target, uint rounds, bool isCritical, bool intentionally, array<CombatRes>& results, int CriticalChance)
{
	Item@ usedArmor = _GetCritterArmor(target, attack.AimHead);

    int      dmgMul = attack.DmgMul;
    int      bt = target.Stat[ST_BODY_TYPE];
    uint     eff = 0;
    uint     msgEff = 0;
    int      weaponPerk = attack.WeaponPerk;
    Critter@ attacker = attack.Attacker;
    bool     validAttacker = valid(attacker);
    Map@     map = target.GetMap();
    bool     isBloodyMess = attack.BloodyMess;
    bool     isCombatText = attack.CombatMessage;
    Item@    realWeapon = attack.RealWeapon;
    uint     aim = attack.Aim;
    uint     extraMessage = 0;
    uint     extraMessageSelf = 0;
    bool     isShotgun = (valid(attack.Ammo) && (attack.Ammo.Ammo_Caliber == 11));
	//bool     isFireGeckoShell = (valid(attack.Ammo) && (attack.Ammo.ProtoId == PID_SHOTGUN_DRAGON_BREATH_SHELLS));
	uint16   ammoPid = attack.ammoPid;
    if(valid(attack.Ammo)) ammoPid = attack.Ammo.ProtoId;

	// 24-05-2015 Cubik: wylaczone ban bronie w tym skrypcie. Nalezy uzywac komendy: `give PID -s cheats@weapon_disconnect
	//bool     isBanhammer = (valid(realWeapon) ? realWeapon.Proto.ProtoId==PID_BAN_HAMMER : false);
	//bool     isHolySpear = (valid(realWeapon) ? realWeapon.Proto.ProtoId==PID_HOLY_SPEAR : false);
	//bool     isWeaponBetterCriticals = (valid(realWeapon) ? realWeapon.Proto.ProtoId==PID_TURBO_PLASMA_RIFLE : false);

    bool     targetIsPlayer = target.IsPlayer();
    bool     attackerIsPlayer = (valid(attacker) ? attacker.IsPlayer() : false);
	bool     attackerIsPaszczur = (valid(attacker) ? attacker.GetProtoId()==NPC_PID_Pashtshuur : false);
	uint16 	 weapPid = attack.weaponPid;

	bool     isSwingThrustWeapon = (valid(realWeapon) ? (weapPid == 517 || weapPid == 160 || weapPid == 236 || weapPid == 530 || weapPid == 9676 || weapPid == 4 || weapPid == 116 || weapPid == 383 || weapPid == 6 || weapPid == 399 || weapPid == 115 || weapPid == 319 || weapPid == 622 || weapPid == 522 || weapPid == 600 || weapPid == 610 || weapPid == 289) : false);
    bool     isThrustThrowWeapon = (valid(realWeapon) ? (weapPid == 9916 || weapPid == 618 || weapPid == 320 || weapPid == 280 || weapPid == 7) : false);

	//bool     isPrimitiveWeapon = (valid(realWeapon) ? (weapPid == PID_SPIKED_KNUCKLES || weapPid == PID_BRASS_KNUCKLES || weapPid == PID_LOUISVILLE_SLUGGER || weapPid == PID_SLEDGEHAMMER || weapPid == PID_WRENCH || weapPid == PID_WAKIZASHI_BLADE || weapPid == PID_SWITCHBLADE || weapPid == PID_SHIV || weapPid == PID_LIL_JESUS_WEAPON || weapPid == PID_COMBAT_KNIFE || weapPid == PID_ROCK || weapPid == PID_SPEAR || weapPid == PID_CLUB || weapPid == PID_KNIFE || weapPid == PID_CROWBAR) : false);

    int bypassRoll = 0;
    uint bypassValue = 0;

	array<int>	_dmgMul;
	_dmgMul.resize(rounds);
	for(uint i = 0; i < rounds; i++)
	{
		_dmgMul[i] = dmgMul;
	}



	//#################################################
	//### IMPLEMENTACJA melee attack swing i thrust ###
	//#################################################
	uint8 use=_WeaponModeUse(attack.weaponMode);

	bool isSwing=false;
	bool isThrust=false;
	//if(attackerIsPlayer)
	//{
		//Log(" Use mode = " + use);
		//Log(" attack.WeaponSubtype [WS_UNARMED==1] = " + attack.WeaponSubtype);
	//}


    bool isDummyTraining = target.CrType >= CRTYPE_DUMMY_STAND ? (target.CrType <= CRTYPE_DUMMY_POWER_ARMOR ? true : false) : false;
    if (validAttacker && !attacker.IsPlayer()) {
        isDummyTraining = false;
    }
    string dummyInfo;

	if (isThrustThrowWeapon)  // bronie, ktore maja zamienione primary_attack mode swing na thrust
	{
		if (use == MODE_PRIMARY_ATTACK)
		{
			isSwing=false;
			isThrust=true;
		}
	}

	if (isSwingThrustWeapon) // BRONIE MELEE posiadajace swing/thrust
	{
		if (use == MODE_PRIMARY_ATTACK)
		{
			isSwing=true;
			isThrust=false;
		}

		if (use == MODE_SECONDARY_ATTACK)
		{
			isSwing=false;
			isThrust=true;
		}
	}

	/*  // 30-08-2011 Cubik: bron spear itp w trybie Throwing NIE jest traktowana jako attack.WeaponSubtype == WS_MELEE!!! wiec ponizsze instrukcje sa niepotrzebne
		if((attack.weaponPid==7) || (attack.weaponPid==280) || (attack.weaponPid==320) || (attack.weaponPid==45))  // spear/sharpened spear/sharpened pole/throw knives maja na primary atak thrust a nie swing i stad ta konwersja
		{
			isThrust=false;
			isSwing=false;
			Log("Uzywasz broni typu spear w trybie swing zamienionym na tryb throw, ktory nie jest modyfikowany jako swing czy thrust, lecz jest to zwykle uderzenie (throw dla spear jest jako primary atak)");
		}
	*/



    if(target.IsDead() || !valid(map))
        return;

    if(validAttacker && intentionally && target.Id != attack.TargetId)
        target.EventAttacked(attacker);

    // check if hit
    if(target.Id == attack.TargetId)
        attack.TargetHit = true;

    // Check no PvP
    if(targetIsPlayer && (attackerIsPlayer || (valid(attacker) && _IsFollower(attacker))) && validAttacker && attacker.GetAccess() == ACCESS_CLIENT &&
       (_MapHasMode(map, MAP_MODE_NO_PVP) || attacker.Mode[MODE_NO_PVP] != 0 || target.Mode[MODE_NO_PVP] != 0))
    {
        if(validAttacker)
            attacker.Say(SAY_NETMSG, "No PvP.");
        target.Say(SAY_NETMSG, "No PvP.");
        return;
    }

    if(target.Mode[MODE_HIDE] != 0 && (!target.IsPlayer() || target.GetAccess() == ACCESS_CLIENT))
        target.ModeBase[MODE_HIDE] = 0;

    if(target.Timeout[TO_BATTLE] < int(__TimeoutBattle))
        _SetTimeout(target, TO_BATTLE, __TimeoutBattle);

    if(target.Mode[MODE_INVULNERABLE] != 0) {
        isCritical = false;
    } else if (isCritical || rounds > 1) { // CRITICAL EFFECT
		int aim_ = aim;
        if(aim_ == HIT_LOCATION_NONE)
            aim_ = HIT_LOCATION_UNCALLED;
        aim_--;

        if (isDummyTraining) {
            dummyInfo = "|" + COLOR_DTEXT_CAPTION + " Crit Power :: ";
        }

        int roll = Random(0, 100);
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " Power Roll = |" + COLOR_DTEXT_ROLL + " " + roll;
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Weap Bonus = |" + COLOR_DTEXT_BONUS + " " + attack.SelectWeaponBonus(BONUS_WEAPON_CRITICAL_ROLL);
        }
        roll += attack.SelectWeaponBonus(BONUS_WEAPON_CRITICAL_ROLL);

		//if(isWeaponBetterCriticals)
			//roll += 10;  // +30 dla testow
        //05-03-2014 Cubil: bonus bazowy do broni do crit rolla
		//roll +=AddCritRollWeapon(realWeapon); //disabled with new bypass

		roll -= target.Stat[ST_LUCK];
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Target LK = |" + COLOR_DTEXT_MALUS + " -" + target.Stat[ST_LUCK];
        }

        if (target.Perk[PE_MAN_OF_STEEL] > 0) {
            roll -= 10;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Man of Steel = |" + COLOR_DTEXT_MALUS + " -10";
            }
        }

        if (valid(usedArmor)) {
            roll += usedArmor.Proto.Armor_CMCritPower;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Armor CritPower Mod = |" + COLOR_DTEXT_MALUS + " " + usedArmor.Proto.Armor_CMCritPower;
            }
			roll -= SelectArmorBonus(usedArmor, BONUS_ARMOR_CRIT_POWER);
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Armor craft mod = |" + COLOR_DTEXT_MALUS + " " + SelectArmorBonus(usedArmor, BONUS_ARMOR_CRIT_POWER);
            }
		}

        if (validAttacker) {
            if (attacker.Perk[PE_BETTER_CRITICALS] > 0) {       // +20 with ranged
                if (attack.WeaponSubtype == WS_GUN || attack.WeaponSubtype == WS_THROWING) {
                    roll += 20;
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Better Criticals perk = |" + COLOR_DTEXT_BONUS + " 20";
                    }
                }
            }
            if (attacker.Trait[TRAIT_HEAVY_HANDED] > 0) {       // -20 with hth
                if (attack.WeaponSubtype == WS_UNARMED) {
                    roll -= 20;
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Heavy Handed trait = |" + COLOR_DTEXT_MALUS + " 20";
                    }
                }
            }
            if (attacker.Perk[PE_BETTER_CRITICALS] > 0) {        // +25 with hth/melee
                if (attack.WeaponSubtype == WS_UNARMED) {
                    roll += 25;
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Better Criticals perk = |" + COLOR_DTEXT_BONUS + " 25";
                    }
                }
            }
            if (attacker.Perk[PE_SNIPER] > 0 && aim != HIT_LOCATION_NONE && aim != HIT_LOCATION_UNCALLED && validAttacker && attacker.Trait[TRAIT_FAST_SHOT] == 0) {
                if (attack.WeaponSubtype == WS_GUN) {
                    int distance = GetDistantion(attacker.HexX, attacker.HexY, target.HexX, target.HexY);
                    int bonus = CLAMP(distance < 25 ? (distance - 25) : (distance > 30 ? (distance - 30) : 0), -25, +25);
                    roll += bonus;
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Sniper Critical Power bonus = |" + (bonus >= 0 ? COLOR_DTEXT_BONUS : COLOR_DTEXT_MALUS) + " " + bonus;
                    }
                }
            }
            if (attack.SilentDeathEffect) {
                roll += 10;
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Silent Death perk = |" + COLOR_DTEXT_BONUS + " 10";
                }
            }
        }

        if (target.Trait[TRAIT_BONEHEAD] != 0 && (aim == HIT_LOCATION_HEAD || aim == HIT_LOCATION_EYES)) {
            roll -= 10;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Bonehead trait = |" + COLOR_DTEXT_MALUS + " 10";
            }
        }

        if (aim != HIT_LOCATION_NONE && aim != HIT_LOCATION_UNCALLED && validAttacker && attacker.Trait[TRAIT_FAST_SHOT] == 0) {
            bypassRoll = roll - target.Stat[ST_LUCK];
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Bypass Roll = |" + COLOR_DTEXT_ROLL + " " + roll;
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Target LK factor = |" + COLOR_DTEXT_MALUS + " " + target.Stat[ST_LUCK];
            }
            bypassRoll = CLAMP(bypassRoll, 0, 100);
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Final Bypass Roll = |" + COLOR_DTEXT_ROLL + " " + bypassRoll;
            }
        }

        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Final Crit Power Roll = |" + COLOR_DTEXT_ROLL + " " + roll;
        }
        if (roll <= 20) {
            roll = 0;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  <= 20 Crit Power Roll category = |" + COLOR_DTEXT_BONUS + " " + roll;
            }
        } else if (roll <= 45) {
            roll = 1;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  <= 45 Crit Power Roll category = |" + COLOR_DTEXT_BONUS + " " + roll;
            }
        } else if (roll <= 70) {
            roll = 2;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  <= 70 Crit Power Roll category = |" + COLOR_DTEXT_BONUS + " " + roll;
            }
        } else if (roll <= 90) {
            roll = 3;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  <= 90 Crit Power Roll category = |" + COLOR_DTEXT_BONUS + " " + roll;
            }
        } else if (roll <= 100) {
            roll = 4;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  <= 100 Crit Power Roll category = |" + COLOR_DTEXT_BONUS + " " + roll;
            }
        } else {
            roll = 5;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  > 100 Crit Power Roll category = |" + COLOR_DTEXT_BONUS + " " + roll;
            }
        }

        // 0x00000001 - knockout
        // 0x00000002 - knockdown
        // 0x00000004 - crippled left leg
        // 0x00000008 - crippled right leg
        // 0x00000010 - crippled left arm
        // 0x00000020 - crippled right arm
        // 0x00000040 - blinded
        // 0x00000080 - death
        // 0x00000400 !- on fire - triggers the 'flamedance' animation, but not if the hit is fatal (probably a bug) // not used now
        // 0x00000800 - bypass armor
        // 0x00004000 - dropped weapon (doesn't work) // haha, really?
        // 0x00008000 - lose next turn
        // 0x00200000 - random

        uint offset = (bt > BT_BIG_BAD_BOSS ? 1 : bt) * 9 * 6 * 7 + aim_ * 6 * 7 + roll * 7;

		if (rounds > 1) {
			if (!isCritical) {
				uint maxCriticalQuantity = 70 * rounds / 100;
				for(uint i = 0; i < maxCriticalQuantity; i++) {
					if (Random(1,100) <= CriticalChance) {
						_dmgMul[i] *= CriticalTable[offset];
						_dmgMul[i] >>= 1;
					}
				}
			} else if (isCritical) {
				uint minCriticalQuantity = 80 * rounds / 100;
				if (minCriticalQuantity <=0) {
                    minCriticalQuantity = 1;
				}

				for (uint i = 0; i < minCriticalQuantity; i++) {
					_dmgMul[i] *= CriticalTable[offset];
					_dmgMul[i] >>= 1;
				}

				for (uint i = minCriticalQuantity; i < rounds; i++) {
					if (Random(1,100) <= CriticalChance) {
						_dmgMul[i] *= CriticalTable[offset];
						_dmgMul[i] >>= 1;
					}
				}
			}
		} else {// jezeli pojedynczy strzal to warunek ze krytyczny wczesniej spelniony i zawsze obliczaj tego krytyka
			_dmgMul[0] *= CriticalTable[offset];
			_dmgMul[0] >>= 1;
		}

		if(isCritical) {
			eff = CriticalTable[offset + 1];
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Crit effect = |" + COLOR_DTEXT_REGULAR + " " + eff;
                if (FLAG(eff, HF_KNOCKOUT)) {
                    dummyInfo += " |" + COLOR_DTEXT_REGULAR + " (|" + COLOR_DTEXT_BONUS + " KO|" + COLOR_DTEXT_REGULAR + " )";
                }
                if (FLAG(eff, HF_KNOCKDOWN)) {
                    dummyInfo += " |" + COLOR_DTEXT_REGULAR + " (|" + COLOR_DTEXT_BONUS + " KD|" + COLOR_DTEXT_REGULAR + " )";
                }
                if (FLAG(eff, HF_CRIPPLED_LEFT_LEG)) {
                    dummyInfo += " |" + COLOR_DTEXT_REGULAR + " (|" + COLOR_DTEXT_BONUS + " LL|" + COLOR_DTEXT_REGULAR + " )";
                }
                if (FLAG(eff, HF_CRIPPLED_RIGHT_LEG)) {
                    dummyInfo += " |" + COLOR_DTEXT_REGULAR + " (|" + COLOR_DTEXT_BONUS + " RL|" + COLOR_DTEXT_REGULAR + " )";
                }
                if (FLAG(eff, HF_CRIPPLED_LEFT_ARM)) {
                    dummyInfo += " |" + COLOR_DTEXT_REGULAR + " (|" + COLOR_DTEXT_BONUS + " LA|" + COLOR_DTEXT_REGULAR + " )";
                }
                if (FLAG(eff, HF_CRIPPLED_RIGHT_ARM)) {
                    dummyInfo += " |" + COLOR_DTEXT_REGULAR + " (|" + COLOR_DTEXT_BONUS + " RA|" + COLOR_DTEXT_REGULAR + " )";
                }
                if (FLAG(eff, HF_BLINDED)) {
                    dummyInfo += " |" + COLOR_DTEXT_REGULAR + " (|" + COLOR_DTEXT_BONUS + " BL|" + COLOR_DTEXT_REGULAR + " )";
                }
                if (FLAG(eff, HF_DEATH)) {
                    dummyInfo += " |" + COLOR_DTEXT_REGULAR + " (|" + COLOR_DTEXT_BONUS + " DE|" + COLOR_DTEXT_REGULAR + " )";
                }
                if (FLAG(eff, HF_ON_FIRE)) {
                    dummyInfo += " |" + COLOR_DTEXT_REGULAR + " (|" + COLOR_DTEXT_BONUS + " OF|" + COLOR_DTEXT_REGULAR + " )";
                }
                if (FLAG(eff, HF_BYPASS_ARMOR)) {
                    dummyInfo += " |" + COLOR_DTEXT_REGULAR + " (|" + COLOR_DTEXT_BONUS + " BP|" + COLOR_DTEXT_REGULAR + " )";
                }
                if (FLAG(eff, HF_DROPPED_WEAPON)) {
                    dummyInfo += " |" + COLOR_DTEXT_REGULAR + " (|" + COLOR_DTEXT_BONUS + " DW|" + COLOR_DTEXT_REGULAR + " )";
                }
                if (FLAG(eff, HF_LOST_NEXT_TURN)) {
                    dummyInfo += " |" + COLOR_DTEXT_REGULAR + " (|" + COLOR_DTEXT_BONUS + " LT|" + COLOR_DTEXT_REGULAR + " )";
                }
            }
			int  stat = CriticalTable[offset + 2];
            if (isDummyTraining && stat >= 0) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Stat = |" + COLOR_DTEXT_BONUS + " "
                                + (stat == 0 ? "ST" : (stat == 1 ? "PE" : (stat == 2 ? "EN" : (stat == 3 ? "CH" : (stat == 4 ? "IN" : (stat == 5 ? "AG" : (stat == 6 ? "LK" : "N/A")))))));
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  = |" + COLOR_DTEXT_BONUS + " " + target.Stat[stat];
            }
			int  statMod = CriticalTable[offset + 3];
            if (isDummyTraining && stat >= 0) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Stat mod = |" + (statMod > 0 ? COLOR_DTEXT_BONUS : COLOR_DTEXT_MALUS) + " " + statMod;
            }

			uint cMessage = CriticalTable[offset + 5];
			uint cFailureMessage = CriticalTable[offset + 6];

			// OLD, but keep for reference (for now):
			// Get data for player body type
			// delete offset=MAX_BODY_TYPES*9*6*7+aim_*6*7+roll*7;
			// magic number 1500 = (fonline male player series minus men series)
			// uint cMessageSelf=CriticalTable[offset+5] + 1500; //+ (target.Gender==GENDER_FEMALE?100:0);
			// uint cFailureMessageSelf=CriticalTable[offset+6] +1500; //+ (target.Gender==GENDER_FEMALE?100:0);

			extraMessage = cMessage;

			if (stat != -1) {
                int effectRoll = Random(1, 10);
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Effect Roll = |" + COLOR_DTEXT_ROLL + " " + effectRoll;
                }

				if (effectRoll > target.Stat[stat] + statMod) {
					eff |= CriticalTable[offset + 4];
					extraMessage = cFailureMessage;
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_MALUS + "  RESIST FAIL |" + COLOR_DTEXT_REGULAR + "  vs Stat Resist = |" + COLOR_DTEXT_MALUS + " " + (target.Stat[stat] + statMod);
                    }
				} else {
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_BONUS + "  RESIST SUCCESS |" + COLOR_DTEXT_REGULAR + "  Stat Resist = |" + COLOR_DTEXT_BONUS + " " + (target.Stat[stat] + statMod);
                    }
				}
			}

			if (weaponPerk == WEAPON_PERK_ENHANCED_KNOCKOUT) {
				SETFLAG(eff, HF_KNOCKOUT);
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Weap Perk = |" + COLOR_DTEXT_BONUS + " Knockout";
                }
			}

			if(weaponPerk == WEAPON_PERK_KNOCKBACK) {
				SETFLAG(eff, HF_KNOCKDOWN);
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Weap Perk = |" + COLOR_DTEXT_BONUS + " Knockback";
                }
			}

			if(target.Mode[MODE_NO_KNOCK] != 0) {
				UNSETFLAG(eff, HF_KNOCKDOWN);
                if (isDummyTraining && FLAG(eff, HF_KNOCKDOWN)) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Target mode = |" + COLOR_DTEXT_MALUS + " MODE_NO_KNOCK";
                }
			} else if (target.IsKnockout()) {
                //  already KD/KO, no need to set flag again
                UNSETFLAG(eff, HF_KNOCKDOWN);
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Target is already KO";
                }
			} else if (FLAG(eff, HF_KNOCKDOWN) && target.Perk[PE_STONEWALL] != 0) {
                int stoneWallRoll = Random(1, 10);
                if (stoneWallRoll <= (target.Stat[ST_ENDURANCE] - 3)) {
                    UNSETFLAG(eff, HF_KNOCKDOWN);
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Knockdown averted by Stonewall |" + COLOR_DTEXT_BONUS + " SUCCESS";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( EN = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_ENDURANCE];
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -3";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + stoneWallRoll;
                    }
                } else {
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Knockdown avert by Stonewall |" + COLOR_DTEXT_MALUS + " FAIL";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( EN = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_ENDURANCE];
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -3";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + stoneWallRoll;
                    }
                }
			}

            if (target.IsKnockout()) {
                //  already KO, no need to set flag again
				UNSETFLAG(eff, HF_KNOCKOUT);
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Target is already KO";
                }
            } else if (FLAG(eff, HF_KNOCKOUT) && target.Perk[PE_STONEWALL] != 0) {
			    int stoneWallRoll = Random(1, 10);
                if (stoneWallRoll  <= (target.Stat[ST_ENDURANCE] - 5)) {
                    UNSETFLAG(eff, HF_KNOCKOUT);
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Knockout avert by Stonewall |" + COLOR_DTEXT_BONUS + " SUCCESS";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( EN = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_ENDURANCE];
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -5";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + stoneWallRoll;
                    }
                } else {
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Knockout avert by Stonewall |" + COLOR_DTEXT_MALUS + " FAIL";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( EN = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_ENDURANCE];
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -5";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + stoneWallRoll;
                    }
                }
			}

			// In the following: in no lost limbs, then clear the effects and set msgEff
			//                   otherwise set msgEff first, then check for HF_RANDOM

            msgEff = eff;
            if (FLAG(eff, HF_RANDOM)) {
                UNSETFLAG(eff, HF_RANDOM);
                switch (Random(1, 4)) {
                    case 1:
                        SETFLAG(eff, HF_CRIPPLED_LEFT_LEG);
                        break;
                    case 2:
                        SETFLAG(eff, HF_CRIPPLED_RIGHT_LEG);
                        break;
                    case 3:
                        SETFLAG(eff, HF_CRIPPLED_LEFT_ARM);
                        break;
                    case 4:
                        SETFLAG(eff, HF_CRIPPLED_LEFT_LEG);
                        break;
                    default:
                        break;
                }
            }

			if (target.Perk[PE_IRON_LIMBS] != 0) {
                int ironLimbsRoll = Random(1, 10);
				if (FLAG(eff, HF_CRIPPLED_LEFT_LEG)) {
                    if (ironLimbsRoll <= (target.Stat[ST_ENDURANCE] - 3)) {
                        UNSETFLAG(eff, HF_CRIPPLED_LEFT_LEG);
                        if (isDummyTraining) {
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Cripple Left Leg avert by Iron Limbs |" + COLOR_DTEXT_BONUS + " SUCCESS";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( EN = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_ENDURANCE];
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -3";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + ironLimbsRoll;
                        }
                    } else {
                        if (isDummyTraining) {
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Cripple Left Leg avert by Iron Limbs |" + COLOR_DTEXT_MALUS + " FAIL";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( EN = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_ENDURANCE];
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -3";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + ironLimbsRoll;
                        }
                    }
				}
				if (FLAG(eff, HF_CRIPPLED_RIGHT_LEG)) {
                    if (ironLimbsRoll <= (target.Stat[ST_ENDURANCE] - 3)) {
                        UNSETFLAG(eff, HF_CRIPPLED_RIGHT_LEG);
                        if (isDummyTraining) {
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Cripple Right Leg avert by Iron Limbs |" + COLOR_DTEXT_BONUS + " SUCCESS";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( EN = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_ENDURANCE];
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -3";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + ironLimbsRoll;
                        }
                    } else {
                        if (isDummyTraining) {
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Cripple Right Leg avert by Iron Limbs |" + COLOR_DTEXT_MALUS + " FAIL";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( EN = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_ENDURANCE];
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -3";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + ironLimbsRoll;
                        }
                    }
				}
				if (FLAG(eff, HF_CRIPPLED_LEFT_ARM)) {
                    if (ironLimbsRoll <= (target.Stat[ST_ENDURANCE] - 3)) {
                        UNSETFLAG(eff, HF_CRIPPLED_LEFT_ARM);
                        if (isDummyTraining) {
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Cripple Left Arm avert by Iron Limbs |" + COLOR_DTEXT_BONUS + " SUCCESS";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( EN = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_ENDURANCE];
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -3";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + ironLimbsRoll;
                        }
                    } else {
                        if (isDummyTraining) {
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Cripple Left Arm avert by Iron Limbs |" + COLOR_DTEXT_MALUS + " FAIL";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( EN = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_ENDURANCE];
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -3";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + ironLimbsRoll;
                        }
                    }
				}
				if (FLAG(eff, HF_CRIPPLED_RIGHT_ARM)) {
                    if (ironLimbsRoll <= (target.Stat[ST_ENDURANCE] - 3)) {
                        UNSETFLAG(eff, HF_CRIPPLED_RIGHT_ARM);
                        if (isDummyTraining) {
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Cripple Right Arm avert by Iron Limbs |" + COLOR_DTEXT_BONUS + " SUCCESS";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( EN = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_ENDURANCE];
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -3";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + ironLimbsRoll;
                        }
                    } else {
                        if (isDummyTraining) {
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Cripple Right Arm avert by Iron Limbs |" + COLOR_DTEXT_MALUS + " FAIL";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( EN = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_ENDURANCE];
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -3";
                            dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + ironLimbsRoll;
                        }
                    }
				}
				msgEff = eff;
			}

			if (target.Mode[MODE_NO_LOOSE_LIMBS] != 0) {
				UNSETFLAG(eff, (HF_CRIPPLED_LEFT_LEG | HF_CRIPPLED_RIGHT_LEG | HF_CRIPPLED_LEFT_ARM | HF_CRIPPLED_RIGHT_ARM | HF_RANDOM));
				msgEff = eff;
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_BONUS + " , Target mode: |" + COLOR_DTEXT_ROLL + " MODE_NO_LOOSE_LIMBS";
                }
			}

			if (target.Perk[PE_IRON_LIMBS] > 0) {
                int ironLimbsRoll = Random(1, 10);
			    if (ironLimbsRoll <= target.Stat[ST_STRENGTH] - 4) {
                    UNSETFLAG(eff, HF_DROPPED_WEAPON);
                    UNSETFLAG(msgEff, HF_DROPPED_WEAPON);
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Weap Drop avert by Iron Limbs |" + COLOR_DTEXT_BONUS + " SUCCESS";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( ST = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_STRENGTH];
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -4";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + ironLimbsRoll;
                    }
                } else {
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Weap Drop avert by Iron Limbs |" + COLOR_DTEXT_MALUS + " FAIL";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( ST = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_STRENGTH];
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -4";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + ironLimbsRoll;
                    }
                }
			} else if (target.Mode[MODE_NO_DROP] != 0) {
                UNSETFLAG(eff, HF_DROPPED_WEAPON);
                UNSETFLAG(msgEff, HF_DROPPED_WEAPON);
                if (isDummyTraining && FLAG(eff, HF_DROPPED_WEAPON)) {
                    dummyInfo += "|" + COLOR_DTEXT_BONUS + " , Target mode: |" + COLOR_DTEXT_ROLL + " MODE_NO_DROP";
                }
			}

            if (bypassRoll > 0) {
                SETFLAG(eff, HF_BYPASS_ARMOR);
                SETFLAG(msgEff, HF_BYPASS_ARMOR);
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Bypass (Roll = |" + COLOR_DTEXT_ROLL + " " + bypassRoll;
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  > 0";
                }
            }

			if (validAttacker && attackerIsPlayer)
				AddScore(attacker, SCORE_SNIPER, 1);
		}
	}
	// isCritical end


    if (validAttacker && (weaponPerk == WEAPON_PERK_ENHANCED_KNOCKOUT)) {
        int enhancedKnockoutRoll = Random(1, 10);
		if (enhancedKnockoutRoll <= attacker.Stat[ST_STRENGTH] - 8) {
            SETFLAG(eff, HF_KNOCKOUT);
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Weap Perk Enhanced Knockout |" + COLOR_DTEXT_BONUS + " SUCCESS";
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( Attacker ST = |" + COLOR_DTEXT_BONUS + " " + attacker.Stat[ST_STRENGTH];
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -8";
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + enhancedKnockoutRoll;
            }
		} else {
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Weap Perk Enhanced Knockout |" + COLOR_DTEXT_MALUS + " FAIL";
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( Attacker ST = |" + COLOR_DTEXT_BONUS + " " + attacker.Stat[ST_STRENGTH];
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -8";
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + enhancedKnockoutRoll;
            }
		}
	}

    if (validAttacker && (weaponPerk == WEAPON_PERK_KNOCKBACK)) {
        int knockbackRoll = Random(1, 10);
		if (knockbackRoll <= attacker.Stat[ST_STRENGTH] - 8) {
            SETFLAG(eff, HF_KNOCKDOWN);
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Weap Perk Enhanced Knockout |" + COLOR_DTEXT_BONUS + " SUCCESS";
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( Attacker ST = |" + COLOR_DTEXT_BONUS + " " + attacker.Stat[ST_STRENGTH];
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -8";
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + knockbackRoll;
            }
		} else {
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Weap Perk Enhanced Knockout |" + COLOR_DTEXT_MALUS + " FAIL";
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( Attacker ST = |" + COLOR_DTEXT_BONUS + " " + attacker.Stat[ST_STRENGTH];
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -8";
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + knockbackRoll;
            }
		}
	}
    // not messaged

    // Heavy Handed Trait
    if (validAttacker && attack.IsUnarmed && attacker.Trait[TRAIT_HEAVY_HANDED] > 0) {
        int heavyHandedStrengthMalus = -6;
        if (valid(realWeapon)) {
            switch(realWeapon.Proto.ProtoId) {
                case PID_BRASS_KNUCKLES:
                    heavyHandedStrengthMalus = -5;
                    break;
                case PID_SPIKED_KNUCKLES:
                    heavyHandedStrengthMalus = -4;
                    break;
                case PID_POWER_FIST:
                    heavyHandedStrengthMalus = -3;
                    break;
                case PID_MEGA_POWER_FIST:
                    heavyHandedStrengthMalus = -2;
                    break;
            }
        }
        int heavyHandedRoll = Random(1, 10);
        if (heavyHandedRoll <= (attacker.Stat[ST_STRENGTH] + heavyHandedStrengthMalus)) {
            SETFLAG(eff, HF_KNOCKDOWN);
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Trait Heavy Handed |" + COLOR_DTEXT_BONUS + " SUCCESS";
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( Attacker ST = |" + COLOR_DTEXT_BONUS + " " + attacker.Stat[ST_STRENGTH];
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " " + heavyHandedStrengthMalus;
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + heavyHandedRoll;
            }
        } else {
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Trait Heavy Handed |" + COLOR_DTEXT_MALUS + " FAIL";
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( Attacker ST = |" + COLOR_DTEXT_BONUS + " " + attacker.Stat[ST_STRENGTH];
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " " + heavyHandedStrengthMalus;
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + heavyHandedRoll;
            }
        }
    }


	// ############################################################################################
	// ######################### Beginning Damage Calculations ####################################
	// ############################################################################################


	int dmgType = attack.DmgType;

	if (valid(attack)) {
		if (ammoPid == PID_SHOTGUN_SHELLS_EMP) {
            dmgType = DAMAGE_TYPE_EMP; // if you are using EMP ammo, change the weapon's dmtype
		}
		if (ammoPid == PID_SHOTGUN_DRAGON_BREATH_SHELLS) {
            dmgType=DAMAGE_TYPE_FIRE; // if you are using FIRE ammo, change the weapon's dmtype
		}
	}

	// #################################################
	// ## Melee attack swing and thrust calculations  ##
	// #################################################
	//if (isSwing) { // works similarly to JHP ammo according to the original formula
		//if((targetDT == 0) && (targetDR < 15))   // setting higher DR for "naked" to reduce very high damage values
		//{
		//	targetDR=15;
		//}
		//dmgMul*=5;
		//targetDR+=59;
		//targetDR=CLAMP(targetDR,0,100);
		//targetDT/=0.15;
	//}

	if (isThrust) {  // works similarly to AP ammo according to the original formula
		attack.DMMod = 4;
		attack.DDMod = 5;
		attack.DRMod = -40;
		//targetDR-=40;
		//targetDR=CLAMP(targetDR,0,100);
		//targetDT/=2;
	}
	// swing:thrust END

    int targetDR = target.GetDR(dmgType, attack.AimHead);
    int targetDT = target.GetDT(dmgType, attack.AimHead);

    int partialBypassChance = GetPartialBypassChance(target, attack.AimHead);
    int partialBypassedRounds = 0;
    int armorDR = target.GetArmorDR(dmgType, attack.AimHead);
    int armorDT = target.GetArmorDT(dmgType, attack.AimHead);

    int partialBypassDR = targetDR - armorDR + (armorDR / 4);
    int partialBypassDT = targetDT - armorDT + (armorDT / 4);

    if (isDummyTraining) {
        if (isCritical) {
            dummyInfo += "\n";
        }
        dummyInfo += "|" + COLOR_DTEXT_CAPTION + " Damage Calculations :: ";
        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " Weap Damage Range (|" + COLOR_DTEXT_BONUS + " " + attack.DmgMin + " - " + attack.DmgMax + ")";
        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Target DT = |" + COLOR_DTEXT_BONUS + " " + targetDT;
        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , DR = |" + COLOR_DTEXT_BONUS + " " + targetDR;
    }

    if (FLAG(eff, HF_BYPASS_ARMOR) && dmgType != DAMAGE_TYPE_EMP) {
        bypassValue = (50 * bypassRoll) / 100;
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Bypass Percentage = |" + COLOR_DTEXT_BONUS + " " + bypassValue;
        }
        targetDT -= (targetDT * bypassValue) / 100;
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Target DT = |" + COLOR_DTEXT_BONUS + " " + targetDT;
        }
        targetDR -= (targetDR * bypassValue) / 100;
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Target DR = |" + COLOR_DTEXT_BONUS + " " + targetDR;
        }
        //  I think this is so that Finesse doesn't affect DR when partial resist.
        if (valid(attacker) && attacker.Trait[TRAIT_FINESSE] != 0) {
            targetDR -= 30;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Target DR Finesse DR adjust = |" + COLOR_DTEXT_BONUS + " -30";
            }
        }
    } else if (weaponPerk == WEAPON_PERK_PENETRATE) {
        targetDT /= 5;
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Weap Perk Penetrate (1/5): DT = |" + COLOR_DTEXT_BONUS + " " + targetDT;
        }
    } else if (COMBAT_AMMO_AP(attack.Ammo)) {
        targetDT /= attack.Ammo.Ammo_DTDiv;
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Weap Ammo DT div = |" + COLOR_DTEXT_BONUS + " " + attack.Ammo.Ammo_DTDiv;
        }
	} else if (isThrust) {
		targetDT /= 2;
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Thrust attack: DT = |" + COLOR_DTEXT_BONUS + " " + targetDT;
        }
	}

    if (validAttacker && attacker.Trait[TRAIT_FINESSE] != 0) {
        targetDR += 30;
        partialBypassDR += 30;
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Trait Finesse DR and partialBypass DR |" + COLOR_DTEXT_MALUS + " +30";
        }
    }
    targetDR += attack.DRMod;   // Always
    partialBypassDR += attack.DRMod;
    if (isDummyTraining) {
        if (attack.DRMod != 0) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Attack DR mod |" + (attack.DRMod > 0 ? COLOR_DTEXT_MALUS : COLOR_DTEXT_BONUS) + " " + attack.DRMod;
        }
    }

    partialBypassDR = MIN(partialBypassDR, targetDR);
    targetDR = CLAMP(targetDR, 0, 100);
    partialBypassDR = CLAMP(partialBypassDR, 0, 100);
    partialBypassDT = MIN(partialBypassDT, targetDT);

    int dmgMin = attack.DmgMin + attack.BonusDmg + attack.DmgMin * attack.SelectWeaponBonus(BONUS_WEAPON_MIN_DMG)/100;
    int dmgMax = attack.DmgMax + attack.BonusDmg + attack.DmgMax * attack.SelectWeaponBonus(BONUS_WEAPON_MAX_DMG)/100;
    if (isDummyTraining) {
        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Damage Range (|" + COLOR_DTEXT_BONUS + " " + dmgMin + " - " + dmgMax + ")";
    }
    int rawDmg;
    int totalDmg = 0;
    //dmgMul *= attack.DMMod;
    int dmgDiv = 2 * attack.DDMod;

    for (uint i = 0; i < rounds; i++) {
		rawDmg = Random(dmgMin, dmgMax);
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , |" + COLOR_DTEXT_ROLL + " \nRound " + (i + 1);
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " : Raw Dmg |" + COLOR_DTEXT_BONUS + " " + rawDmg;
        }


        if (isDummyTraining && _dmgMul[i] != 1) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Crit Mult = |" + COLOR_DTEXT_BONUS + " " + _dmgMul[i];
        }
        _dmgMul[i] *= attack.DMMod;
        if (isDummyTraining && attack.DMMod != 1) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Attack dmg mod = |" + (attack.DMMod > 0 ? COLOR_DTEXT_BONUS : COLOR_DTEXT_MALUS) + " " + attack.DMMod;
        }
		rawDmg *= _dmgMul[i];
        rawDmg /= dmgDiv;
        if (isDummyTraining && dmgDiv != 1) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Dmg Div = |" + (dmgDiv < 1 ? COLOR_DTEXT_BONUS : COLOR_DTEXT_MALUS) + " " + dmgDiv;
        }

        if (!FLAG(eff, HF_BYPASS_ARMOR) && partialBypassChance > 0) {
            int partialBypassRoll = Random(1, 100);
            if (partialBypassRoll <= partialBypassChance) {
                rawDmg -= partialBypassDT;
                rawDmg -= (rawDmg * partialBypassDR) / 100;
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Partial Bypass Chance = |" + COLOR_DTEXT_BONUS + " " + partialBypassChance;
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + partialBypassRoll;
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , PBypass DT = |" + COLOR_DTEXT_BONUS + " " + partialBypassDT;
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , PBypass DR = |" + COLOR_DTEXT_BONUS + " " + partialBypassDR;
                }
                partialBypassedRounds++;
            }
        } else {
            rawDmg -= targetDT;
            rawDmg -= (rawDmg * targetDR) / 100;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Target DT = |" + COLOR_DTEXT_MALUS + " " + targetDT;
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Target DR = |" + COLOR_DTEXT_MALUS + " " + targetDR;
            }
        }
        if (rawDmg > 0) {
            totalDmg += rawDmg;
        }
        if (isDummyTraining) {
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , raw Dmg = |" + COLOR_DTEXT_BONUS + " " + rawDmg;
            dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Total Dmg = |" + COLOR_DTEXT_BONUS + " " + totalDmg;
        }
    }

    if (validAttacker) {
        if (attack.Attacker.Perk[PE_PYROMANIAC] != 0 && dmgType == DAMAGE_TYPE_FIRE && ammoPid != PID_SHOTGUN_DRAGON_BREATH_SHELLS) {
            totalDmg += totalDmg / 4; // now +25% fire dmg
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Pyromaniac 25% fire-dmg boost: Total Dmg = |" + COLOR_DTEXT_BONUS + " " + totalDmg;
            }
        }
        if (attack.Attacker.Trait[TRAIT_HEAVY_HANDED] != 0 && attack.IsUnarmed) {
            totalDmg += 5;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Heavy Handed +5 melee boost: Total Dmg = |" + COLOR_DTEXT_BONUS + " " + totalDmg;
            }
        }
        if (attack.Attacker.Trait[TRAIT_ONE_HANDER] != 0 && (valid(realWeapon) && !FLAG(realWeapon.Flags, ITEM_FLAG_TWO_HANDS) && attack.WeaponSubtype != WS_UNARMED)) {
            totalDmg += 5;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , One Hander +5 dmg boost: Total Dmg = |" + COLOR_DTEXT_BONUS + " " + totalDmg;
            }
        }
        if (attack.Attacker.Trait[TRAIT_KAMIKAZE] != 0) {
            totalDmg += totalDmg / 10; // +10% more dmg
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Kamikazee +10% dmg boost: Total Dmg = |" + COLOR_DTEXT_BONUS + " " + totalDmg;
            }
        }
    }

	//if(!isPrimitiveWeapon) totalDmg=0;


    // 0x00000001 - knockout
    // 0x00000002 - knockdown
    // 0x00000004 - crippled left leg
    // 0x00000008 - crippled right leg
    // 0x00000010 - crippled left arm
    // 0x00000020 - crippled right arm
    // 0x00000040 - blinded
    // 0x00000080 - death
    // 0x00000400 !- on fire - triggers the 'flamedance' animation, but not if the hit is fatal (probably a bug)
    // 0x00000800 - bypass armor
    // 0x00004000 !- dropped weapon (doesn't work)
    // 0x00008000 - lose next turn

    // Code for dropping weapon, adapted from critical failures

    if(FLAG(eff, HF_DROPPED_WEAPON))
    {
        Item@ realWeaponTarget = _CritGetItemHand(target);
        if(valid(realWeaponTarget))
        {
            /*
             * NO DROP MODE FOR PLAYERS
             * weapon drops cause weapon to go to inventory instead of ground
             */
            if(target.IsPlayer() && !_PlayerDropEnabled(target, map))
            {
                target.MoveItem(realWeaponTarget.Id, realWeaponTarget.GetCount(), SLOT_INV);
            }
            else if(realWeaponTarget.IsStackable())
            {
                Item@ dropped = map.AddItem(target.HexX, target.HexY, realWeaponTarget.GetProtoId(), 1);
                if(realWeaponTarget.GetCount() > 1)
                    realWeaponTarget.SetCount(realWeaponTarget.GetCount() - 1);
                else
                    DeleteItem(realWeaponTarget);

                if(!target.IsPlayer())
                {
                    NpcPlane@ plane = CreatePlane();
                    array<NpcPlane@> crPlanes(0);

                    if(target.GetPlanes(crPlanes) > 0)
                        plane.Priority = crPlanes[0].Priority + 1;
                    else
                        plane.Priority = 70;

                    plane.Type = AI_PLANE_PICK;
                    plane.Pick_HexX = dropped.HexX;
                    plane.Pick_HexY = dropped.HexY;
                    plane.Pick_Pid = dropped.GetProtoId();
                    plane.Pick_UseItemId = 0;
                    plane.Pick_ToOpen = false;
                    plane.Identifier = PLANE_PICK_DROPPED_WPN;
                    plane.IdentifierExt = dropped.Id;
                    plane.Run = true;
                    target.AddPlane(plane);
                    SetLvar(dropped.Id, LIVAR_npc_wpn_owner, target.Id);
                }
            }
            else
            {
                MoveItem(realWeaponTarget, 0, map, target.HexX, target.HexY);
                if(!target.IsPlayer())
                {
                    NpcPlane@ plane = CreatePlane();
                    array<NpcPlane@> crPlanes(0);

                    if(target.GetPlanes(crPlanes) > 0)
                        plane.Priority = crPlanes[0].Priority + 1;
                    else
                        plane.Priority = 70;

                    plane.Type = AI_PLANE_PICK;
                    plane.Pick_HexX = realWeaponTarget.HexX;
                    plane.Pick_HexY = realWeaponTarget.HexY;
                    plane.Pick_Pid = realWeaponTarget.GetProtoId();
                    plane.Pick_UseItemId = 0;
                    plane.Pick_ToOpen = false;
                    plane.Identifier = PLANE_PICK_DROPPED_WPN;
                    plane.IdentifierExt = realWeaponTarget.Id;
                    plane.Run = true;
                    target.AddPlane(plane);
                    SetLvar(realWeaponTarget.Id, LIVAR_npc_wpn_owner, target.Id);
                }
            }
        }
    }



	bool isOffGame = false;
    bool isKo = false;
    bool knockDown = false;
    bool knockOut = false;
    bool isDead = false;
    bool loseTurn = false;
    bool isBelow = false;
    int  knockDmg = totalDmg;

    if (target.Mode[MODE_INVULNERABLE] != 0) {
        eff = 0;
    } else {
        eff = eff & (~target.Mode[MODE_NEGATE_CRIT_EFF]);
        msgEff = msgEff & (~target.Mode[MODE_NEGATE_CRIT_EFF]);
    }
    // If already knocked down from critical, no need to check again, otherwise check for other KD mechanics
    if (FLAG(eff, HF_KNOCKDOWN)) {
		isKo = true;
        knockDown = true;
    } else if ((dmgType == DAMAGE_TYPE_EXPLODE) && (totalDmg > 9) && valid(realWeapon) && realWeapon.Proto.ProtoId!=PID_DYNACORD) {//25-07-2013 Cubik: dynacord nie bedzie przewracal, miny, plastiki i dynamit beda wywracac
		if (target.Perk[PE_STONEWALL] != 0) {
            //  ST-5 *20 > random(1, 105) vs explosion/shotgun KD roll changed to ST-2 *10 > random(1, 100) roll
            //  meaning chance to avoid such KD changed for chars with 10 -> 6 ST from 95%, 76%, 57%, 38%, 19% into 80%, 70%, 60%, 50%, 40%
            int stonewallRoll = Random(1, 100);
			if ((target.Stat[ST_STRENGTH] - 2) * 10 > stonewallRoll) {
			    isKo = false;
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Explosion KD avert by Stonewall: |" + COLOR_DTEXT_BONUS + " SUCCESS";
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( ST = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_STRENGTH];
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -2";
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + stonewallRoll;
                }
            } else {
				isKo = true;
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Explosion KD avert by Stonewall: |" + COLOR_DTEXT_MALUS + " FAIL";
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( ST = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_STRENGTH];
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -2";
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + stonewallRoll;
                }
			}
		} else {
			isKo = true;
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , " + COLOR_DTEXT_MALUS + " Explosion KD";
            }
		}
	} else if (isShotgun && rounds > 1 && GetDistantion(attack.Attacker.HexX, attack.Attacker.HexY, target.HexX, target.HexY) <= 10) {
        int shotgunKnockdownRoll = Random(1, 10);
        if (shotgunKnockdownRoll <= int(rounds)) {
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Shotgun KD effect: |" + COLOR_DTEXT_BONUS + " " + " SUCCESS";
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( Rounds = |" + COLOR_DTEXT_BONUS + " " + rounds;
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + shotgunKnockdownRoll + "|" + COLOR_DTEXT_REGULAR + "  )";
            }
            if (target.Perk[PE_STONEWALL] != 0) {
                int stonewallRoll = Random(1, 100);
                if ((target.Stat[ST_STRENGTH] - 2) * 10 > stonewallRoll) {
                    isKo = false;
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Shotgun KD avert by Stonewall: |" + COLOR_DTEXT_BONUS + " SUCCESS";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( ST = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_STRENGTH];
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -2";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + stonewallRoll + "|" + COLOR_DTEXT_REGULAR + "  )";
                    }
                } else {
                    isKo = true;
                    if (isDummyTraining) {
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Shotgun KD avert by Stonewall: |" + COLOR_DTEXT_MALUS + " FAIL";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( ST = |" + COLOR_DTEXT_BONUS + " " + target.Stat[ST_STRENGTH];
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Modifier = |" + COLOR_DTEXT_MALUS + " -2";
                        dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + stonewallRoll + "|" + COLOR_DTEXT_REGULAR + "  )";
                    }
                }
            }
        } else {
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Shotgun KD effect: |" + COLOR_DTEXT_MALUS + " " + " FAIL";
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " ( Rounds = |" + COLOR_DTEXT_BONUS + " " + rounds;
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + "  vs Roll = |" + COLOR_DTEXT_ROLL + " " + shotgunKnockdownRoll + "|" + COLOR_DTEXT_REGULAR + "  )";
            }
        }
    }

    // Clipped LLeg
    if(FLAG(eff, HF_CRIPPLED_LEFT_LEG))
        target.DamageBase[DAMAGE_LEFT_LEG] = 1;
    // Clipped RLeg
    if(FLAG(eff, HF_CRIPPLED_RIGHT_LEG))
        target.DamageBase[DAMAGE_RIGHT_LEG] = 1;
    // Clipped LArm
    if(FLAG(eff, HF_CRIPPLED_LEFT_ARM))
        target.DamageBase[DAMAGE_LEFT_ARM] = 1;
    // Clipped RArm
    if(FLAG(eff, HF_CRIPPLED_RIGHT_ARM))
        target.DamageBase[DAMAGE_RIGHT_ARM] = 1;
    // Blinded
    if(FLAG(eff, HF_BLINDED))
        target.DamageBase[DAMAGE_EYE] = 1;

    // Lose turn
    if(FLAG(eff, HF_LOST_NEXT_TURN))
    {
        isKo = true;
        loseTurn = true;
    }

    // Knock out
    if(FLAG(eff, HF_KNOCKOUT))
    {
        //Log("Flaga jest HF_KNOCKOUT");
		isKo = true;
        knockOut = true;
        loseTurn = false;       // Overridden
    }

    // Instant death
    if(FLAG(eff, HF_DEATH))
        if(target.Stat[ST_CURRENT_HP] > totalDmg)
            totalDmg = target.Stat[ST_CURRENT_HP];


    //  BNW MECHANICS CHANGE: see issue #110 https://github.com/Sasabmeg/FOnline-BraveNewWorld/issues/110
    if(target.Mode[MODE_INVULNERABLE] == 0) {
        //  Add extra fire damage based on BURNT status
        int oldDmg = totalDmg;
        if (dmgType == DAMAGE_TYPE_FIRE) {
            //  make sure no immunity/vulnerability bug due to server crash
            if (target.ParamBase[TO_EX_BURNT] > int(GetTick())) {
                target.ParamBase[TO_EX_BURNT] = GetTick();
            }
            //  fire hit/explosion effect
            uint16 stepX = target.HexX;
            uint16 stepY = target.HexY;
            map.MoveHexByDir(stepX, stepY, 0, 1);
            map.MoveHexByDir(stepX, stepY, 5, 1);
            if (oldDmg > 50) {
                map.RunEffect(PID_EXPLODE_FIRE_BIG, stepX, stepY, 0);
            } else if (oldDmg > 35) {
                map.RunEffect(PID_EXPLODE_FIRE_SMALL, stepX, stepY, 0);
            }
            if (target.ParamBase[TO_EX_BURNT] + BURN_EFFECT_LINGER_TIME > int(GetTick())) {
                float burntFactor = float(100 + CLAMP(target.ParamBase[ST_EX_BURNT], 0, 100)) / 100;
                totalDmg = int(totalDmg * burntFactor);
                //attack.Attacker.Say(SAY_NETMSG, "Burnt factor = " + burntFactor + ", currentBurnt% = " + target.ParamBase[ST_EX_BURNT] + ", oldDamage = " + oldDmg + ", newDamage = " + totalDmg);
                //Log("Burnt factor = " + burntFactor + ", currentBurnt = " + target.ParamBase[ST_EX_BURNT] + ", oldDamage = " + oldDmg + ", newDamage = " + totalDmg);
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , " + COLOR_DTEXT_BONUS + " Fire Vulnerability Stacking Mechanic";
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Old Fire Vul. = |" + COLOR_DTEXT_BONUS + " " + target.ParamBase[ST_EX_BURNT] + "%";
                }
                target.ParamBase[ST_EX_BURNT] = CLAMP(target.ParamBase[ST_EX_BURNT] + oldDmg / 4, 0, 100);
                if (isDummyTraining) {
                    dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , New Fire Vul. = |" + COLOR_DTEXT_BONUS + " " + target.ParamBase[ST_EX_BURNT] + "%";
                }
                //attack.Attacker.Say(SAY_NETMSG, "Current Burnt = " + target.ParamBase[ST_EX_BURNT]);
                //Log("Current Burnt = " + target.ParamBase[ST_EX_BURNT]);
                target.ParamBase[TO_EX_BURNT] = GetTick();
            } else {
                //attack.Attacker.Say(SAY_NETMSG, "First fire damage");
                //Log("First fire damage");
                target.ParamBase[ST_EX_BURNT] = CLAMP(oldDmg / 4, 0, 100);
                target.ParamBase[TO_EX_BURNT] = GetTick();
            }
        }
        if (dmgType == DAMAGE_TYPE_PLASMA) {
            //  make sure no immunity/vulnerability bug due to server crash
            if (target.ParamBase[TO_EX_IRREMEDIABLE] > int(GetTick())) {
                target.ParamBase[TO_EX_IRREMEDIABLE] = GetTick();
            }
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , " + COLOR_DTEXT_BONUS + " Irremediable Mechanic";
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Old Irremediable = |" + COLOR_DTEXT_BONUS + " " + target.ParamBase[ST_EX_IRREMEDIABLE] + "%";
            }
            int burstTotalDamageEffect = totalDmg;
            if (rounds > 1) {
                burstTotalDamageEffect /= rounds;
            }
            if (target.ParamBase[TO_EX_IRREMEDIABLE] + PLASMA_EFFECT_LINGER_TIME > int(GetTick())) {
                if (burstTotalDamageEffect > target.ParamBase[ST_EX_IRREMEDIABLE]) {
                    target.ParamBase[ST_EX_IRREMEDIABLE] = CLAMP(burstTotalDamageEffect, 0, 100);
                    target.ParamBase[TO_EX_IRREMEDIABLE] = GetTick();
                    //attack.Attacker.Say(SAY_NETMSG, "Current Irremediable% = " + target.ParamBase[ST_EX_IRREMEDIABLE]);
                    //Log("Current Irremediable% = " + target.ParamBase[ST_EX_IRREMEDIABLE]);
                } else {
                    target.ParamBase[TO_EX_IRREMEDIABLE] = GetTick();
                    //attack.Attacker.Say(SAY_NETMSG, "Current Irremediable% = " + target.ParamBase[ST_EX_IRREMEDIABLE]);
                    //Log("Current Irremediable% = " + target.ParamBase[ST_EX_IRREMEDIABLE]);
                }
            } else {
                target.ParamBase[ST_EX_IRREMEDIABLE] = CLAMP(burstTotalDamageEffect, 0, 100);
                target.ParamBase[TO_EX_IRREMEDIABLE] = GetTick();
                //attack.Attacker.Say(SAY_NETMSG, "Current Irremediable% = " + target.ParamBase[ST_EX_IRREMEDIABLE]);
                //Log("Current Irremediable% = " + target.ParamBase[ST_EX_IRREMEDIABLE]);
            }
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , New Irremediable = |" + COLOR_DTEXT_BONUS + " " + target.ParamBase[ST_EX_IRREMEDIABLE] + "%";
            }
        }
        if (dmgType == DAMAGE_TYPE_ELECTR || dmgType == DAMAGE_TYPE_EMP) {
            //  make sure no immunity/vulnerability bug due to server crash
            if (target.ParamBase[TO_EX_SHOCKED] > int(GetTick())) {
                target.ParamBase[TO_EX_SHOCKED] = GetTick();
            }
            if (target.ParamBase[TO_EX_SHOCKED] + SHOCK_EFFECT_LINGER_TIME < int(GetTick())) {
                uint16 stepX = target.HexX;
                uint16 stepY = target.HexY;
                map.MoveHexByDir(stepX, stepY, 0, 1);
                map.MoveHexByDir(stepX, stepY, 5, 1);
                map.RunEffect(PID_EXPLODE_EMP, stepX, stepY, 0);
                int dirRoll = Random(0, 1);
                stepX = target.HexX;
                stepY = target.HexY;
                map.MoveHexByDir(stepX, stepY, 0 + dirRoll, 1);
                map.RunEffect(PID_EXPLODE_EMP, stepX, stepY, 0);
                stepX = target.HexX;
                stepY = target.HexY;
                map.MoveHexByDir(stepX, stepY, 2 + dirRoll, 1);
                map.RunEffect(PID_EXPLODE_EMP, stepX, stepY, 0);
                stepX = target.HexX;
                stepY = target.HexY;
                map.MoveHexByDir(stepX, stepY, 4 + dirRoll, 1);
                map.RunEffect(PID_EXPLODE_EMP, stepX, stepY, 0);
                map.RunEffect(PID_EXPLODE_EMP, target.HexX, target.HexY, 0);
                int apLoss = 0;
                if (dmgType == DAMAGE_TYPE_ELECTR) {
                    apLoss = 2 + Random(0, totalDmg / 20);
                } else {
                    apLoss = Random(1, 3);
                }
                //attack.Attacker.Say(SAY_NETMSG, "Target old AP = " + target.StatBase[ST_CURRENT_AP]);
                //Log("Target old AP = " + target.StatBase[ST_CURRENT_AP]);
                if (target.StatBase[ST_CURRENT_AP] - 100 * apLoss > 0) {
                    target.StatBase[ST_CURRENT_AP] -= 100 * apLoss;
                } else {
                    target.StatBase[ST_CURRENT_AP] -= target.StatBase[ST_CURRENT_AP];
                }
                //target.StatBase[ST_CURRENT_AP] = (target.StatBase[ST_CURRENT_AP] - 100 * apLoss > 0 ? target.StatBase[ST_CURRENT_AP] - 100 * apLoss : 0);
                target.ParamBase[TO_EX_SHOCKED] = GetTick();
                target.Say(SAY_NETMSG, "You have been shocked, impairing your movement and losing " + apLoss + " action points.");
                //attack.Attacker.Say(SAY_NETMSG, "Target AP loss = " + apLoss + ", new AP = " + target.StatBase[ST_CURRENT_AP] + ", timer = " + target.ParamBase[TO_EX_SHOCKED]);
                //Log("Target AP loss = " + apLoss + ", new AP = " + target.StatBase[ST_CURRENT_AP] + ", timer = " + target.ParamBase[TO_EX_SHOCKED]);
                if (target.ParamBase[MODE_NO_RUN] == 0 && target.GetTimeEvents(CTE_ALLOW_RUN, null, null, null) == 0) {
                    target.ParamBase[MODE_NO_RUN] = 1;
                    //  EMP grenade
                    int duration = Random(950, 1250);
                    bool isGrenade = false;
                    int skillNum = 0;
                    if (valid(realWeapon)) {
                        skillNum = _WeaponSkill(realWeapon.Proto, use);
                        isGrenade = (skillNum == SK_THROWING);
                    }
                    if (isGrenade) {
                        duration -= 500;
                    }
                    duration += CLAMP((10 - target.StatBase[ST_STRENGTH]) * 250, 0, 2500);
                    //  increase duration for PVE for fun mechanics/tactics, no need to balance that much here
                    if (!targetIsPlayer) {
                        duration = 3 + duration * 5;
                    }
                    target.AddTimeEvent("cte_AllowRunAgain", REAL_MS(duration), CTE_ALLOW_RUN);
                    //attack.Attacker.Say(SAY_NETMSG, "Target run disabled, reset in 3 seconds.");
                    //Log("Target run disabled, reset in 3 seconds.");
                    FloatingStatusChangeText(target, duration, STATUS_TEXT_REASON_SHOCKED);
                } else {
                    //  this probably never happens
                    //attack.Attacker.Say(SAY_NETMSG, "Target not able to run or another run suppressing effect already in use.");
                    //Log("Target not able to run or another run suppressing effect already in use.");
                }
            } else {
                uint16 stepX = target.HexX;
                uint16 stepY = target.HexY;
                map.MoveHexByDir(stepX, stepY, 0, 1);
                map.MoveHexByDir(stepX, stepY, 5, 1);
                map.RunEffect(PID_EXPLODE_EMP, stepX, stepY, 0);
                //attack.Attacker.Say(SAY_NETMSG, "Target was already shocked recently");
                //Log("Target was already shocked recently");
            }
        }
    }
    //  BNW MECHANICS CHANGE END

    if(totalDmg > 0)
    {
        if(target.Mode[MODE_INVULNERABLE] == 0)
        {

            /*********************************************************
             CHARGING TARGET'S TESLA ARMOR BASED ON RECIEVED EW DAMAGE
            **********************************************************/
            if(attack.DmgType == DAMAGE_TYPE_LASER || attack.DmgType == DAMAGE_TYPE_PLASMA || attack.DmgType == DAMAGE_TYPE_ELECTR || attack.DmgType == DAMAGE_TYPE_EMP)
            {
                Item@ targetsArmor = target.GetItem(0, SLOT_ARMOR);
                if(valid(targetsArmor) && targetsArmor.GetProtoId() == PID_TESLA_ARMOR)
                {
                    uint recharge = totalDmg/4;
                    if(recharge > 0 && targetsArmor.Charge < targetsArmor.Proto.Misc_ChargeMax)
                    {
                        targetsArmor.Charge += recharge;
                        if(targetsArmor.Charge > targetsArmor.Proto.Misc_ChargeMax)
                            targetsArmor.Charge = targetsArmor.Proto.Misc_ChargeMax;
                        targetsArmor.Update();
                        target.Say(SAY_NETMSG, "Charging armor with "+recharge+" charges.");
                        target.Say(SAY_NETMSG, "Charges: "+targetsArmor.Charge+"/"+targetsArmor.Proto.Misc_ChargeMax+".");
                    }
                }
            }
            //END

            target.StatBase[ST_CURRENT_HP] -= totalDmg;
            if(target.Stat[ST_CURRENT_HP] < 1)
            {
                int deadHitPoints = target.Perk[PE_DEAD_MAN_WALKING] > 0 ? __DeadHitPoints : __DeadHitPoints / 2;
                if(target.Trait[TRAIT_BLOODY_MESS] != 0 || (validAttacker && attack.Attacker.Trait[TRAIT_BLOODY_MESS] != 0))
                {
                    deadHitPoints = 0;
                    isBloodyMess = true;
                }
                if(target.Stat[ST_CURRENT_HP] > deadHitPoints && IsHumanoid(target) && target.Mode[MODE_NO_KNOCK] == 0)
                {
                    isKo = true;
                    isBelow = true;
                }
                else
                    isDead = true;
            }
        }
        // Add leaderboard score
        if(attack.IsUnarmed && validAttacker && attackerIsPlayer)
            AddScore(attacker, SCORE_UNARMED_DAMAGE, totalDmg);
    }

    bool attackFront = true;
    uint dir = GetDirection(attack.Hx, attack.Hy, target.HexX, target.HexY);
    if((dir == target.Dir || ((dir + 1) % 6) == target.Dir || ((dir + 5) % 6) == target.Dir))
        attackFront = false;

    int   armorDr = target.GetDR(dmgType, attack.AimHead);
    Item@ armor_ = _GetCritterArmor(target, attack.AimHead);


	if(valid(armor_) && targetIsPlayer)
	{
		if(attackerIsPaszczur)
		{
			WearItem(target, armor_, ((100 - armorDr) * rounds + 2 * totalDmg) / 3);
		}
		else
			WearItem(target, armor_, ((100 - armorDr) * rounds + totalDmg) / 6);
	}

	// 30-08-2013 Cubik: Banhammer effect - kick player from game
	if(isOffGame)
	{
		if(target.IsPlayer()) target.Disconnect();
	}

    // Dead
    if(isDead)
    {
        bool burst = attack.IsBurst;
        uint anim2Dead = 0;

        if(target.IsKnockout())
        {
            if(target.Anim2Knockout == ANIM2_IDLE_PRONE_FRONT)
                anim2Dead = ANIM2_DEAD_PRONE_FRONT;
            else
                anim2Dead = ANIM2_DEAD_PRONE_BACK;
        }
        else
        {
            if(attackFront)
                anim2Dead = ANIM2_DEAD_FRONT;
            else
                anim2Dead = ANIM2_DEAD_BACK;

            switch(dmgType)
            {
            case DAMAGE_TYPE_UNCALLED:
                break;
            case DAMAGE_TYPE_NORMAL:
                if(burst)
                {
                    if(isCritical || isBloodyMess)
                        anim2Dead = ANIM2_DEAD_BLOODY_BURST;
                    else
                        anim2Dead = ANIM2_DEAD_BURST;
                }
                else
                {
                    if(isCritical || isBloodyMess)
                        anim2Dead = ANIM2_DEAD_BLOODY_SINGLE;
                }
                break;
            case DAMAGE_TYPE_LASER:
                anim2Dead = ANIM2_DEAD_LASER;
                break;
            case DAMAGE_TYPE_FIRE:
                if(isCritical || isBloodyMess)
                {
                    if(isBloodyMess || Random(0, 3) == 0)
                        anim2Dead = ANIM2_DEAD_BURN_RUN;
                    else
                        anim2Dead = ANIM2_DEAD_BURN;
                }
                else
                    anim2Dead = ANIM2_DEAD_BURN;
                break;
            case DAMAGE_TYPE_PLASMA:
                anim2Dead = ANIM2_DEAD_FUSED;
                break;
            case DAMAGE_TYPE_ELECTR:
                if(Random(0, 1) == 0)
                    anim2Dead = ANIM2_DEAD_PULSE;
                else
                    anim2Dead = ANIM2_DEAD_PULSE_DUST;
                break;
            case DAMAGE_TYPE_EXPLODE:
                anim2Dead = ANIM2_DEAD_EXPLODE;
                break;
            default:
                break;
            }
            if(target.Param[MODE_SPECIAL_DEAD] != 0)
            {
                target.SetDir(0);
                anim2Dead = ANIM2_DEAD_EXPLODE;
            }
        }

        if(targetIsPlayer)
            AddScore(target, SCORE_ZOMBY, 1);
        if(validAttacker && attackerIsPlayer)
        {
            AddScore(attacker, SCORE_KILLER, 1);
            if(targetIsPlayer)
            {
                AddScore(attacker, SCORE_MANIAC, 1);
            }
            else if(target.Id == attack.TargetId)
                target.AddEnemyInStack(attacker.Id);
        }

        if(validAttacker && !attackerIsPlayer)
            attacker.EraseEnemyFromStack(target.Id);

        if(valid(attacker))
        {
            // OLD VERSION
            /*
            if(bt != BT_MEN && bt != BT_WOMEN && bt != BT_SUPER_MUTANT && bt != BT_GHOUL && bt != BT_CHILDREN && bt != BT_BRAHMIN || !IsTown(map))
                attacker.StatBase[ST_EXPERIENCE] += target.Stat[ST_KILL_EXPERIENCE];
            attacker.KillBase[KILL_BEGIN + bt]++;
            if(target.IsNpc())
                LogExperience(attacker, target.Stat[ST_KILL_EXPERIENCE], valid(realWeapon) ? realWeapon.Proto.Weapon_Skill_0 : SK_UNARMED, "Kill", target.GetProtoId()); // may cause errors with spear
            */
            //_OLD VERSION_

            //_NEW VERSION_
            if(IsTown(map))
            {
                if(bt != BT_MEN && bt != BT_WOMEN && bt != BT_SUPER_MUTANT && bt != BT_GHOUL && bt != BT_CHILDREN && bt != BT_BRAHMIN)
                    attacker.StatBase[ST_EXPERIENCE] += target.Stat[ST_KILL_EXPERIENCE];
            }
            else
            {
                // VERSION3 - all alive players who see killed critter and are grouped by follow tags
                if(attackerIsPlayer)
                {
                    array<Critter@> playersToShare;
                    int             cnt = 0;
                    int             exp = 0;
                    int             expDiv = 0;

                    //players who see killed critter
                    cnt = target.GetCritters(true, FIND_LIFE | FIND_ONLY_PLAYERS, playersToShare);
                    if(cnt > 0)
                    {
                        //filter players who are following me or my leader
                        Critter@ myLeader = attacker.GetFollowLeader();
                        for(int i=0; i < cnt; ++i)
                        {
                            ++expDiv;
                            //player is attacker
                            if(playersToShare[i].Id == attacker.Id)
                                continue;

                            //player is followed by attacker
                            if(valid(myLeader) && playersToShare[i].Id == myLeader.Id)
                                continue;

                            Critter@ tmpLeader = playersToShare[i].GetFollowLeader();
                            //player is following attacker
                            if(valid(tmpLeader) && attacker.Id == tmpLeader.Id)
                                continue;

                            //player is following attacker's leader
                            if(valid(tmpLeader) && valid(myLeader) && tmpLeader.Id == myLeader.Id)
                                continue;

                            //no match - remove player from array
                            playersToShare.removeAt(i);
                            --i;
                            --cnt;
                            --expDiv;
                        }

                        if(expDiv > 0)
                            exp = target.Stat[ST_KILL_EXPERIENCE]/expDiv;
                        else
                            exp = 0;

                        if(exp > 0)
                        {
                            for(int i=0; i < expDiv; ++i)
                            {
                                if(playersToShare[i].Id == attacker.Id && expDiv > 1)
                                    playersToShare[i].StatBase[ST_EXPERIENCE] += int(exp*1.25);      //killer gets 25% bonus exp when in group
                                else
                                    playersToShare[i].StatBase[ST_EXPERIENCE] += exp;
                            }
                        }
                    }
                }
                else
                {
                    attacker.StatBase[ST_EXPERIENCE] += target.Stat[ST_KILL_EXPERIENCE];
                }

                // _VERSION3_

            }

            attacker.KillBase[KILL_BEGIN + bt]++;
            //_NEW VERSION_
        }

        //player's weapon deterioration for NO DROP
        if(targetIsPlayer && !_PlayerDropEnabled(target, map))
        {
            WearHandsOnDeath(target);
        }

        if(_IsTrueNpc(target) && IsEncounterMap(map))
        {
            Item@ itemHand1 = target.GetItem(0, SLOT_HAND1);
            if(valid(itemHand1))
            {
                if(itemHand1.GetType() == ITEM_TYPE_WEAPON)
                {
                    uint8 roll = Random(0, 100);
                    if(roll < 30 || (itemHand1.Val0 >= BONUS_WEAPON_CRITICAL_ROLL && itemHand1.Val0 <= BONUS_WEAPON_MAX_RANGE))
                    { }
                    else if(roll < 60 && itemHand1.IsDeteriorable())
                    {
                        SetMinWear(itemHand1, 100);
                        itemHand1.AmmoCount = 0;
                        itemHand1.Update();
                    }
                    else
                        DeleteItem(itemHand1);
                }
            }

            Item@ itemHand2 = target.GetItem(0, SLOT_HAND2);
            if(valid(itemHand2))
            {
                if(itemHand2.GetType() == ITEM_TYPE_WEAPON)
                {
                    uint8 roll = Random(0, 100);
                    if(roll < 30 || (itemHand2.Val0 >= BONUS_WEAPON_CRITICAL_ROLL && itemHand2.Val0 <= BONUS_WEAPON_MAX_RANGE))
                    { }
                    else if(roll < 60 && itemHand2.IsDeteriorable())
                    {
                        SetMinWear(itemHand2, 100);
                        itemHand2.AmmoCount = 0;
                        itemHand2.Update();
                    }
                    else
                        DeleteItem(itemHand2);
                }
            }
        }

        target.ToDead(anim2Dead, attacker);
    }
    else
	if(isKo)
    {
        //Log("isKo = True");
		int  maxAp = target.Stat[ST_ACTION_POINTS];
        int  currentAp = target.Stat[ST_CURRENT_AP];
        int  targetAp = currentAp;
        bool quick = target.Perk[PE_QUICK_RECOVERY] > 0;
        float intellectFactor = ((1.0 / 3.0) + (2.0 * (10.0 - target.Stat[ST_INTELLECT]) / 9.0));
        if (loseTurn) {
            targetAp = quick ? (-maxAp / 3) : (-maxAp * intellectFactor);
            target.StatBase[ST_MOVE_AP] = 0;
        }

        if (knockOut) {
            targetAp = quick ? -Random(maxAp, 3 * maxAp) / 3 : -Random(maxAp, 3 * maxAp) * intellectFactor;
        }

		if (knockDown && !(target.IsKnockout() && map.IsTurnBased())) {
            targetAp -= quick ? 1 : (3 * intellectFactor);
		}

		if((isBelow || knockOut || knockDown || dmgType == DAMAGE_TYPE_EXPLODE || isShotgun ) && !target.IsKnockout() && target.Mode[MODE_NO_KNOCK] == 0)
        {
            //Log("jest knockOut albo knockDown");
			int knockDist = knockDmg;
			//Log("knockDist = " + knockDist);
            if((dmgType == DAMAGE_TYPE_EXPLODE || isShotgun || weaponPerk == WEAPON_PERK_KNOCKBACK) && target.IsCanWalk())
            {
				if(weaponPerk == WEAPON_PERK_KNOCKBACK)
                    knockDist /= 5;
                else
                    knockDist /= 10;
                if(target.Perk[PE_STONEWALL] != 0)
                    knockDist /= 2;
                knockDist--;
//Log("knockDist = " + knockDist);
                if(knockDist > 10)
                    knockDist = 10;
                uint16 knockHx = attack.Hx;
                uint16 knockHy = attack.Hy;
                if(knockDist > 0)
                {
                    map.GetHexCoordWall(target.HexX, target.HexY, knockHx, knockHy, 180.0f, knockDist);
                    target.ToKnockout(KNOCKOUT_ANIM2_DEFAULT(attackFront), 0, knockHx, knockHy);
                }
                else
                    target.ToKnockout(KNOCKOUT_ANIM2_DEFAULT(attackFront), 0, target.HexX, target.HexY);
            }
            else
                target.ToKnockout(KNOCKOUT_ANIM2_DEFAULT(attackFront), 0, target.HexX, target.HexY);
        }
        if(targetAp < currentAp)
            target.StatBase[ST_CURRENT_AP] = 100 * targetAp;
    }

    // Damage
    else if(!(target.IsKnockout() || FLAG(target.Mode[MODE_EXT], MODE_EXT_NO_HIT_ANIM)))
    {
        // Animate hit
        if(attack.ShowHitAnimForce)
            target.Action(CRITTER_ACTION_DAMAGE_FORCE, attackFront ? 0 : 1, null);
        else
            target.Action(CRITTER_ACTION_DAMAGE, attackFront ? 0 : 1, null);

        // Npc hit message
        if(isCombatText && dmgType != DAMAGE_TYPE_UNCALLED && !targetIsPlayer)
        {
            switch(aim)
            {
            case HIT_LOCATION_NONE:
            case HIT_LOCATION_UNCALLED:
            case HIT_LOCATION_TORSO:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_TORSO);
                break;
            case HIT_LOCATION_EYES:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_EYES);
                break;
            case HIT_LOCATION_HEAD:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_HEAD);
                break;
            case HIT_LOCATION_LEFT_ARM:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_LEFT_ARM);
                break;
            case HIT_LOCATION_RIGHT_ARM:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_RIGHT_ARM);
                break;
            case HIT_LOCATION_GROIN:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_GROIN);
                break;
            case HIT_LOCATION_RIGHT_LEG:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_RIGHT_LEG);
                break;
            case HIT_LOCATION_LEFT_LEG:
                AI_TrySayCombatText(target, COMBAT_TEXT_HIT_LEFT_LEG);
                break;
            default:
                break;
            }
        }
    }

    bool isAimed = (aim != HIT_LOCATION_NONE) && (aim != HIT_LOCATION_UNCALLED);

    uint mainMsg = CMSG_HIT;
    uint length = 4;

    if(isCritical)
    {
        mainMsg += 2;
        length += 2;
    }
    if(isDead)
    {
        mainMsg += 4;
        // if(isCritical) length-=1;
    }
    if(isAimed)
    {
        mainMsg += 1;
        length += 1;
    }
    if(isAimed && isCritical)
    {
        length += 1;
    }

    array<uint> sendEff(length);
    sendEff[0] = mainMsg;
    sendEff[1] = target.Id;
    sendEff[2] = (valid(attacker))?attacker.Id:0;
    uint now = 3;
//Log("SENDEFF "+sendEff[0]+" "+sendEff[1]+" "+sendEff[2]);
    if(isAimed)
    {
        sendEff[now] = aim;
        now++;
        if(isCritical)
        {
            sendEff[now] = bypassValue;
            now++;
        }
    }

    sendEff[now] = totalDmg;
    now++;

    if(isCritical)
    {
        sendEff[now] = msgEff;
        now++;
        sendEff[now] = extraMessage;
    }

    Critter@[] source = { target };
    array<Critter@> crits;

    if(@target.GetMap() != null)
    {
        target.GetMap().GetCrittersSeeing(source, true, FIND_ALL | FIND_ONLY_PLAYERS, crits);

        for(int i = 0, j = crits.length(); i < j; i++)
            if(crits[i].Id != target.Id)
                AddEff(crits[i], sendEff, results);
    }
    if(isCritical)
        sendEff[now] = extraMessage + 1500;              // men_player - men_npc

    AddEff(target, sendEff, results);

    // Poisoning and irradiating:
    if (validAttacker) {
        if (valid(realWeapon) && (realWeapon.Proto.ProtoId == PID_NEEDLER_PISTOL)) {
            int poisonRoll = Random(1, 10);
			AffectPoison(target, poisonRoll);
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Poison Needler = |" + COLOR_DTEXT_BONUS + " " + poisonRoll;
            }
		} else if (valid(realWeapon) && (realWeapon.Proto.ProtoId == PID_POISONED_THROWING_KNIFE)) {
            int poisonRoll = Random(1, 10);
            AffectPoison(target, poisonRoll);
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Poison Throwing Knife = |" + COLOR_DTEXT_BONUS + " " + poisonRoll;
            }
        } else if (valid(realWeapon) && (realWeapon.Proto.ProtoId == PID_PASHTSHUUR_SPIKE)) {
            int poisonRoll = Random(1, 5);
            AffectPoison(target, poisonRoll);
            if (isDummyTraining) {
                dummyInfo += "|" + COLOR_DTEXT_REGULAR + " , Poison Pashtshuur Spike = |" + COLOR_DTEXT_BONUS + " " + poisonRoll;
            }
        } else {
			int poison = attacker.Stat[ST_TOXIC];
			int radiation = attacker.Stat[ST_RADIOACTIVE];
			if(poison != 0 || radiation != 0)
			{
				if(Random(2, 11) > target.Stat[ST_LUCK])
				{
					if(poison > 0)
						AffectPoison(target, Random(poison / 3, poison));
					if(radiation > 0)
						AffectRadiation(target, Random(radiation / 3, radiation));
				}
			}
			else
			{
				int attackerBt = attacker.Stat[ST_BODY_TYPE];
				if(attackerBt == BT_RADSCORPION || attackerBt == BT_FLOATER || attackerBt == BT_ALIEN || attackerBt == BT_CENTAUR)
				{
					if(Random(2, 11) > target.Stat[ST_LUCK])
					{
						if(attackerBt == BT_RADSCORPION)
							AffectPoison(target, Random(3, 15));
						else if(attackerBt == BT_FLOATER)
							AffectPoison(target, Random(10, 40));
						else if(attackerBt == BT_ALIEN)
							AffectRadiation(target, Random(10, 40));
						else if(attackerBt == BT_CENTAUR)
						{
							AffectPoison(target, Random(10, 20));
							AffectRadiation(target, Random(10, 20));
						}
					}
				}
			}
		}
    }

    if (isDummyTraining && attacker.IsPlayer()) {
        attacker.Say(SAY_NETMSG, dummyInfo);
    }


    PostDamage(target);
}


void CommenceExplosion(AttackStruct& attack, Map@ map, uint16 tx, uint16 ty, Critter@ target, uint weapPid, bool isCritical, uint intentionallyId, bool isRocket, array<CombatRes>& results, bool isExplodeRocket)
{
    uint radius = 2;
    if(isRocket) radius = isExplodeRocket?4:3;


    if(weapPid == PID_DYNACORD)
        radius = 4;
    else if(weapPid == PID_FIRE_GRENADE || weapPid == PID_FAKE_FIRE_GRENADE)
        radius = 3;

    if(weapPid == PID_MOLOTOV_COCKTAIL || weapPid == PID_FIRE_GRENADE || weapPid == PID_FAKE_FIRE_GRENADE)
        map.RunEffect(PID_EXPLODE_FIRE_BIG, tx, ty, 2);
    else if(weapPid == PID_FRAG_GRENADE || weapPid == PID_HOLY_HAND_GRENADE)
        map.RunEffect(PID_EXPLODE_FIRE_SMALL, tx, ty, 2);
    else if(weapPid == PID_PULSE_GRENADE)
        map.RunEffect(PID_EXPLODE_EMP, tx, ty, 2);
    else if(weapPid == PID_PLASMA_GRENADE || weapPid == PID_FAKE_PLASMA_GRENADE)
        map.RunEffect(PID_EXPLODE_PLASMA, tx, ty, 2);
    else if(isRocket)
        map.RunEffect(PID_EXPLODE_ROCKET, tx, ty, 1);
    else if(weapPid == PID_DYNACORD)
        map.RunEffect(PID_EXPLODE_FIRE_BIG, tx, ty, 3);
    else
        map.RunEffect(PID_EXPLODE_FIRE_BIG, tx, ty, 2);   // default case

    // Explosion sound. this could use some rework.
    string     soundName = "WHN1XXX1.ACM";
    ProtoItem@ proto = GetProtoItem(weapPid);
    if(valid(proto))
        soundName.rawSet(2, proto.Weapon_SoundId_0);
    map.PlaySound(soundName, tx, ty, 50);

    array<Critter@> critsHit;
    map.GetCrittersHex(tx, ty, radius, FIND_LIFE_AND_KO, critsHit);
    bool            validTarget = valid(target);
    uint            targetId = 0;
    bool            intentionally = (valid(attack.Attacker) && !_IsTrueNpc(attack.Attacker)) || targetId == intentionallyId;

    if(validTarget)
    {
        targetId = target.Id;
		int CriticalChance;
		if(isCritical) CriticalChance=100;
        ApplyDamage(attack, target, 1, isCritical, intentionally, results, CriticalChance);
    }

    attack.Hx = tx;
    attack.Hy = ty;

    for(int i = 0, j = critsHit.length(); i < j; i++)
        if(!validTarget || targetId != critsHit[i].Id)
            ApplyDamage(attack, critsHit[i], 1, false, intentionally, results, 0);

    if(weapPid == PID_MOLOTOV_COCKTAIL || weapPid == PID_FIRE_GRENADE || weapPid == PID_FAKE_FIRE_GRENADE)
        CommenceFireHex(attack.Attacker, map, tx, ty, radius);
}

void CommenceExplosionEx(Critter@ attacker, Map@ map, uint16 tx, uint16 ty, Critter@ target, uint weapPid, bool isCritical, uint intentionallyId, bool isRocket, bool isExplodeRocket)   // export
{
    array<CombatRes> results;
    AttackStruct     attack;
    @attack.Attacker = attacker;
    attack.Aim = HIT_LOCATION_UNCALLED;
    ProtoItem@ proto = GetProtoItem(weapPid);

    attack.DmgMin = _WeaponDmgMin(proto, 0) + _WeaponDmgMin(proto, 0) * attack.SelectWeaponBonus(BONUS_WEAPON_MIN_DMG)/100;
    attack.DmgMax = _WeaponDmgMax(proto, 0) + _WeaponDmgMax(proto, 0) * attack.SelectWeaponBonus(BONUS_WEAPON_MAX_DMG)/100;
    attack.DmgType = _WeaponDmgType(proto, 0);
    attack.WeaponPerk = proto.Weapon_Perk;

    CommenceExplosion(attack, map, tx, ty, target, weapPid, isCritical, intentionallyId, isRocket, results, isExplodeRocket);
    FlushResults(results);
}

void CommenceExplosionHexEx(Critter@ attacker, Map@ map, uint16 tx, uint16 ty, Critter@ target, uint weapPid, Item@ usedWeapon, uint ammoPid, bool isCritical, uint intentionallyId, bool isRocket, bool isExplodeRocket)   // export
{
    array<CombatRes> results;
    AttackStruct     attack;
    @attack.Attacker = attacker;
    attack.Aim = HIT_LOCATION_UNCALLED;
    @attack.RealWeapon = usedWeapon;
    ProtoItem@ proto = GetProtoItem(weapPid);

    attack.DmgMin = _WeaponDmgMin(proto, 0);
    attack.DmgMax = _WeaponDmgMax(proto, 0);
    attack.DmgType = _WeaponDmgType(proto, 0);
    attack.WeaponPerk = proto.Weapon_Perk;
    if(ammoPid > 0)
    {
        attack.ammoPid = ammoPid;

        ProtoItem@ ammo = GetProtoItem(ammoPid);
        // Ammo
        if(valid(ammo))
        {
            attack.DRMod = ammo.Ammo_DrMod;
            attack.DMMod = ammo.Ammo_DmgMult;
            attack.DDMod = ammo.Ammo_DmgDiv;
            if(attack.DMMod == 0)
                attack.DMMod = 1;
            if(attack.DDMod == 0)
                attack.DDMod = 1;
        }
    }

    CommenceExplosion(attack, map, tx, ty, target, weapPid, isCritical, intentionallyId, isRocket, results, isExplodeRocket);
    FlushResults(results);
}

void CommenceDischargeEx(Critter@ attacker, Map@ map, uint16 tx, uint16 ty, uint dmgRad, uint dmgMin, uint dmgMax, int effChance, uint rechargeVal)   //export
{
    array<CombatRes> results;

    AttackStruct     attack;
    @attack.Attacker = attacker;
    attack.Aim = HIT_LOCATION_UNCALLED;
    attack.DmgMin = dmgMin;
    attack.DmgMax = dmgMax;
    attack.DmgType = DAMAGE_TYPE_ELECTR;

    uint radius = dmgRad;
    uint16 stepX = attacker.HexX;
    uint16 stepY = attacker.HexY;

    //drawing effects
    //map.MoveHexByDir(stepX, stepY, 4, 1);
    //for(uint8 stepDir = 0; stepDir < 6; stepDir++)
    //{
    //    map.MoveHexByDir(stepX, stepY, stepDir, 1);
    //    map.RunEffect(PID_EXPLODE_EMP, stepX, stepY, 0);
    //}

    for(uint rad = radius; rad <= radius; ++rad)
    {
    stepX = attacker.HexX;
    stepY = attacker.HexY;
        map.MoveHexByDir(stepX, stepY, 4, rad);
        for(uint8 stepDir = 0; stepDir < 6; stepDir++)
        {
            for(uint step = 0; step < rad; step++)
            {
                map.MoveHexByDir(stepX, stepY, stepDir, 1);
                //if(Random(1, 100) < effChance)
                map.RunEffect(PID_EXPLODE_EMP, stepX, stepY, 0);
            }
        }
    }
    map.PlaySound("was1xxx" + Random(1, 2), tx, ty, 50);

    //getting critters in range
    array<Critter@> crits;
    uint foundCritters = map.GetCrittersHex(tx, ty, radius, FIND_LIFE_AND_KO, crits);
    for(uint c = 0; c < foundCritters; c++)
    {
        if(crits[c].Id == attacker.Id)
        {
            crits.removeAt(c);
            foundCritters--;
            break;
        }

    }

    uint recharge = (foundCritters>0)?rechargeVal/foundCritters:0;

    //commencing attack
    bool intentionally = (valid(attack.Attacker) && !_IsTrueNpc(attack.Attacker));
    for(uint c = 0; c < foundCritters; c++)
    {
        map.RunEffect(PID_EXPLODE_EMP, crits[c].HexX, crits[c].HexY, 0);
        ApplyDamage(attack, crits[c], 1, false, intentionally, results, 0);

        Item@ usedArmor = crits[c].GetItem(0, SLOT_ARMOR);
        if(!valid(usedArmor) || usedArmor.GetProtoId() != PID_TESLA_ARMOR)
        {
            crits.removeAt(c);
            --foundCritters;
            --c;
        }
    }

    //charging affected armors
    if(foundCritters > 0 && recharge > 0)
    {
        for(uint c = 0; c < foundCritters; c++)
        {
            if(crits[c].IsLife())
            {
                Item@ usedArmor = crits[c].GetItem(0, SLOT_ARMOR);
                if(valid(usedArmor) || usedArmor.GetProtoId() == PID_TESLA_ARMOR)
                {
                    usedArmor.Charge += recharge;
                    if(usedArmor.Charge > usedArmor.Proto.Misc_ChargeMax)
                        usedArmor.Charge = usedArmor.Proto.Misc_ChargeMax;
                    usedArmor.Update();
                    crits[c].Say(SAY_NETMSG, "Charging armor with "+recharge+" charges.");
                    crits[c].Say(SAY_NETMSG, "Charges: "+usedArmor.Charge+"/"+usedArmor.Proto.Misc_ChargeMax+".");
                }
            }
        }
    }

    FlushResults(results);
}

void CommenceFireHex(Critter@ attacker, Map@ map, uint16 tx, uint16 ty, uint8 radius)
{
    if(!valid(map))
        return;

    if(!valid(attacker))
        return;

    uint uniqID = Random(1, 9999);

    for(uint rad = 1; rad <= radius; ++rad)
    {
        uint16 stepX = tx;
        uint16 stepY = ty;
        map.MoveHexByDir(stepX, stepY, 4, rad);
        for(uint8 stepDir = 0; stepDir < 6; stepDir++)
        {
            for(uint step = 0; step < rad; step++)
            {
                map.MoveHexByDir(stepX, stepY, stepDir, 1);

                if(map.IsHexRaked(stepX, stepY))
                {
                    Item@ itm = map.GetItem(stepX, stepY, PID_FIRE_HEX);
                    if(valid(itm))
                    {
                        itm.Val0 = attacker.Id;
                        itm.Val1 = uniqID;
                        itm.Update();
                    }
                    else
                    {
                        Item@ item = map.AddItem(stepX, stepY, PID_FIRE_HEX, 1);
                        if(valid(item))
                        {
                            item.Val0 = attacker.Id;
                            item.Val1 = uniqID;
                            item.SetScript( "_FireInit" );
                            item.SetEvent(ITEM_EVENT_WALK, "_FireWalk");
                            item.Update();
                        }
                    }
                }
            }
        }
    }

    if(map.IsHexRaked(tx, ty))
    {
        Item@ itm = map.GetItem(tx, ty, PID_FIRE_HEX);
        if(valid(itm))
        {
            itm.Val0 = attacker.Id;
            itm.Val1 = uniqID;
            itm.Update();
        }
        else
        {
            Item@ item = map.AddItem(tx, ty, PID_FIRE_HEX, 1);
            if(valid(item))
            {
                item.Val0 = attacker.Id;
                item.Val1 = uniqID;
                item.SetScript( "_FireInit" );
                item.SetEvent(ITEM_EVENT_WALK, "_FireWalk");
                item.Update();
            }
        }
    }

    uint[] values = { attacker.Id, map.Id, tx, ty, radius, uniqID, 5};
    CreateTimeEvent(AFTER(REAL_SECOND(1)), "combat@e_ProcessFireHex", values, false);
}

void _FireInit( Item& item, bool firstTime ){
    if( !firstTime  && valid(item))
        DeleteItem( item );
}

void _FireWalk(Item& fire, Critter& cr, bool entered, uint8 dir )
{
    Critter@ attacker = GetCritter(fire.Val0);
    if(!valid(attacker))
        return;

    array<CombatRes> results;

    AttackStruct     attack;
    @attack.Attacker = attacker;
    attack.Aim = HIT_LOCATION_UNCALLED;
    attack.DmgMin = 8;
    attack.DmgMax = 14;
    attack.DmgType = DAMAGE_TYPE_FIRE;

    ApplyDamage(attack, cr, 1, false, true, results, 0);

    FlushResults(results);
}

uint e_ProcessFireHex( uint[] @ values )
{
    Map@ map = GetMap(values[1]);
    if(!valid(map))
        return 0;

    int uniqID = values[5];

    array<Item@> items;
    map.GetItems(values[2], values[3], values[4], PID_FIRE_HEX, items);

    if(values[6] > 0)
    {
        Critter@ attacker = GetCritter(values[0]);

        if(valid(items) && valid(attacker))
        {
            for(uint i = 0; i < items.length(); ++i)
            {
                if(items[i].Val1 == uniqID)
                {
                    Critter@ cr = map.GetCritter(items[i].HexX, items[i].HexY);
                    if(valid(cr))
                    {
                        array<CombatRes> results;

                        AttackStruct     attack;
                        @attack.Attacker = attacker;
                        attack.Aim = HIT_LOCATION_UNCALLED;
                        attack.DmgMin = 1;
                        attack.DmgMax = 10;
                        attack.DmgType = DAMAGE_TYPE_FIRE;

                        ApplyDamage(attack, cr, 1, false, true, results, 0);

                        FlushResults(results);
                    }
                }
            }
        }

        --values[6];

        return REAL_SECOND(1);
    }
    else
    {
        if(valid(items))
        {
            for(uint i = 0; i < items.length(); ++i)
            {
                if(items[i].Val1 == uniqID)
                    DeleteItem(items[i]);
            }
        }
    }

    return 0;
}

void CriticalFailure(Critter& cr, ProtoItem& weapon, uint8 weaponUse, ProtoItem@ ammo, uint eff, array<CombatRes>& results)
{
    // 0x00000100 hit self
    // 0x00100000 weapon exploded

    // 0x00000200 lost rest of ammo
    // 0x00000400 fired dud shot
    // 0x00000800 hurt self
    // 0x00001000 hit randomly
    // 0x00002000 crippled random limb
    // 0x00040000 on fire NOT USED NOW, TODO?

    // 0x00200000 weapon destroyed
    // 0x00400000 weapon dropped
    // 0x00800000 lost next turn
    // 0x02000000 knocked down

	AttackStruct attack;

    int   totalDmg = 0;
    bool  tookDamage = false;
    Item@ realWeapon = _CritGetItemHand(cr);
    bool  wpnIsRemoved = _WeaponRemove(weapon, weaponUse);
    Map@  map = cr.GetMap();

    if(cr.Mode[MODE_NO_DROP] != 0)
        UNSETFLAG(eff, MF_WEAPON_DROPPED);

    if(FLAG(eff, MF_HIT_SELF) || FLAG(eff, MF_WEAPON_EXPLODED))        // Only one bullet because burst weapons do not have the ability
    {
        bool validAmmo = valid(ammo);
        uint16 ammoPid = 0;
        if(validAmmo)
            ammoPid = ammo.ProtoId;

        int  dmgType = _WeaponDmgType(weapon, weaponUse);
		if(ammoPid == PID_SHOTGUN_SHELLS_EMP) dmgType=DAMAGE_TYPE_EMP; // jesli uzywane ammo typu EMP to zmien dmtype broni
		if(ammoPid == PID_SHOTGUN_DRAGON_BREATH_SHELLS) dmgType=DAMAGE_TYPE_FIRE; // jesli uzywane ammo typu FIRE to zmien dmtype broni
        int  targetDT = cr.GetDT(dmgType, false);
		int  targetDR = cr.GetDR(dmgType, false);

		Item@ armor_ = _GetCritterArmor(cr, attack.AimHead);
		//if(dmgType==DAMAGE_TYPE_EXPLODE)
		//{
			//targetDT += SelectArmorBonus(armor_, BONUS_ARMOR_EXPLODE_DT);
			//targetDR += SelectArmorBonus(armor_, BONUS_ARMOR_EXPLODE_DR);
		//}
		//else
		//if((dmgType!=DAMAGE_TYPE_ELECTR) && (dmgType!=DAMAGE_TYPE_EMP))
		//{
			//targetDT += SelectArmorBonus(armor_, BONUS_ARMOR_NORMAL_DT - 1 + dmgType);
			//targetDR += SelectArmorBonus(armor_, BONUS_ARMOR_NORMAL_DR - 1 + dmgType);
		//}



        int  partialBypassChance = GetPartialBypassChance(cr, false);
        int  armorDT = cr.GetArmorDT(dmgType, false);
		int  armorDR = cr.GetArmorDR(dmgType, false);

        int  partialBypassDR = targetDR - armorDR + (armorDR / 5);
        int  partialBypassDT = targetDT - armorDT + (armorDT / 5);

        if(weapon.Weapon_Perk == WEAPON_PERK_PENETRATE)
            targetDT /= 5;
        else if(validAmmo && COMBAT_AMMO_AP(ammo))
            targetDT /= validAmmo ? ammo.Ammo_DTDiv : 1;

        if(cr.Trait[TRAIT_FINESSE] != 0)
        {
            targetDR += 30;
            partialBypassDR += 30;
        }
        targetDR += validAmmo ? ammo.Ammo_DrMod : 0;
        partialBypassDR += validAmmo ? ammo.Ammo_DrMod : 0;
        targetDR = CLAMP(targetDR, 0, 100);

        partialBypassDR = MIN(partialBypassDR, targetDR);
        targetDR = CLAMP(targetDR, 0, 100);
        partialBypassDR = CLAMP(partialBypassDR, 0, 100);
        partialBypassDT = MIN(partialBypassDT, targetDT);

        int dmgMin = _WeaponDmgMin(weapon, weaponUse) + _WeaponDmgMin(weapon, weaponUse) * attack.SelectWeaponBonus(BONUS_WEAPON_MIN_DMG)/100;
        int dmgMax = _WeaponDmgMax(weapon, weaponUse) + _WeaponDmgMax(weapon, weaponUse) * attack.SelectWeaponBonus(BONUS_WEAPON_MAX_DMG)/100;
        int dmgMul = validAmmo ? ammo.Ammo_DmgMult : 1;   // Technically, should be *2
        int dmgDiv = validAmmo ? ammo.Ammo_DmgDiv : 1;    // Technically, should be *2
        int bonusFromLuck = CLAMP((8 - cr.Stat[ST_LUCK]) / 3, 0, 3);
        totalDmg = Random(dmgMin, dmgMax) + cr.Perk[PE_BONUS_RANGED_DAMAGE] * bonusFromLuck + cr.Perk[PE_MORE_RANGED_DAMAGE] * bonusFromLuck;
        totalDmg *= dmgMul;
        totalDmg /= dmgDiv;

        if(Random(1, 100) <= partialBypassChance)
        {
            totalDmg -= partialBypassDT;
            totalDmg -= (totalDmg * partialBypassDR) / 100;
        }
        else
        {
            totalDmg -= targetDT;
            totalDmg -= (totalDmg * targetDR) / 100;
        }

        if(totalDmg < 0)
            totalDmg = 0;
        int bt = cr.Stat[ST_BODY_TYPE];
        // The damage perks are used even in this case!
        if(cr.Perk[PE_PYROMANIAC] != 0 && dmgType == DAMAGE_TYPE_FIRE && ammoPid != PID_SHOTGUN_DRAGON_BREATH_SHELLS)
            totalDmg += totalDmg/4; // now +25% fire dmg
        if(cr.Trait[TRAIT_HEAVY_HANDED] != 0 && weapon.Weapon_IsUnarmed)
            totalDmg += 5;
        if(cr.Trait[TRAIT_ONE_HANDER] != 0 && (valid(realWeapon) && !FLAG(realWeapon.Flags, ITEM_FLAG_TWO_HANDS) && attack.WeaponSubtype != WS_UNARMED))
            totalDmg += 5;
        if(cr.Trait[TRAIT_KAMIKAZE] != 0)
            totalDmg += totalDmg/10; // +10% more dmg
        tookDamage = true;
    }

    uint16 ammoRound = _WeaponRound(weapon, weaponUse);
    if(ammoRound > 0 && valid(realWeapon) && cr.Mode[MODE_UNLIMITED_AMMO] == 0)
    {
        if(realWeapon.AmmoCount <= ammoRound || FLAG(eff, MF_LOST_REST_OF_AMMO))
            realWeapon.AmmoCount = 0;
        else
            realWeapon.AmmoCount -= ammoRound;
        realWeapon.Update();
    }

    if(cr.Mode[MODE_NO_DROP] != 0 || (cr.Perk[PE_IRON_LIMBS] > 0 && Random(1, 10) <= cr.Stat[ST_STRENGTH] - 4))
        UNSETFLAG(eff, MF_WEAPON_DROPPED);
    if(cr.Mode[MODE_NO_LOOSE_LIMBS] != 0)
        UNSETFLAG(eff, MF_CRIPPLED_RANDOM_LIMB);
    if(cr.Perk[PE_STONEWALL] > 0)
        if(FLAG(eff, MF_KNOCKED_DOWN) && Random(0, 10) <= cr.Stat[ST_ENDURANCE] - 3)
            UNSETFLAG(eff, MF_KNOCKED_DOWN);

    if(FLAG(eff, MF_WEAPON_DROPPED) && valid(realWeapon))
    {
        /*
         * NO DROP MODE FOR PLAYERS
         * weapon drops cause weapon to go to inventory instead of ground
         */
        if(cr.IsPlayer() && !_PlayerDropEnabled(target, map))
        {
            cr.MoveItem(realWeapon.Id, realWeapon.GetCount(), SLOT_INV);
        }
        else if(realWeapon.IsStackable())
        {
            Item@ dropped = map.AddItem(cr.HexX, cr.HexY, weapon.ProtoId, 1);
            if(realWeapon.GetCount() > 1)
                realWeapon.SetCount(realWeapon.GetCount() - 1);
            else
                DeleteItem(realWeapon);

            if(!cr.IsPlayer())
            {
                NpcPlane@ plane = CreatePlane();
                array<NpcPlane@> crPlanes(0);

                if(cr.GetPlanes(crPlanes) > 0)
                    plane.Priority = crPlanes[0].Priority + 1;
                else
                    plane.Priority = 70;

                plane.Type = AI_PLANE_PICK;
                plane.Pick_HexX = dropped.HexX;
                plane.Pick_HexY = dropped.HexY;
                plane.Pick_Pid = dropped.GetProtoId();
                plane.Pick_UseItemId = 0;
                plane.Pick_ToOpen = false;
                plane.Identifier = PLANE_PICK_DROPPED_WPN;
                plane.IdentifierExt = dropped.Id;
                plane.Run = true;
                cr.AddPlane(plane);
                SetLvar(dropped.Id, LIVAR_npc_wpn_owner, cr.Id);
            }
        }
        else
        {
            MoveItem(realWeapon, 0, map, cr.HexX, cr.HexY);
            if(!cr.IsPlayer())
            {
                NpcPlane@ plane = CreatePlane();

                array<NpcPlane@> crPlanes(0);

                if(cr.GetPlanes(crPlanes) > 0)
                    plane.Priority = crPlanes[0].Priority + 1;
                else
                    plane.Priority = 70;

                plane.Type = AI_PLANE_PICK;
                plane.Pick_HexX = realWeapon.HexX;
                plane.Pick_HexY = realWeapon.HexY;
                plane.Pick_Pid = realWeapon.GetProtoId();
                plane.Pick_UseItemId = 0;
                plane.Pick_ToOpen = false;
                plane.Identifier = PLANE_PICK_DROPPED_WPN;
                plane.IdentifierExt = realWeapon.Id;
                plane.Run = true;
                cr.AddPlane(plane);
                SetLvar(realWeapon.Id, LIVAR_npc_wpn_owner, cr.Id);
            }
        }
    }

    if((FLAG(eff, MF_WEAPON_DESTROYED) || FLAG(eff, MF_WEAPON_EXPLODED)) && valid(realWeapon))
    {
        if(realWeapon.IsStackable())
        {
            if(realWeapon.GetCount() > 1)
                realWeapon.SetCount(realWeapon.GetCount() - 1);
            else
                DeleteItem(realWeapon);
        }
        else
            DeleteItem(realWeapon);
    }

    if(FLAG(eff, MF_HURT_SELF))
    {
        totalDmg += Random(1, 5);
        tookDamage = true;
    }

    if(FLAG(eff, MF_LOST_NEXT_TURN))
    {
        cr.StatBase[ST_CURRENT_AP] = (cr.Perk[PE_QUICK_RECOVERY] > 0 ? (-100 * cr.Stat[ST_ACTION_POINTS]) / 3 : -100 * cr.Stat[ST_ACTION_POINTS]);
        cr.StatBase[ST_MOVE_AP] = 0;
    }

    if(FLAG(eff, MF_KNOCKED_DOWN) && !cr.IsKnockout())
        cr.ToKnockout(KNOCKOUT_ANIM2_DEFAULT(true), cr.Perk[PE_QUICK_RECOVERY] != 0 ? 1 : 3, cr.HexX, cr.HexY);

    if(FLAG(eff, MF_CRIPPLED_RANDOM_LIMB))
    {
        switch(Random(1, 4))
        {
        case 1:
            if(cr.Perk[PE_IRON_LIMBS] == 0 || Random(1, 10) > cr.Stat[ST_ENDURANCE] - 3)
                cr.DamageBase[DAMAGE_LEFT_LEG] = 1;
            else
                UNSETFLAG(eff, MF_CRIPPLED_RANDOM_LIMB);
            break;
        case 2:
            if(cr.Perk[PE_IRON_LIMBS] == 0 || Random(1, 10) > cr.Stat[ST_ENDURANCE] - 3)
                cr.DamageBase[DAMAGE_RIGHT_LEG] = 1;
            else
                UNSETFLAG(eff, MF_CRIPPLED_RANDOM_LIMB);
            break;
        case 3:
            if(cr.Perk[PE_IRON_LIMBS] == 0 || Random(1, 10) > cr.Stat[ST_ENDURANCE] - 3)
                cr.DamageBase[DAMAGE_LEFT_ARM] = 1;
            else
                UNSETFLAG(eff, MF_CRIPPLED_RANDOM_LIMB);
            break;
        case 4:
            if(cr.Perk[PE_IRON_LIMBS] == 0 || Random(1, 10) > cr.Stat[ST_ENDURANCE] - 3)
                cr.DamageBase[DAMAGE_RIGHT_ARM] = 1;
            else
                UNSETFLAG(eff, MF_CRIPPLED_RANDOM_LIMB);
            break;
        default:
            break;
        }
    }

    if(FLAG(eff, MF_WEAPON_EXPLODED))
        map.RunEffect(PID_EXPLODE_FIRE_SMALL, cr.HexX, cr.HexY, 2);

    if(totalDmg > 0)
        cr.StatBase[ST_CURRENT_HP] -= totalDmg;

    uint[] allEff = { CMSG_CRIT_MISS, cr.Id, 0, eff };


    if(tookDamage)
    {
        allEff.resize(5);
        allEff[4] = totalDmg;
        allEff[0] = CMSG_CRIT_MISS_DAMAGE;
    }

    if(cr.Stat[ST_CURRENT_HP] < 1)
    {
        int deadHitPoints = cr.Perk[PE_DEAD_MAN_WALKING] > 0 ? __DeadHitPoints : __DeadHitPoints / 2;
        if(cr.Stat[ST_CURRENT_HP] > deadHitPoints && IsHumanoid(cr) && cr.Mode[MODE_NO_KNOCK] == 0)
        {
            if(!cr.IsKnockout())
                cr.ToKnockout(KNOCKOUT_ANIM2_DEFAULT(true), 0, cr.HexX, cr.HexY);
        }
        else
        {
            uint anim2Dead = ANIM2_DEAD_FRONT;
            if(cr.IsKnockout())
            {
                if(cr.Anim2Knockout == ANIM2_IDLE_PRONE_FRONT)
                    anim2Dead = ANIM2_DEAD_PRONE_FRONT;
                else
                    anim2Dead = ANIM2_DEAD_PRONE_BACK;
            }
            cr.ToDead(anim2Dead, null);
            allEff[2] |= MF_WAS_KILLED;
        }
    }

    Critter@[] him = { cr };
    array<Critter@> crits;
    cr.GetMap().GetCrittersSeeing(him, true, FIND_ALL | FIND_ONLY_PLAYERS, crits);
    for(int i = 0, j = crits.length(); i < j; i++)
        AddEff(crits[i], allEff, results);

    FlushResults(results);
}


void InjureCritter(Critter& cr, uint dmg, uint dmgType, uint8 dir, uint attackerId)   // Export
{
    if(dmgType > DAMAGE_TYPE_EXPLODE)
    {
        Log("Invalid damage type.");
        return;
    }

    Critter@ attacker = null;
    if(attackerId != 0 && cr.Id != attackerId)
        @attacker = GetCritter(attackerId);

    AttackStruct attack;
    @attack.Attacker = attacker;

    uint16 hx = cr.HexX;
    uint16 hy = cr.HexY;
    Map@   map = cr.GetMap();
    if(valid(map))
        map.MoveHexByDir(hx, hy, (dir + 3) % 6, 1);

    attack.Hx = hx;
    attack.Hy = hy;
    attack.set_Aim(HIT_LOCATION_UNCALLED);
    attack.IsBurst = false;
    attack.BloodyMess = false;
    attack.CombatMessage = false;
    attack.WeaponPerk = -1;
    attack.WeaponSubtype = 0;
    attack.DmgMin = dmg;
    attack.DmgMax = dmg;
    attack.DmgType = dmgType;
    attack.BonusDmg = 0;
    attack.DmgMul = 2;
    attack.DRMod = 0;
    attack.DMMod = 1;
    attack.DDMod = 1;
    attack.TargetId = cr.Id;
    attack.ShowHitAnimForce = true;

    array<CombatRes> results;
    ApplyDamage(attack, cr, 1, false, true, results, 0);

    FlushResults(results);
}

int FindCritterInArray(array<Critter@>& crits, Critter& cr)
{
    uint crId = cr.Id;
    for(uint i = 0, j = crits.length(); i < j; i++)
        if(crits[i].Id == crId)
            return i;
    return -1;
}

uint GetAimApCost(int hitLocation)
{
    switch(hitLocation)
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __ApCostAimTorso;
    case HIT_LOCATION_EYES:
        return __ApCostAimEyes;
    case HIT_LOCATION_HEAD:
        return __ApCostAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __ApCostAimArms;
    case HIT_LOCATION_GROIN:
        return __ApCostAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __ApCostAimLegs;
    default:
        break;
    }
    return 0;
}

uint GetHitAim(int hitLocation)
{
    switch(hitLocation)
    {
    case HIT_LOCATION_NONE:
        break;
    case HIT_LOCATION_UNCALLED:
        break;
    case HIT_LOCATION_TORSO:
        return __HitAimTorso;
    case HIT_LOCATION_EYES:
        return __HitAimEyes;
    case HIT_LOCATION_HEAD:
        return __HitAimHead;
    case HIT_LOCATION_LEFT_ARM:
    case HIT_LOCATION_RIGHT_ARM:
        return __HitAimArms;
    case HIT_LOCATION_GROIN:
        return __HitAimGroin;
    case HIT_LOCATION_RIGHT_LEG:
    case HIT_LOCATION_LEFT_LEG:
        return __HitAimLegs;
    default:
        break;
    }
    return 0;
}


// Used by AI
int RawToHit(Critter& cr, Critter& target, ProtoItem@ weapon, uint8 weaponUse, ProtoItem@ ammo)   // export
{
    int skillNum = valid(weapon) ? _WeaponSkill(weapon, weaponUse) : SK_UNARMED;
    int toHit = cr.Skill[skillNum];
    int weaponPerk = valid(weapon) ? weapon.Weapon_Perk : 0;
    int blockers = 0;
    int dist = GetDistantion(cr.HexX, cr.HexY, target.HexX, target.HexY);
    if(skillNum != SK_UNARMED)
    {
        // Ranged attack modifiers
        int distmod1 = 2;       // Used for initial weapon bonus
        int distmod2 = 0;       // Minimal distance
        if(weaponPerk == WEAPON_PERK_LONG_RANGE)
            distmod1 = 4;
        else if(weaponPerk == WEAPON_PERK_SCOPE_RANGE)
        {
            distmod1 = 5;
            distmod2 = 8;
        }

        int perception = cr.Stat[ST_PERCEPTION];
        int acc = dist;

        if(dist < distmod2)
            acc += distmod2;
        else
        {
            if(cr.IsPlayer())
                acc -= (perception - 2) * distmod1;
            else
                acc -= perception * distmod1;
        }

        if(-2 * perception > acc)
            acc = -2 * perception;

        acc -= 2 * cr.Perk[PE_SHARPSHOOTER];

        if(acc >= 0)
        {
            if(cr.Damage[DAMAGE_EYE] != 0)
                acc *= -12;
            else
                acc *= -4;
        }
        else
            acc *= -4;

        toHit += acc;

        Map@ map = cr.GetMap();
        blockers = map.GetCrittersPath(cr.HexX, cr.HexY, target.HexX, target.HexY, 0.0f, dist, FIND_LIFE, null);
        if(!target.IsKnockout())
            blockers--;
        toHit -= 10 * blockers;
    }     // Range modifiers end
    else
        toHit += 8*cr.Perk[PE_SHARPSHOOTER];

    if(valid(weapon))
    {
        if(!(weapon.Weapon_IsUnarmed) && cr.Trait[TRAIT_ONE_HANDER] != 0)
            toHit += (FLAG(weapon.Flags, ITEM_FLAG_TWO_HANDS) ? -40 : 20);

        int handlingStrength = cr.Stat[ST_STRENGTH];
        int reqStrength = weapon.Weapon_MinStrength;
        if(cr.Perk[PE_WEAPON_HANDLING] != 0)
            handlingStrength += 2;
        if(handlingStrength < reqStrength)
            toHit -= (reqStrength - handlingStrength) * 20;

        if(weaponPerk == WEAPON_PERK_ACCURATE)
            toHit += 20;
    }

    int acmod = target.GetAC(false);
    if(valid(ammo))
        acmod += ammo.Ammo_AcMod;
    if(acmod > 0)
        toHit -= acmod;

    if(cr.Damage[DAMAGE_EYE] != 0)
        toHit -= 25;

    if(target.IsKnockout())
        toHit += 40;
    if(target.GetMultihex() > 0)
        toHit += 15;

    return toHit;
}


void NotifyOops(Critter@ cr, Critter@ t1, Critter@ t2, array<CombatRes>& results)
{
    // if(t2==null) pass "cr critically missed and hit randomly."
    // otherwise pass "Oops! t2 was hit instead of t1!"
    if(!valid(t2))
    {
        uint[] allEff = { CMSG_HIT_RANDOMLY, cr.Id, 0 };
        Critter@[] him = { cr };
        array<Critter@> crits;
        cr.GetMap().GetCrittersSeeing(him, true, FIND_ALL | FIND_ONLY_PLAYERS, crits);
        for(int i = 0, j = crits.length(); i < j; i++)
            AddEff(crits[i], allEff, results);
    }
    else
    {
        uint[] allEff = { CMSG_OOPS, t1.Id, t2.Id };
        Critter@[] them = { t1, t2 };
        array<Critter@> crits;
        t1.GetMap().GetCrittersSeeing(them, true, FIND_ALL | FIND_ONLY_PLAYERS, crits);
        for(int i = 0, j = crits.length(); i < j; i++)
            AddEff(crits[i], allEff, results);
    }
}

void NotifyMiss(Critter@ cr, array<CombatRes>& results)
{
    uint[] allEff = { CMSG_MISS, cr.Id, 0 };
    Critter@[] him = { cr };
    array<Critter@> crits;
    cr.GetMap().GetCrittersSeeing(him, true, FIND_ALL | FIND_ONLY_PLAYERS, crits);
    for(int i = 0, j = crits.length(); i < j; i++)
        AddEff(crits[i], allEff, results);
}

Critter@ ChooseRandomTarget(Map& map, Critter& cr, Critter& target, uint wpnMaxDist)
{
    array<Critter@> crits;
    uint16          hx = cr.HexX;
    uint16          hy = cr.HexY;
    uint            n = map.GetCrittersHex(hx, hy, wpnMaxDist, FIND_LIFE_AND_KO, crits);
    if(n == 0)
        return null;          // Should never happen
    uint   start = Random(0, n - 1);
    uint16 bx = 0;
    uint16 by = 0;
    uint16 pbx = 0;
    uint16 pby = 0;
    for(uint i = start; i < n; i++)
    {
        if(!valid(crits[i]))
            continue;
        if(crits[i].Id == cr.Id || crits[i].Id == target.Id)
            continue;
        // Wallcheck:
        map.GetCrittersPath(hx, hy, crits[i].HexX, crits[i].HexY, 0.0f, 0, FIND_LIFE_AND_KO, null, pbx, pby, bx, by);
        if(bx == crits[i].HexX && by == crits[i].HexY)
            return crits[i];
    }
    for(uint i = 0; i < start; i++)
    {
        if(!valid(crits[i]))
            continue;
        if(crits[i].Id == cr.Id || crits[i].Id == target.Id)
            continue;
        // Wallcheck:
        map.GetCrittersPath(hx, hy, crits[i].HexX, crits[i].HexY, 0.0f, 0, FIND_LIFE_AND_KO, null, pbx, pby, bx, by);
        if(bx == crits[i].HexX && by == crits[i].HexY)
            return crits[i];
    }

    return null;
}

int GetPartialBypassChance(Critter& target, bool aimHead)
{
    Item@ armor = _GetCritterArmor(target, aimHead);
    if(!valid(armor))
        return 0;
    int deterPercent = (100 * armor.Deterioration) / MAX_DETERIORATION;
    if(!armor.IsDeteriorable() || _CritHasExtMode(target, MODE_EXT_NO_DETERIORATION) || deterPercent <= 50)
        return 0;
    return ((deterPercent - 50) * 100) / 50;
}

int AddCritRollWeapon(Item@ realWeapon)
{
	int _roll=0;
	if(valid(realWeapon))
	{
		if(realWeapon.Proto.ProtoId==PID_TURBO_PLASMA_RIFLE) _roll = 5;
		if(realWeapon.Proto.ProtoId==PID_PLASMA_RIFLE) _roll = 5;
	}
	return _roll;
}

uint cte_AllowRunAgain(Critter& cr, int identifier, uint& rate) {
    rate = 0;
    if (cr.ParamBase[MODE_NO_RUN] > 0) {
        cr.ParamBase[MODE_NO_RUN] = 0;
    }
    return 0;
}
