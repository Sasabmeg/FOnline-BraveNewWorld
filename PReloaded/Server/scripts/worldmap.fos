//
// FOnline: Reloaded
//
//
// worldmap.fos
//

#include "_bags.fos"
#include "_macros.fos"
#include "groups_h.fos"

#define __WORLDMAP_MODULE__
#include "worldmap_h.fos"
#include "logging_h.fos"
#include "_colors.fos"
#include "_macros.fos"
#include "_maps.fos"
#include "_scripts.fos"
#include "caravans_h.fos"
#include "groups_h.fos"
//#include "lexems_h.fos"
#include "mapdata_h.fos"
#include "npc_common_h.fos"
#include "utils_h.fos"
//#include "weather_h.fos"
#include "world_common_h.fos"
#include "worldmap_data.fos"

import void SetWear(Item& item, int wearProcent) from "repair";
import void SetMinWear(Item& item, int wearProcent) from "repair";
import int  GetGroupsStatus(uint fac1, uint fac2) from "reputations_modifiers";

import bool AddAttackPlane(Critter& npc, uint priority, Critter& target) from "npc_planes";

import void AddEncounterContainers(Map@ map, array<Critter@>@ critters) from "encounter_containers";

import void AddSpecialBonusEncounterBoss(Item@ it) from "item_bonus";
import bool IsItemCraftable(uint16 pid) from "fix_boy";

#define STR_GROUP    # (g)    (20000000 + g)

class CCheck
{
    uint  Type;
    uint  Index;
    uint8 Operator;
    int   Value;

    CCheck()
    {
        Type = 0;
        Index = 0;
        Operator = 0;
        Value = 0;
    }

    void Set(uint type, uint index, uint8 operator, int value)
    {
        Type = type;
        Index = index;
        Operator = operator;
        Value = value;
    }
};

class CEncounterPerk
{
    uint index;
    uint level;
    uint chance;

    CEncounterPerk(uint index, uint level, uint chance)
    {
        this.index = index;
        this.level = level;
        this.chance = chance;
    }
};

class CEncounterObject
{
    uint                     ObjectType;
    uint16                   Pid;        // Proto id
    uint                     Dialog;
    string                   Script;
    uint                     Distance;   // Distance from center of encounter
    uint                     Bag;
    uint                     NpcRole;
    uint                     TeamId;
    array<CEncounterObject@> Childs;     // Items in inventory or container
    array<CCheck>            Checks;
    // Only for critter
    uint                     Ratio;  // szansa crittera na wylosowanie w obrebie grupy np Radscoprion 30%
    bool                     Dead;
    int                      Armor;
    int                      Helmet;
    int                      OverrideCrtype;
    // Only for item
    uint                     Minimum;
    uint                     Maximum;
    uint                     Slot;
    // value required to generate object
    uint                     cost;

    array<CEncounterPerk>    Perks;


    // for items: broken count
    uint        BrokenMin;
    uint        BrokenMax;
    // modes to be set
    array<uint> modes;

    CEncounterObject()
    {
        ObjectType = 0;
        Pid = 0;
        Dialog = 0;
        Script = "";
        Distance = 0;
        Ratio = 0;
        Bag = BAG_Empty;
        NpcRole = 0;
        Dead = false;
        Armor = 0;
        Helmet = 0;
        OverrideCrtype = 0;
        Minimum = 0;
        Maximum = 0;
        Slot = 0;
        cost = 0;
        BrokenMin = 0;
        BrokenMax = 0;
        TeamId = 0;
    }

    CEncounterObject@ NewCheck(uint type, uint index, uint8 operator, int value)
    {
        uint len = Checks.length();
        Checks.resize(len + 1);
        Checks[len].Set(type, index, operator, value);
        return this;
    }

    CEncounterObject@ SetPid(uint16 pid)                            { Pid = pid; return this; }
    CEncounterObject@ SetDialog(uint dialog)                        { Dialog = dialog; return this; }
    CEncounterObject@ SetScript(string& script)                     { Script = script; return this; }
    CEncounterObject@ SetBag(uint bag)                              { Bag = bag; return this; }
    CEncounterObject@ SetNpcRole(uint role)                         { NpcRole = role; return this; }
    CEncounterObject@ SetTeamId(uint teamid)                        { TeamId = teamid; return this; }
    CEncounterObject@ SetTeamId(uint faction, uint rank, uint mode) { TeamId = _TeamIdPack(faction, rank, mode); return this; }

    CEncounterObject@ SetDistance(uint distance)                       { Distance = distance; return this; }
    CEncounterObject@ CheckRandom(int value)                           { NewCheck(CHECK_RANDOM, 0, 0, value); return this; }
    CEncounterObject@ CheckStat(uint index, uint8 operator, int value) { NewCheck(CHECK_STAT, index, operator, value); return this; }
    CEncounterObject@ CheckPerk(uint index, uint8 operator, int value) { NewCheck(CHECK_PERK, index, operator, value); return this; }
    CEncounterObject@ CheckLVar(uint index, uint8 operator, int value) { NewCheck(CHECK_LVAR, index, operator, value); return this; }
    CEncounterObject@ CheckGVar(uint index, uint8 operator, int value) { NewCheck(CHECK_GVAR, index, operator, value); return this; }
    CEncounterObject@ CheckHour(uint8 operator, int value)             { NewCheck(CHECK_HOUR, 0, operator, value); return this; }
    CEncounterObject@ SetRatio(uint ratio)                             { Ratio = ratio; return this; }
    CEncounterObject@ SetDead(bool dead)                               { Dead = dead; return this; }
    CEncounterObject@ SetMinimum(uint minimum)                         { Minimum = minimum; return this; }
    CEncounterObject@ SetMaximum(uint maximum)                         { Maximum = maximum; return this; }
    CEncounterObject@ SetSlot(uint slot)                               { Slot = slot; return this; }

    CEncounterObject@ Mode(uint mode)
    {
        return Mode(mode, 1);
    }
    CEncounterObject@ Mode(uint mode, uint val)
    {
        uint len = modes.length();
        modes.resize(len + 2);
        modes[len] = mode;
        modes[len + 1] = val;
        return this;
    }

    CEncounterObject@ AddPerk(uint index, uint level, uint chance)
    {
        CEncounterPerk@ perk = CEncounterPerk(index, level, chance);
        this.Perks.insertLast(perk);
        return this;
    }

    CEncounterObject@ AddItem(uint16 pid, uint min, uint max, uint slot)
    {
        return this.AddItem(pid, min, max, slot, MAX_BROKENS - 60, MAX_BROKENS - 40);
    }

    CEncounterObject@ AddItem(uint16 pid, uint min, uint max, uint slot, uint brokenMin, uint brokenMax)
    {
        ProtoItem@ proto = GetProtoItem(pid);
        if(!valid(proto))
            return this;
        uint             len = Childs.length();
        Childs.resize(len + 1);
        CEncounterObject new_child;
        @Childs[len] = new_child;
        new_child.SetPid(pid);
        new_child.SetMinimum(min);
        new_child.SetMaximum(max);
        new_child.SetSlot(slot);
        if(proto.Deteriorable)
        {
            new_child.BrokenMin = brokenMin;
            new_child.BrokenMax = brokenMax;
        }
        uint thiscost = BaseItemValue(pid, (new_child.BrokenMin + new_child.BrokenMax + 1) / 2, 0, true);
        thiscost = (min * thiscost + max * thiscost) / 2; // average cost, yes
        cost += thiscost;
        return this;
    }

    /**
     * Value required to generate given object, for the purpose of calculating the average priece only.
     */
    uint GetCost() { return cost; }

    /**
     * Set modes for given critter' instance.
     */
    void SetModes(Critter& npc)
    {
        for(uint i = 0, j = modes.length(); i < j; i += 2)
            npc.ModeBase[modes[i]] = modes[i + 1];
    }
};

class CEncounterGroup
{
    uint Index;     // index to the global EncounterGroup array
    uint TeamNum;   // as in now-deprecated (!) team id: 100*faction + 10* rank + mode, or mob/neutral group number (if below 200)
    uint Position;
    uint Spacing;
    // distance from center of encounter
    uint DistMin;
    uint DistMax;
    // denotes number of 'ratio' critters in group...some critters can be multiplied using those values
    // using their Ratio(EncounterObject::Ratio) property. It's percentage. For example, radscorpion in Radscorpions group have ratio 100%
    // so if RatioMin is equal to 1 and RatioMax is equal to 10 we will get Random(1,10) radscorpions
    uint RatioMin;
    uint RatioMax;

    uint Cost;

    // quantity ratio modifiers
    float                   QuantityNight;
    float                   QuantityDay;

    array<CEncounterObject> Objects;

    CEncounterGroup()
    {
        TeamNum = 0;
        Position = 0;
        Spacing = 0;
        // default values
        DistMin = 7;
        DistMax = 15;
        // defaults, but should be set per group also
        RatioMin = 1;
        RatioMax = 3;

        Cost = 0;

        QuantityNight = QuantityDay  = 1.0f;
    }
    /**
     * Gets the modified quantity for the group, basing on the value passed from zone.
     */
    uint GetModifiedQuantity(uint quantity)
    {
        if(IsNight())
            return uint(QuantityNight * quantity);
        else
            return uint(QuantityDay * quantity);
    }

    /**
     * Gets value needed to spawn group, knowing the ratio
     */
    uint GetCost(int ratio)
    {
        uint cost = 0;
        for(uint i = 0, j = Objects.length(); i < j; i++)
        {
            cost += MAX((Objects[i].Ratio * ratio) / 100, 1) * Objects[i].GetCost();   // number of objects times it's cost
        }
        return cost;
    }

    /**
     * Sets the average vaule of the group, derived from ratio and objects. It must be called every time the group is defined, see InitGroupsCost().
     */
    void SetAverageCost() // obsolete
    {
        this.Cost = 0;

        for(uint ratio = RatioMin; ratio <= RatioMax; ratio++)     // for every possible critters number, simulate spawning
        {
            for(uint i = 0, j = Objects.length(); i < j; i++)
            {
                // TODO, but not really: test "if random(a,b) > n" checks
                this.Cost += MAX((Objects[i].Ratio * ratio) / 100, 1) * Objects[i].GetCost();   // number of objects times it's cost
            }
        }
    }

    CEncounterObject@ NewObject()
    {
        uint len = Objects.length();
        Objects.resize(len + 1);
        return Objects[len];
    }

    CEncounterObject@ AddCritter(uint16 pid)
    {
        CEncounterObject@ obj = NewObject();
        obj.ObjectType = ENCOUNTER_OBJECT_CRITTER;
        obj.Pid = pid;
        return obj;
    }

    CEncounterObject@ AddItem(uint16 pid)
    {
        CEncounterObject@ obj = NewObject();
        obj.ObjectType = ENCOUNTER_OBJECT_ITEM;
        obj.Pid = pid;
        return obj;
    }
    /**
     * Check timeout for group.
     */
    /*bool CheckTimeout(Critter@ leader)
       {
            GameVar @var = GetUnicumVar(UVAR_enc_timeout, leader.Id, Index+1); // 0 id not allowed for slave-ids in uvariables
            if (var.GetValue() != 0 && uint(var.GetValue()) > ELAPSED_TIME)
            {
                    DPlayerLog(leader, "Time left for group: " + Index +": " + (var.GetValue() - ELAPSED_TIME));
                    return false;
            }
            return true;
       }
     */
};
class CAction
{
    int Target;     // target group within encounters groups
    int Action;     // action type
};
class CEncounter
{
    int         Difficulty;   // taken from zone
    uint16      LocationPid;
    bool        Special;
    array<uint> Groups;
    array<uint> Players;     // GROUP_Player(i) -> Players[i]
    // uint[] RatioMin;
    // uint[] RatioMax;
    array<CCheck> Checks;
    uint          Ratio;
    // cost of this encounter, increased when a group is added
    // int Cost;

    CEncounter()
    {
        Difficulty = 0;
        LocationPid = 0;
        Special = false;
        // Cost = 0;
        Ratio = 0;
    }

    /**
     * Checks if the value in encounter's zone is sufficient to 'fund the encounter'.
     * scrapped for now
     */
    /*bool CheckCost(Critter@ leader)
       {
        IZone@ zone = GetZone(leader.WorldX, leader.WorldY);
        if(leader.IsPlayer() && leader.GetAccess() == ACCESS_ADMIN)
            leader.Say(SAY_NETMSG, "Value required/existing for encounter: " + this.GetCost() + "/" + zone.GetValue());
        //return zone.GetValue() >= this.Cost || this.Cost == 0; // old version; has problems with proper diffusion of wealth
        return (zone.GetValue() > 0) || (this.GetCost() == 0); // means that the zone will take credit often

       }*/

    CEncounter@ AddGroup(uint group /*, uint ratioMin, uint ratioMax*/)
    {
        uint len = Groups.length();
        Groups.resize(len + 1);
        // RatioMin.resize(len+1);
        // RatioMax.resize(len+1);
        Groups[len] = group;
        // RatioMin[len]=ratioMin;
        // RatioMax[len]=ratioMax;
        // if (group < GROUP_MAX)
        //	this.Cost += EncounterGroups[group].GetCost();
        return this;
    }
    CEncounter@ AddPlayer(Critter& player)
    {
        AddGroup(GROUP_Player(int(player.Id)));
        return this;
    }
    Critter@ GetPlayer(uint i)
    {
        return GetCritter(uint(-1) - Groups[i]);
    }
    CEncounter@ NewCheck(uint type, uint index, uint8 operator, int value)
    {
        uint len = Checks.length();
        Checks.resize(len + 1);
        Checks[len].Set(type, index, operator, value);
        return this;
    }

    CEncounter@ SetLocationPid(uint16 locationPid)               { LocationPid = locationPid; return this; }
    CEncounter@ SetSpecial(bool special)                         { Special = special; return this; }
    CEncounter@ CheckRandom(int value)                           { NewCheck(CHECK_RANDOM, 0, 0, value); return this; }
    CEncounter@ CheckStat(uint index, uint8 operator, int value) { NewCheck(CHECK_STAT, index, operator, value); return this; }
    CEncounter@ CheckPerk(uint index, uint8 operator, int value) { NewCheck(CHECK_PERK, index, operator, value); return this; }
    CEncounter@ CheckLVar(uint index, uint8 operator, int value) { NewCheck(CHECK_LVAR, index, operator, value); return this; }
    CEncounter@ CheckGVar(uint index, uint8 operator, int value) { NewCheck(CHECK_GVAR, index, operator, value); return this; }
    CEncounter@ CheckHour(uint8 operator, int value)             { NewCheck(CHECK_HOUR, 0, operator, value); return this; }

    int GenerateEncounterString(Critter& cr, string@ str, bool groupAdded, bool awareness)
    {
        int s = 0;
        for(uint i = 0, j = groupAdded ? Groups.length() - 1 : Groups.length(); i < j; i++)
        {
            if(Groups[i] >= GROUP_MAX)               // players
            {
                Critter@ player = GetPlayer(i);
                if(!valid(player) || player.Id == cr.Id)
                    continue;
                if(player.IsNpc())
                    str += "$str" + (++s) + "caravan";
                else if(awareness)
                    str += "$str" + (++s) + "|0xffff0000 " + player.Name;
                else
                    str += "$str" + (++s) + "wastelander";
            }
            else
            {
                str += "$str" + (++s) + "@msg gm " + (20000000 + Groups[i]) + "@";
            }
            // in case the player logged out in the meantime. if player is invalid, use -1, since logged out player is not the one getting the string:
            bool prelast = i + 2 == j && (Groups[i + 1] < GROUP_MAX || (Groups[i + 1] >= GROUP_MAX && getProbablyId(i + 1) != cr.Id));     // some other group, but not you
            bool last = (i + 1 == j) || (i + 1 < j && Groups[i + 1] >= GROUP_MAX && getProbablyId(i + 1) == cr.Id);

            if(last)
                str += ".";
            else if(prelast)
                str += " and ";
            else
                str += ", ";
        }
        return s;
    }

    uint getProbablyId(uint i)     // helper
    {
        Critter@ probablyPlayer = GetPlayer(i);
        return valid(probablyPlayer) ? probablyPlayer.Id : uint(-1);
    }

	//leader.SayMsg(SAY_ENCOUNTER_TB, TEXTMSG_GM, feAlready.OwnerGroup ? (10000026) : (10000025),  "$str1" + "|0xffff0000 " + "Encounter is in TURN-BASED mode." + "|0x0000FF00 " + "\n\n" + "$str2" + "Do you wish to encounter: " + "$player" + GetSafePlayerName(feAlready.OwnerId));
    void Ask(int say, Critter@ leader, bool isTB)
    {
        string str;
        DPlayerLog(leader, "Asking about " + Groups.length() + " groups.");
        int    s = GenerateEncounterString(leader, str, false, true);
        DPlayerLog(leader, str);
		if(isTB)
		{
			str += "\n\n" + "$str" + (++s) + "$str" + (++s) + "|0xffff5500 " + "Encounter is in TURN-BASED mode.";
		}

		leader.SayMsg(say, TEXTMSG_GM, 10000010 + s, str);
    }
    void Say(Critter@ leader, Critter@ player)
    {
        string str;
        // special encounters
        if(Special)
        {
            str += "$str1@msg gm " + (((100 + LocationPid) * 1000) + 5) + "@";
            player.SayMsg(SAY_NETMSG, TEXTMSG_GM, 10000000, str);
        }
        else         // normal
        {
            int s = GenerateEncounterString(leader, str, true, true);

            player.SayMsg(SAY_NETMSG, TEXTMSG_GM, 10000000 + s, str);
        }
    }
    bool IsSingleGroup() { return Groups.length() <= 2; }     // some group and player

    int GetCost()
    {
        int cost = 0;
        for(uint i = 0, j = Groups.length(); i < j; i++)
            if(Groups[i] < GROUP_MAX)
                cost += EncounterGroups[Groups[i]].GetCost(Ratio);
        return cost;
    }
};

class CZone : IZone
{
    array<uint>   Groups;
    array<int>    Quantities;
    array<uint>   Flags;
    // world coords
    uint          x;
    uint          y;
    int           Difficulty;
    array<uint16> LocationPids;
    uint          Terrain;
    uint          Fill;
    uint          MorningChance;
    uint          AfternoonChance;
    uint          NightChance;
    // percentage factor that adjust a chance of finding prospects (and other special encounters in the future)
    // initialized on every start, so that it gives some randomness to how players need to look for things
    uint8 Factor;
    // value that can be used to generate encounter objects
    int   value;
    CZone(uint x, uint y)
    {
        this.x = x;
        this.y = y;
        Difficulty = 0;
        Terrain = 0;
        Fill = 0;
        MorningChance = 0;
        AfternoonChance = 0;
        NightChance = 0;
        Factor = Random(1, 100);
        // value = Random(1000, 5000);
        value = 0;
    }
    uint GetX() { return x; }
    uint GetY() { return y; }
    uint GetLocationPids(array<uint16>& pids)
    {
        for(uint i = 0, j = LocationPids.length(); i < j; i++)
            pids.insertLast(LocationPids[i]);
        return LocationPids.length();
    }
    /**
     * Checks if zone is flagged with given flag.
     */
    bool ContainsFlag(uint flag)
    {
        for(uint i = 0, j = Flags.length(); i < j; i++)
            if(Flags[i] == flag)
                return true;
        return false;
    }
    /**
     * Retrieves quantity of the given group in zone, taking the day/night modifiers into account.
     */
    uint GetQuantity(uint group)
    {
        for(uint i = 0, j = Groups.length(); i < j; i++)
            if(Groups[i] == group)
                return EncounterGroups[Groups[i]].GetModifiedQuantity(Quantities[i]);
        return 0;
    }
    /**
     * Retrieves base quantity of the given group in zone (without their day/night mods).
     */
    uint GetBaseQuantity(uint group)
    {
        for(uint i = 0, j = Groups.length(); i < j; i++)
            if(Groups[i] == group)
                return Quantities[i];
        return 0;
    }
    /**
     * Sets the quantity for given group.
     */
    void SetQuantity(uint group, uint quantity)
    {
        for(uint i = 0, j = Groups.length(); i < j; i++)
        {
            if(Groups[i] == group)
            {
                Quantities[i] = quantity;
                // fixme: performance?
                SaveGroupsQuantities();
                return;
            }
        }
        // add new group
        Groups.insertLast(group);
        Quantities.insertLast(quantity);
        // fixme: performance?
        SaveGroupsQuantities();
    }
    /**
     * Changes the quantity for given group.
     */
    void ChangeQuantity(uint group, int mod)
    {
        for(uint i = 0, j = Groups.length(); i < j; i++)
        {
            if(Groups[i] == group)
            {
                Quantities[i] = MAX(0, Quantities[i] + mod);
                // fixme: performance?
                SaveGroupsQuantities();
                return;
            }
        }
        if(mod > 0)
        {
            // add new group
            Groups.insertLast(group);
            Quantities.insertLast(mod);
        }
        // fixme: performance?
        SaveGroupsQuantities();
    }
    /**
     * Chance (to be tested as percentage) of the encounter in given zone, depending on the groups and their quantities, and the current time.
     */
    uint GetChance() // GetChance, jako szansa na enco w kratce - jest to suma wszystkich wartosci Quantity(ustawiane w edytorze, np. 3 itp) kazdej grupy w kratce
    {
        uint sum = 0;
		//Log("Groups.length(): " + Groups.length());
        for(uint i = 0, j = Groups.length(); i < j; i++)
		{
			//Log("EncounterGroups[Groups[" + i + "]].GetModifiedQuantity(Quantities[" + i + "]): " + EncounterGroups[Groups[i]].GetModifiedQuantity(Quantities[i]));
            //Log("Quantities[" + i + "]: " + Quantities[i]);
			sum += EncounterGroups[Groups[i]].GetModifiedQuantity(Quantities[i]);
		}
		if(sum > MAX_ENCO_CHANCE) sum = MAX_ENCO_CHANCE; // ograniczenie szansy na encountera
        return sum;
    }
    /**
     * Retrieves the value for that zone.
     */
    int GetValue()
    {
        return value;
    }
    void SetValue(int val)
    {
        this.value = val;
    }
    void AddValue(int val)
    {
        this.value += val;
    }
    /**
     * Decreases value for given zone.
     */
    void SubValue(uint val)
    {
        value -= val;
    }
    /**
     * Retrieves the type of terrain for given world-coordinates.
     */
    uint GetTerrain()
    {
        return Terrain;
    }
    /**
     * Gets the random factor that decides about special discoveries.
     */
    uint8 GetFactor()
    {
        return Factor;
    }
    /**
     * Sets the random factor that decides about special discoveries.
     */
    void SetFactor(uint8 factor)
    {
        this.Factor = CLAMP(factor, 1, 100);
    }
    void AddLocationPid(uint16 locationPid)
    {
        uint len = LocationPids.length();
        LocationPids.resize(len + 1);
        LocationPids[len] = locationPid;
    }
    /**
     * Chooses groups for an encounter.
     */
    void ChooseGroups(Critter& leader, CEncounter& enc)
    {
        // filter out timeouted groups
        array<uint> available;
        int         available_sum = 0;
        int         sum = 0;

        for(uint i = 0, j = Groups.length(); i < j; i++)  //Groups.length() - ilosc grup w kratce
        {
            //Log("Groups[" + i + "] = " + Groups[i]);
			if(Groups[i] >= EncounterGroups.length())  // Groups[i] to jest numer Index-u grupy enco z calej ich listy, czyli numer grupy np GROUP_CRV_MAD_WARRIORS=138
                Log("FE: Incorrect group in zone: " + ZONE_X(leader.WorldX) + "," + ZONE_Y(leader.WorldY));
            #ifndef __DEBUG__
            // if(EncounterGroups[Groups[i]].CheckTimeout(leader))
            if(true)
            #endif
            #ifdef __DEBUG__
            if(true)
            #endif
            {
                available.insertLast(i);
                available_sum += EncounterGroups[Groups[i]].GetModifiedQuantity(Quantities[i]);                 // instead of GetQuantity(i) to avoid loop-lookups
            }
            sum += EncounterGroups[Groups[i]].GetModifiedQuantity(Quantities[i]);
        }

        int roll = Random(1, available_sum);
        int v = 0;
        int already = 0;
        DPlayerLog(leader, "Choosing group: " + roll + "/" + available_sum);
        for(uint i = 0, j = available.length(); i < j; i++)  //available.length() - ilosc grup do wykorzystania
        {
            int  quantity = Quantities[available[i]]; // liczebnosc(quantity) danej grupy o indeksie groupidx
            uint groupidx = Groups[available[i]]; // available[] - tablica numerow indeksow grup z kratki bedacych mozliwych do wykorzystania
            v += quantity;
            if(roll - v <= 0)
            {
                DPlayerLog(leader, "Chosen group: " + groupidx + ":" + roll + "/" + quantity);
				//Log("Chosen group: " + groupidx + ":" + roll + "/" + quantity);
                enc.AddGroup(groupidx);
                already = i;
                break;
            }
        }


        // iterate through groups and try to combine them into some nicer encounter
        for(int i = 0, j = available.length(); i < j; i++)
        {
            int  quantity = Quantities[available[i]];
            uint groupidx = Groups[available[i]];
            if(i == already)
                continue;
            int  roll = Random(1, 2*sum); // mnozenie przez 2 w celu zmniejszenia liczby grup w jednym enco; bylo int  roll = Random(1, sum);
            bool success = roll <= quantity;

            DPlayerLog(leader, "Roll for group: " + groupidx + ": " + roll + " vs " + quantity + "/" + sum);
			//Log("Roll for group: " + groupidx + ": " + roll + " vs " + quantity + "/" + sum);
            #ifndef __DEBUG__
            // if(success && EncounterGroups[groupidx].CheckTimeout(leader))
            if(success)
            #endif
            #ifdef __DEBUG__
            if(success)
            #endif

            enc.AddGroup(Groups[available[i]]);
        }

    }


    /** 06-02-2014 Cubik: nowa funckja ChooseGroups2 uwzgledniajaca czy to jest karawana, liczbe graczy i level gracza
     * Chooses groups for an encounter.
     */
    void ChooseGroups2(Critter& leader, CEncounter& enc, int max_level_gracza, bool isCaravan, uint players_count, int min_level_gracza, bool isPlayerCaravan)
    {
        bool NewEncoAvailable=false;
		if((isCaravan && min_level_gracza>=9) || (players_count>=3 && min_level_gracza>=9) || isPlayerCaravan) NewEncoAvailable=true;


		//Log("NewEncoAvailable= " + NewEncoAvailable);

		// filter out timeouted groups
        array<uint> available;
        int         available_sum = 0;
        int         sum = 0;

		//Log("ChooseGroups:Groups.length() = " + Groups.length());
        for(uint i = 0, j = Groups.length(); i < j; i++)  //Groups.length() - ilosc grup w kratce
        {
            //Log("Groups[" + i + "] = " + Groups[i]);
			if(Groups[i] >= EncounterGroups.length())  // Groups[i] to jest numer Index-u grupy enco z calej ich listy, czyli numer grupy np GROUP_CRV_MAD_WARRIORS=138
                Log("FE: Incorrect group in zone: " + ZONE_X(leader.WorldX) + "," + ZONE_Y(leader.WorldY));
            #ifndef __DEBUG__
            // if(EncounterGroups[Groups[i]].CheckTimeout(leader))
            if(true)
            #endif
            #ifdef __DEBUG__
            if(true)
            #endif
            {
                if(NewEncoAvailable==true)
				{
					available.insertLast(i);  // wrzuca indexy grup enco z kratki do koszyka do wykorzystania
					available_sum += EncounterGroups[Groups[i]].GetModifiedQuantity(Quantities[i]);                 // instead of GetQuantity(i) to avoid loop-lookups
				}
				if(NewEncoAvailable==false)
				{
					if(Groups[i]<=134 || (Groups[i]>=145 && Groups[i]<GROUP_MAX)) // jesli enco zwykle o indexie <=134 lub >=145 to dodawaj
					{
						available.insertLast(i);  // wrzuca indexy grup enco z kratki do koszyka do wykorzystania
						available_sum += EncounterGroups[Groups[i]].GetModifiedQuantity(Quantities[i]);                 // instead of GetQuantity(i) to avoid loop-lookups
					}
				}
            }

			if(NewEncoAvailable==true)
            {
				sum += EncounterGroups[Groups[i]].GetModifiedQuantity(Quantities[i]);
			}
			if(NewEncoAvailable==false)
			{
				if(Groups[i]<=134 || (Groups[i]>=145 && Groups[i]<GROUP_MAX)) // jesli enco zwykle o indexie <=134 lub >=145 to dodawaj
					sum += EncounterGroups[Groups[i]].GetModifiedQuantity(Quantities[i]);
			}
        }

		//Log("available_sum: " + available_sum);
		//Log("sum: " + sum);
		// available_sum - suma wartosci quantity wszystkich grup w kratce
		// sum - j.w. powtorzona wartosc do dlaszych obliczen
        int roll = Random(1, available_sum);
		//Log("roll = Random(1, available_sum): " + roll);
        int v = 0;
        int already = 0;
        DPlayerLog(leader, "Choosing group: " + roll + "/" + available_sum);
        for(uint i = 0, j = available.length(); i < j; i++)  //available.length() - ilosc grup do wykorzystania
        {
            int  quantity = Quantities[available[i]]; // liczebnosc(quantity) danej grupy o indeksie groupidx
            uint groupidx = Groups[available[i]]; // available[] - tablica numerow indeksow grup z kratki bedacych mozliwych do wykorzystania

			if(NewEncoAvailable==true)
			{
				v += quantity;
				if(roll - v <= 0)
				{
					DPlayerLog(leader, "Chosen group: " + groupidx + ":" + roll + "/" + quantity);
					//Log("Chosen group: Groups[available["+i+"]]: " + groupidx);
					//Log("Chosen group: " + groupidx);
					enc.AddGroup(groupidx);
					already = i;
					break;
				}
			}

			if(NewEncoAvailable==false)
			{
				if(Groups[i]<=134 || (Groups[i]>=145 && Groups[i]<GROUP_MAX)) // jesli enco zwykle o indexie <=134 lub >=145 to dodawaj
				{
					v += quantity;
					if(roll - v <= 0)
					{
						DPlayerLog(leader, "Chosen group: " + groupidx + ":" + roll + "/" + quantity);
						//Log("Chosen group: " + groupidx);
						enc.AddGroup(groupidx);
						already = i;
						break;
					}
				}
			}
        }


        // iterate through groups and try to combine them into some nicer encounter
        for(int i = 0, j = available.length(); i < j; i++)
        {
            int  quantity = Quantities[available[i]];
            uint groupidx = Groups[available[i]];
            if(i == already)
                continue;
            int  roll = Random(1, 2*sum); // mnozenie przez 2 w celu zmniejszenia liczby grup w jednym enco; bylo int  roll = Random(1, sum);
            bool success = roll <= quantity;

            DPlayerLog(leader, "Roll for group: " + groupidx + ": " + roll + " vs " + quantity + "/" + sum);
			//Log("Roll for group: " + groupidx + ": " + roll + " vs " + quantity + "/" + sum);
            #ifndef __DEBUG__
            // if(success && EncounterGroups[groupidx].CheckTimeout(leader))
            if(success)
            #endif
            #ifdef __DEBUG__
            if(success)
            #endif
			{
				//Log("AddGroup: " + Groups[available[i]]);
				enc.AddGroup(Groups[available[i]]);
			}
        }

    }

};

array<CEncounterGroup> EncounterGroups(GROUP_MAX);
array<CZone@>          Worldmap(ZONE_COUNT_X* ZONE_COUNT_Y);

//
// Zone
//

/**
 * Retrieves zone for given world-coords.
 */
IZone@ GetZone(uint x, uint y)
{
    uint zx = ZONE_X(x);
    uint zy = ZONE_Y(y);
    return Worldmap[ZONE_IDX(zx, zy)];
}

bool ZoneContainsFlag(CZone@ zone, uint flag)
{
    return zone.ContainsFlag(flag);
}
/**
 * Fetches the zones that are marked with given flag.
 */
uint GetZonesWithFlag(uint flag, array<IZone@>@ zones)
{
    for(uint i = 0, j = Worldmap.length(); i < j; i++)
        if(Worldmap[i].ContainsFlag(flag))
            zones.insertLast(Worldmap[i]);
    return zones.length();
}

/**
 * Retrieves zone for given zone-coords.
 */
/*IZone@ GetZoneByZCoords(uint zx, uint zy)
   {
        return Worldmap[zx, zy];
   }*/

/**
 * Injects value given by the amount to the zones chosen using world coordinate.
 */
#define _InjectLog    # (text) file __f; __f.open("logs/injectvalue.log", "a"); __f.writeString(GetCurrentDateTimeString() + "> " + text + "\n"); __f.close();
void InjectValue(uint x, uint y, uint amount, uint from)
{
    if(amount == 0)
        return;
    int  spread = 4;

    uint zx = ZONE_X(x);
    uint zy = ZONE_Y(y);
    _InjectLog(amount + " " + from);
    while(amount > 0)
    {
        uint   x = Random(MAX(0, zx - spread), MIN(zx + spread, ZONE_COUNT_X - 1));
        uint   y = Random(MAX(0, zy - spread), MIN(zy + spread, ZONE_COUNT_Y - 1));
        IZone@ zone = Worldmap[ZONE_IDX(x, y)];
        uint   am = Random(1, amount);
        zone.AddValue(am);
        amount -= am;
    }
}
/**
 * Total value of encounter store.
 */
int WorldmapGetTotalValue()
{
    int sum = 0;
    for(uint zx = 0; zx < ZONE_COUNT_X; zx++)
    {
        for(uint zy = 0; zy < ZONE_COUNT_Y; zy++)
        {
            IZone@ zone = Worldmap[ZONE_IDX(zx, zy)];
            sum += zone.GetValue();
        }
    }
    return sum;
}

// table is obsolete
CZone@ SetZone(uint zx, uint zy, uint table, int difficulty, uint terrain, uint fill, uint morningChance, uint afternoonChance, uint nightChance)
{
    CZone@ zone = Worldmap[zy * ZONE_COUNT_X + zx];
    zone.Difficulty = difficulty;
    zone.Terrain = terrain;
    zone.Fill = fill;
    zone.MorningChance = morningChance;
    zone.AfternoonChance = afternoonChance;
    zone.NightChance = nightChance;
    return zone;
}

CZone@ SetZone(uint zx, uint zy, uint table, int difficulty, uint terrain, uint fill, uint chance)
{
    return SetZone(zx, zy, table, difficulty, terrain, fill, chance, chance, chance);
}

//
// Checks
//

bool CheckCompare(int val1, uint8 operator, int val2)
{
    if(operator == '>')
        return val1 > val2;
    if(operator == '<')
        return val1 < val2;
    if(operator == '=')
        return val1 == val2;
    Log("Unknown operator.");
    return false;
}

bool CheckChecks(array<CCheck>@ checks, array<Critter@>@ critters)
{
    for(int i = 0, j = checks.length(); i < j; i++)
    {
        CCheck@ check = checks[i];
        switch(check.Type)
        {
        case CHECK_RANDOM:
            if(Random(1, 100) > check.Value)
                return false;
            break;
        case CHECK_HOUR:
            if(!CheckCompare(__Hour, check.Operator, check.Value))
                return false;
            break;
        case CHECK_STAT:
            for(uint i = 0, j = critters.length(); i < j; i++)
                if(!CheckCompare(critters[i].Stat[check.Index], check.Operator, check.Value))
                    return false;
            break;
        // case CHECK_SKILL: for(uint i=0,j=critters.length();i<j;i++) if(not CheckCompare(critters[i].Skill[check.Index],check.Operator,check.Value)) return false; break;
        case CHECK_PERK:
            for(uint i = 0, j = critters.length(); i < j; i++)
                if(!CheckCompare(critters[i].Perk[check.Index], check.Operator, check.Value))
                    return false;
            break;
        case CHECK_LVAR:
            for(uint i = 0, j = critters.length(); i < j; i++)
            {
                GameVar@ lvar = GetLocalVar(check.Index, critters[i].Id);
                if(!valid(lvar))
                {
                    Log("Local var !found.");
                    return false;
                }
                if(!CheckCompare(lvar.GetValue(), check.Operator, check.Value))
                    return false;
            }
            break;
        case CHECK_GVAR:
        {
            GameVar@ gvar = GetGlobalVar(check.Index);
            if(!valid(gvar))
            {
                Log("Global var !found.");
                return false;
            }
            if(!CheckCompare(gvar.GetValue(), check.Operator, check.Value))
                return false;
        }
        break;
        default:
            Log("Unknown check.");
            return false;
        }
    }
    return true;
}

//
// Stored founded encounters
//

#define FOUNDED_ENCOUNTER_LIVE_TIME    (REAL_MINUTE(60))     // 10 real minutes

class CFoundedEncounter
{
    uint        Index;

    CEncounter@ Encounter;
    CZone@      Zone;
    bool        IsGenerated;
    uint        FullSecond;
    uint        PositionX;
    uint        PositionY;
    uint        OwnerId;
    bool        OwnerGroup;
    bool        TurnBased;
    uint        LocationId;
    uint16      StartHexX;
    uint16      StartHexY;
    array<bool> DirBusy;
    uint8       FirstDirIdx;   // for nicer placement
    uint        AskChance;
    array<uint> Actions;       // from*to*action

    CFoundedEncounter()
    {
        Index = 0;
        @Encounter = null;
        @Zone = null;
        IsGenerated = false;
        FullSecond = 0;
        PositionX = 0;
        PositionY = 0;
        OwnerId = 0;
        OwnerGroup = false;
        TurnBased = false;
        LocationId = 0;
        StartHexX = 0;
        StartHexY = 0;
        DirBusy.resize(6);
        for(uint i = 0; i < 6; i++)
            DirBusy[i] = false;
        FirstDirIdx = 0;
    }
    /**
     * Determines action between 2 groups.
     */
    int DetermineAction(int gr1, int gr2)
    {
        int status = GetGroupsStatus(gr2, gr1);
        switch(status)
        {
        case FACTION_NEUTRAL:
            return ACTION_NONE;
        case FACTION_ALLY:
            return ACTION_NONE;
        case FACTION_ENEMY:
            return ACTION_FIGHTING;
        }
        return ACTION_FIGHTING;
    }
    /**
     * Prepares actions for groups.
     */
    void PrepareActions()
    {
        for(uint i = 0, k = Encounter.Groups.length(); i < k; i++)
        {
            CEncounterGroup@ gr1;
            if(Encounter.Groups[i] < GROUP_MAX)
                @gr1 = EncounterGroups[Encounter.Groups[i]];
            else
                continue;                 // player
            // get the opponents
            for(uint j = 0, l = Encounter.Groups.length(); j < l; j++)
            {
                if(i == j)
                    continue;
                CEncounterGroup@ gr2;
                if(Encounter.Groups[j] < GROUP_MAX)
                    @gr2 = EncounterGroups[Encounter.Groups[j]];
                Actions.insertLast(i);
                Actions.insertLast(j);
                if(valid(gr1) && gr1.TeamNum == 0)                   // mob
                {
                    Actions.insertLast(ACTION_FIGHTING);
                }
                else
                {
                    if(valid(gr1) && valid(gr2))
                    {
                        int action = DetermineAction(GetGroupIndex(gr1.TeamNum), GetGroupIndex(gr2.TeamNum));
                        Actions.insertLast(action);
                    }
                    else if(valid(gr1) && !valid(gr2))                       // group -> player
                    {
                        // check reputation
                        Critter@ leader = Encounter.GetPlayer(j);
                        if(valid(leader))
                        {
                            DPlayerLog(leader, "Checking your reputation with regard to group: " + GetGroupIndex(gr1.TeamNum) + " which is " + leader.Reputation[GetGroupIndex(gr1.TeamNum)]);
                            if(leader.Reputation[GetGroupIndex(gr1.TeamNum)] < __ReputationNeutral)
                            {
                                Actions.insertLast(ACTION_FIGHTING);
                            }
                            else
                            {
                                Actions.insertLast(ACTION_NONE);
                            }
                        }
                        else
                            Actions.insertLast(ACTION_NONE);
                    }
                    else
                        Actions.insertLast(ACTION_NONE);
                }
            }
        }
    }
};

array<CFoundedEncounter> FoundedEncounters(1000);
uint FoundedEncountersLastIndex = 0;

CFoundedEncounter@ CreateFoundedEncounter(uint x, uint y, CEncounter@ encounter, CZone@ zone, uint ownerId, bool ownerGroup)
{
	//Log("CreateFoundedEncounter: ");
	//Log("x,y= " + x + "," + y);
	//Log("ownerId= " + ownerId);
	//Log("ownerGroup= " + ownerGroup);

    for(int i = 0, j = FoundedEncounters.length(); i < j; i++)
    {
        CFoundedEncounter@ ge = FoundedEncounters[i];
        if(ge.Index == 0  || (ELAPSED_TIME - ge.FullSecond >= FOUNDED_ENCOUNTER_LIVE_TIME && ge.TurnBased))
        {
            FoundedEncountersLastIndex++;
            ge.Index = FoundedEncountersLastIndex;
            @ge.Encounter = encounter;
            @ge.Zone = zone;
            ge.IsGenerated = false;
            ge.FullSecond = ELAPSED_TIME;
            ge.PositionX = x;
            ge.PositionY = y;
            ge.OwnerId = ownerId;
            ge.OwnerGroup = ownerGroup;
            ge.LocationId = 0;
            ge.Actions.resize(0);
            for(uint k = 0; k < 6; k++)
                ge.DirBusy[k] = false;
            ge.FirstDirIdx = 0;
			//Log("CreateFoundedEncounter: return ge");
            return ge;
        }
    }

    // Grow buffer and refind
    FoundedEncounters.resize(FoundedEncounters.length() * 2);
    return CreateFoundedEncounter(x, y, encounter, zone, ownerId, ownerGroup);
}

CFoundedEncounter@ GetFoundedEncounter(uint index)
{
    for(int i = 0, j = FoundedEncounters.length(); i < j; i++)
    {
        CFoundedEncounter@ ge = FoundedEncounters[i];
        if(ge.Index == index)
		{
			//Log("GetFoundedEncounter:");
			//Log("return ge;  ge.Index = " + ge.Index);
			//Log("ge.LocationId= " + ge.LocationId);
			return ge;
		}
    }
    return null;
}

CFoundedEncounter@ GetNearFoundedEncounter(array<Critter@>@ group, uint x, uint y, uint radius)
{
    int combatMode = group[0].Mode[MODE_DEFAULT_COMBAT];
	//Log("combatMode = " + combatMode);
	//Log("x, y = " + x + ", " + y);
	//Log("radius = " + radius);
    for(int i = 0, j = FoundedEncounters.length(); i < j; i++)
    {
        CFoundedEncounter@ ge = FoundedEncounters[i];
        if(ge.Index == 0)
            continue;
        if(ge.TurnBased && combatMode == COMBAT_MODE_REAL_TIME)
            continue;
        if(!ge.TurnBased && combatMode == COMBAT_MODE_TURN_BASED)
            continue;
        if(((ELAPSED_TIME - ge.FullSecond < FOUNDED_ENCOUNTER_LIVE_TIME) || !ge.TurnBased) && ge.IsGenerated &&
           (!valid(ge.Encounter) || (!ge.Encounter.Special && CheckChecks(ge.Encounter.Checks, group))) &&
           uint(sqrt(float(POW2(ge.PositionX - x) + POW2(ge.PositionY - y)))) <= 3*radius &&
           group[0].Id != ge.OwnerId &&
           valid(GetLocation(ge.LocationId)))
        {
            //Log("return ge");
			return ge;
        }
    }
	//Log("return null");
    return null;
}

/*
CFoundedEncounter@ GetNearFoundedEncounter(array<Critter@>@ group, uint x, uint y, uint radius)
{
    int combatMode = group[0].Mode[MODE_DEFAULT_COMBAT];
	//Log("combatMode = " + combatMode);
	//Log("x, y = " + x + ", " + y);
	//Log("radius = " + radius);

	for(uint i=0; i<FoundedEncounters.length(); i++)
	{
		CFoundedEncounter@ ge=FoundedEncounters[i];
		//Log("i= " + i);
		//Log("ge.Index= " + ge.Index);
		//Log("ge.PositionX, ge.PositionY = " + ge.PositionX + ", " + ge.PositionY);
		//Log("ge.TurnBased= " + ge.TurnBased);
		//Log("__FullSecond-ge.FullSecond= " + (__FullSecond-ge.FullSecond));
		//Log("ge.IsGenerated= " + ge.IsGenerated);
		//Log("(sqrt(float(POW2(ge.PositionX-x)+POW2(ge.PositionY-y))))= " + (sqrt(float(POW2(ge.PositionX-x)+POW2(ge.PositionY-y)))));
		//Log("group[0].Id==ge.OwnerId: " + group[0].Id + "??" + ge.OwnerId);
		//Log("ge.LocationId= " + ge.LocationId);


		if(ge.Index==0) continue; //{Log("1.."); continue;}
		if(ge.TurnBased && combatMode==COMBAT_MODE_REAL_TIME) continue; // {Log("2.."); continue;}
		if(not ge.TurnBased && combatMode==COMBAT_MODE_TURN_BASED) continue; // {Log("3.."); continue;}

		if(__FullSecond-ge.FullSecond>=FOUNDED_ENCOUNTER_LIVE_TIME) continue; // {Log("4.."); continue;}
		if(not ge.IsGenerated) continue; // {Log("5.."); continue;}
		if(valid(ge.Encounter) && ge.Encounter.Special && not CheckChecks(ge.Encounter.Checks,group)) continue; // {Log("6.."); continue;}
		if(uint(sqrt(float(POW2(ge.PositionX-x)+POW2(ge.PositionY-y))))>3*radius) continue;//  {Log("7.."); continue;}
		if(group[0].Id==ge.OwnerId) continue; // { Log("8.."); continue;}
		if(not valid(GetLocation(ge.LocationId))) continue; // {Log("9.."); continue;}

		Log("return ge");
			return ge;
	}
	Log("return null");
	return null;
}
*/

uint GetFreeDir(array<bool>& dirBusy, uint8& inout firstDirIdx)
{
    // 0 - 3; 2 - 5; 1 - 4
    uint[] dirs = { 0, 2, 1, 0, 2 };
    if(firstDirIdx == 0)
        firstDirIdx = Random(0, 2);
    for(uint i = firstDirIdx; i < firstDirIdx + 3; i++)
    {
        int dir = dirs[i];
        int opp = (dir + 3) % 6;

        if(dirBusy[dir] && !dirBusy[opp])
        {
            // return opposite
            dirBusy[opp] = true;
            return opp;
        }
        else if(!dirBusy[dir] && !dirBusy[opp])
        {
            dirBusy[dir] = true;
            return dir;
        }
    }

    // every free/occupied
    int dir = Random(0, 5);
    dirBusy[dir] = true;
    return dir;
}

void RotatePosition(uint toDir, array<uint>& positionsDirs)
{
    for(uint i = 1, j = positionsDirs.length(); i < j; i++)     // Skip Steps
    {
        positionsDirs[i] += toDir;
        if(positionsDirs[i] > 5)
            positionsDirs[i] -= 6;
    }
}

void MovePositionPoint(Map& map, uint16& pointX, uint16& pointY, array<uint>& positionDirs, uint pathIndex, uint count, uint spacing)
{
    uint steps = positionDirs[0];
    uint pathLen = (positionDirs.length() - 1) / 2;
    count *= steps;
    count %= pathLen;
    // uint16 hx=pointX,hy=pointY;

    if(steps > 1)
    {
        for(uint i = 0; i < spacing; i++)
        {
            for(uint j = 0; j < steps; j++)
            {
                uint dir = positionDirs[1 + pathLen * pathIndex + count + j];
                map.MoveHexByDir(pointX, pointY, dir, 1);
            }
        }
    }
    else
    {
        uint dir = positionDirs[1 + pathLen * pathIndex + count];
        map.MoveHexByDir(pointX, pointY, dir, spacing);
    }
    // map.GetHexCoord(hx,hy,pointX,pointY,0.0f,0); // Check for barrier
}

void ParseEncounterObject(CEncounterObject@ obj, Map@ map, uint16 posX, uint16 posY, uint8 reversDir, array<Critter@>& crittersGrouop, uint teamId, uint level)
{
    Critter@ npc;
    if(obj.ObjectType == ENCOUNTER_OBJECT_CRITTER)
    {
        // if(not map.IsHexPassed(posX,posY)) return;

        uint aiPack = 0;       // Default

        if(obj.TeamId != 0)
            teamId = obj.TeamId;

        // team id here is in its deprecated version
        array<int> params;
        if(obj.Armor != -1)
        {
            params.insertLast(ST_DEFAULT_ARMOR_PID);
            params.insertLast(obj.Armor);
            params.insertLast(ST_OVERRIDE_CRTYPE);
            params.insertLast(obj.OverrideCrtype);
        }

        if(obj.Helmet != -1)
        {
            params.insertLast(ST_DEFAULT_HELMET_PID);
            params.insertLast(obj.Helmet);
        }

        if(teamId < 200)
            @npc = AddNpc(map, obj.Pid, posX, posY, reversDir, params, obj.Dialog, obj.Script, aiPack, obj.Bag, teamId + (TEAM_Mob0 - TEAM_Mob0_Worldmap), false /*isMob*/, level);
        else
            @npc = AddNpc(map, obj.Pid, posX, posY, reversDir, params, obj.Dialog, obj.Script, aiPack, obj.Bag, teamId / 100, (teamId / 10) % 10, teamId % 10, false /*isMob*/, level);

        if(!valid(npc))
            return;

        // auto-delete this npc after some time
        SetDeleteEvent(npc, REAL_MINUTE(10));

        // modes
        obj.SetModes(npc);
        _CritSetExtMode(npc, MODE_EXT_NO_DETERIORATION);

        npc.StatBase[ST_NPC_ROLE] = obj.NpcRole;
        npc.ChangeCrType(npc.StatBase[ST_BASE_CRTYPE]);
        npc.StatBase[ST_REPLICATION_TIME] = REPLICATION_DELETE;
        IZone@ zone = GetZone(npc.WorldX, npc.WorldY);

        // handle armours first
        Item@ armor = npc.GetItem(0, SLOT_ARMOR);
        if(valid(armor) && armor.IsDeteriorable() && !armor.IsStackable())
        {
            //SetMinWear(armor, Random(MAX(0, (MAX_BROKENS - 60) - (7 * npc.Stat[ST_LEVEL]) / 3), (MAX_BROKENS - 40)));
            //// add some deterioration: 50-90%
            //int toWear = Random(armor.BrokenCount, 90);
            //toWear -= npc.Stat[ST_LEVEL] * 2 / 3;
            //SetWear(armor, toWear);

            uint wear = Random(5, 10);
            SetMinWear(armor, wear);
            SetWear(armor, wear+Random(0, 20));
        }

        @armor = npc.GetItem(0, SLOT_HEAD);
        if(valid(armor) && armor.IsDeteriorable() && !armor.IsStackable())
        {
            //SetMinWear(armor, Random(MAX(0, (MAX_BROKENS - 60) - (7 * npc.Stat[ST_LEVEL]) / 3), (MAX_BROKENS - 40)));
            //// add some deterioration: 50-90%
            //int toWear = Random(armor.BrokenCount, 90);
            //toWear -= npc.Stat[ST_LEVEL] * 2 / 3;
            //SetWear(armor, toWear);

            uint wear = Random(5, 10);
            SetMinWear(armor, wear);
            SetWear(armor, wear+Random(0, 20));
        }

        if(obj.Childs.length() > 0)
        {
            for(uint i = 0, j = obj.Childs.length(); i < j; i++)
            {
                CEncounterObject@ child = obj.Childs[i];
                uint              count = Random(child.Minimum, child.Maximum);
                if(count > 0)
                {
                    Item@ item = npc.AddItem(child.Pid, count);
                    if(item.IsStackable())
                    {
                        item.SetCount((item.GetCount() * (100 + 6 * npc.Stat[ST_LEVEL])) / 100);
                    }
                    // if they have something(presumably weapon) in hand, set it as favorite so they will keep holding it
                    if(child.Slot == SLOT_HAND1 || child.Slot == SLOT_HAND2)
                        npc.SetFavoriteItem(child.Slot, child.Pid);
                    if(valid(item) && child.Slot != SLOT_INV &&
                       (item.GetType() != ITEM_TYPE_WEAPON || npc.IsAnim1(item.Proto.Weapon_Anim1)))
                    {
                        if(child.Slot == 4)
                        {
                            Log("bad item! " + child.Pid + ", npc pid " + npc.GetProtoId());
                        }
                        npc.MoveItem(item.Id, item.GetCount(), child.Slot);
                    }

                    // make it crappy
                    if(valid(item))
                        if(item.IsDeteriorable() && !item.IsStackable())
                        {
                            // set the number of breakages
                            //SetMinWear(item, Random(MAX(0, child.BrokenMin - (7 * npc.Stat[ST_LEVEL]) / 3), child.BrokenMax));
                            //// add some deterioration: 50-90%
                            //int toWear = Random(item.BrokenCount, 90);
                            //toWear -= npc.Stat[ST_LEVEL] * 2 / 3;
                            //SetWear(item, toWear);
                            uint wear = Random(5, 15);
                            SetMinWear(item, wear);
                            SetWear(item, wear+Random(5, 25));
                        }

                    // one must be careful with that, that's why we forbid adding more than 1 IsWeared() item at a time (it's bad for other reasons too)
                    // zone.SubValue(BaseItemValue(item) * ( item.IsStackable() ? 1 : count));
                    item.Update();
                }
            }
            // reduce value
        }

        if(IsHumanoid(npc))
        {
            if(Random(0, 100) < 10)
                npc.AddItem(PID_BOTTLE_CAPS, Random(1, 50));

            if(Random(0, 100) < 20)
                npc.AddItem(random_from_array(npcExtraItems), 1);
        }

        if(obj.Perks.length > 0)
        {
            for(uint i = 0; i < obj.Perks.length; i++)
            {
                if(obj.Perks[i].chance > uint(Random(0, 99)))
                    npc.PerkBase[obj.Perks[i].index] = obj.Perks[i].level;
            }
        }

        if(obj.Dead)
        {
            npc.ToDead(Random(0, 1) == 0 ? ANIM2_DEAD_FRONT : ANIM2_DEAD_BACK, null);
        }
        else
        {
            uint len = crittersGrouop.length();
            crittersGrouop.resize(len + 1);
            @crittersGrouop[len] = npc;
        }
    }
    else if(obj.ObjectType == ENCOUNTER_OBJECT_ITEM)
    {
        Item@ item = map.AddItem(posX, posY, obj.Pid, 1);
        if(!valid(item))
            return;

        if(obj.Childs.length() > 0 && item.GetType() == ITEM_TYPE_CONTAINER)
        {
            for(uint i = 0, j = obj.Childs.length(); i < j; i++)
            {
                CEncounterObject@ child = obj.Childs[i];
                uint              count = Random(child.Minimum, child.Maximum);
                if(count > 0)
                    item.AddItem(child.Pid, count, 0);
            }
        }
    }
    else
    {
        Log("Unknown object type<" + obj.ObjectType + ">.");
    }

    // Find unusable weapons
    if(valid(npc))
    {
        array<Item@> items;
        uint         num = npc.GetItems(-1, items);

        for(uint i = 0; i < num; i++)
        {
            if(items[i].GetType() == ITEM_TYPE_WEAPON && !CanUseWeapon(npc, items[i]) && (items[i].GetProtoId() != PID_OLD_SHOVEL))
                Log("WARNING: Critter created with pid " + npc.GetProtoId() + " on loc pid " + map.GetLocation().GetProtoId() + " that can't use weapon with PID " + items[i].GetProtoId());
        }
    }
}

/*
 */
void ActionFighting(array<Critter@>& npcL, array<Critter@>& npcR)
{
    for(int i = 0, j = npcL.length(); i < j; i++)
    {
        Critter@ nl = npcL[i];
        if(!valid(nl))
        {
            Log("AF: Invalid critter in L group: " + i);
            continue;
        }
        bool nlIsNpc = nl.IsNpc();
        for(int k = 0, l = npcR.length(); k < l; k++)
        {
            Critter@ nr = npcR[k];
            if(!valid(nr))
            {
                Log("AF: Invalid critter in R group: " + k);
                continue;
            }
            uint pr = AI_PLANE_ATTACK_PRIORITY;
            // todo: reputation prorities?
            if(nlIsNpc)
            {
                // AddAttackPlane(nl, nr.IsPlayer() ? Random(pr, pr+20) : Random(pr, pr+10), nr);
                AddAttackPlane(nl, Random(pr, pr + 20), nr);
                nl.AddEnemyInStack(nr.Id);
                nl.Wait(Random(5000, 7000));
            }
            if(nr.IsNpc())
            {
                // AddAttackPlane(nr, nl.IsPlayer() ? Random(pr, pr+20) : Random(pr, pr+10), nl);
                AddAttackPlane(nr, Random(pr, pr + 20), nl);
                nr.AddEnemyInStack(nl.Id);
                nr.Wait(Random(5000, 7000));
            }
        }
    }
}
/*
 */
Map@ GenerateEncounter(CFoundedEncounter@ fe, array<Critter@>@ critters)
{
    uint        start = GetTick();
    bool        specialencounter = true;

    CEncounter@ encounter = fe.Encounter;

    uint16      locPid = (valid(encounter) ? encounter.LocationPid : 0);
    if(fe.Zone.LocationPids.length() == 0)
    {
        Log("No location Pids defined for zone " + fe.Zone.x + ", " + fe.Zone.y + ".");
        return null;
    }

    if(locPid == 0)
        locPid = random_from_array(fe.Zone.LocationPids);
    if(fe.PositionX < 1)
        fe.PositionX = 1;
    if(fe.PositionY < 1)
        fe.PositionY = 1;

    fe.LocationId = CreateLocation(locPid, fe.PositionX, fe.PositionY, null);

    if(fe.LocationId == 0)
    {
        Log("CreateLocation fail, location pid<" + locPid + ">.");
        return null;
    }

    Location@ location = GetLocation(fe.LocationId);
    if(!valid(location))
    {
        Log("GetLocation fail.");
        return null;
    }

    // apply weather before adding any critter
    //WeatherUpdateFast(location);

    location.Color = COLOR_RGBA(0xFF, 0xA0, 0x40, 80);
    Map@ map = location.GetMapByIndex(0);
    if(!valid(map))
    {
        Log("GetMapByIndex fail.");
        return null;
    }
    // remember when created
    map.SetData(MAP_DATA_CREATED_ON, ELAPSED_TIME);

    uint16 startX = 0, startY = 0;
    if(!map.GetEntireCoords(0, 0, startX, startY))
    {
        Log("Default entire not found.");
        return null;
    }
    fe.StartHexX = startX;
    fe.StartHexY = startY;


    Critter@ leader = critters[0];
    uint     playerscount = 0;
	int max_level_gracza=0;
	int min_level_gracza=9999;
    for(uint i = 0, j = critters.length(); i < j; i++)
	{
        if(critters[i].IsPlayer())
		{
            playerscount++;
			if(max_level_gracza < critters[i].Stat[ST_LEVEL])
				max_level_gracza=critters[i].Stat[ST_LEVEL];

			if(min_level_gracza > critters[i].Stat[ST_LEVEL])
				min_level_gracza=critters[i].Stat[ST_LEVEL];
		}
	}

    Critter@ guide = GetMostSkilled(critters, SK_OUTDOORSMAN);

    if(!valid(encounter) || fe.Encounter.Special)       // Empty map or special
    {
        bool special = valid(encounter) && fe.Encounter.Special;
        fe.IsGenerated = true;
        return map;
    }


    // add player group
    fe.Encounter.AddPlayer(leader);
    DPlayerLog(leader, "Ratio: " + encounter.Ratio + ", diff: " + encounter.Difficulty);
    array<array<Critter@> > crittersGroups(encounter.Groups.length());

    ///////////////////////////////////////////////////////////
	// 07-02-2014 Cubik: wyszukiwanie nowych grup enco o indeksie >=135
	bool isNewEnco = false;
	for(uint i = 0, j = encounter.Groups.length(); i < j; i++)
    {
        uint groupNum = encounter.Groups[i];

		if(groupNum >= 135 && groupNum<145) isNewEnco = true;
		//Log("groupNum = " + groupNum);
		//Log("isNewEnco [" + i + "] = " + isNewEnco);
	}
	//Log("isNewEnco = " + isNewEnco);
	///////////////////////////////////////////////////

	for(uint i = 0, j = encounter.Groups.length(); i < j; i++)
    {
        uint groupNum = encounter.Groups[i];

        if(groupNum >= GROUP_MAX)
        {
            array<Critter@>@ crGroup = crittersGroups[i];
            crGroup.resize(critters.length());
            for(uint k = 0, l = critters.length(); k < l; k++)
                @crGroup[k] = critters[k];
            continue;
        }

        CEncounterGroup@ group = EncounterGroups[groupNum];
        uint             distance = Random(group.DistMin, group.DistMax);

        // if(distance==0) distance=7+leader.Stat[ST_PERCEPTION]+leader.Perk[PE_CAUTIOUS_NATURE]*3;

        uint teamId = group.TeamNum;
        if(teamId == TEAM_Mob)
            teamId = TEAM_Mob0_Worldmap + i;
        else if(teamId == TEAM_Neutral)
            teamId = TEAM_Neutral0_Worldmap + i;

        uint position = group.Position;
        uint spacing = group.Spacing;
        if(position == POSITION_SURROUNDING)
            spacing = leader.Stat[ST_PERCEPTION] + leader.Perk[PE_CAUTIOUS_NATURE] * 3;

        array<uint> positionDirs = PositionDirs[position];
        uint        steps = positionDirs[0];
        uint        dirsCount = 0;

        uint        freeDir = GetFreeDir(fe.DirBusy, fe.FirstDirIdx);
        if(freeDir != 0)
            RotatePosition(freeDir, positionDirs);
        uint reversDir = freeDir + 3;
        if(reversDir > 5)
            reversDir -= 6;

        // Get start point for group
        uint16[] pointX = { startX, startY };
        uint16[] pointY = { startX, startY };
        if(position != POSITION_NONE)
        {
            uint16 hx = pointX[0], hy = pointY[0];
            map.MoveHexByDir(pointX[0], pointY[0], freeDir, position != POSITION_SURROUNDING ? distance : spacing);
            map.GetHexCoord(hx, hy, pointX[0], pointY[0], 0.0f, 0);        // Check for barrier
            pointX[1] = pointX[0];
            pointY[1] = pointY[0];
            MovePositionPoint(map, pointX[1], pointY[1], positionDirs, 1, 0, spacing);
        }
		// ToDo:
		// skalowanie liczby critterow w enco od lvl gracza???
		//
        uint totalratio = 0;         // sum of all ratios, to make them normalised
		uint limited_ratio = 30;     // ograniczenie liczby NPC w enco nowym dla zakrsu lvl 12-17; 100 - brak ograniczenia, 0- calkowite ograniczenie
        for(uint k = 0, l = group.Objects.length(); k < l; k++)
		{
			//if((min_level_gracza>=12 && max_level_gracza<18) && (groupNum>=135 && groupNum<GROUP_MAX) && (group.Objects[k].Ratio>0 && group.Objects[k].Ratio<100))
			if((min_level_gracza>=9 && max_level_gracza<18) && (groupNum>=135 && groupNum<145))
			{
				totalratio += limited_ratio*group.Objects[k].Ratio/100;  // suma Ratio wszystkich critterow w obrebie grupy enco
				//if(group.Objects[k].Ratio == 0)
				//	totalratio += 100*100/100;  // suma Ratio wszystkich critterow w obrebie grupy enco
			}
			else
            totalratio += group.Objects[k].Ratio;  // suma Ratio wszystkich critterow w obrebie grupy enco
		}
        bool force = true;
		uint total_count = 0; // suma ilosci critterow w danej grupie, jesli bedzie = 0 to ustawiona na min 1

        for(uint k = 0, l = group.Objects.length(); k < l; k++)
        {
            CEncounterObject@ obj = group.Objects[k];

            if(!CheckChecks(obj.Checks, critters))
                continue;

            uint otherDistance = obj.Distance;

            uint ncount = 0;
            uint count = 0;
            /*
			if(obj.Ratio > 0)
            {
                for(uint rc = 0; rc < encounter.Ratio; rc++)
                    count += Random(group.RatioMin, group.RatioMax);

                for(uint n = 0; n < count; n++)
                    // ratio roll instead of obj.Ratio*ratio/100
                    if(Random(1, totalratio) <= int(obj.Ratio))
                        ncount++;
            }
            else
                ncount = 1;
			*/
			int roll=0;
			if((min_level_gracza>=9 && max_level_gracza<18) && (groupNum>=135 && groupNum<145)) // zmniejszenie liczebnosci grupy enco >=135 ze wzgledu na lvl 12-18
			{
				//Log("Oraniczona liczba NPC w Nowym Enco, GROUP ID: "  + groupNum);

				if(obj.Ratio > 0)
				{
					force = false;
					for(uint rc = 0; rc < encounter.Ratio; rc++)
						count += Random(group.RatioMin, group.RatioMax);

					for(uint n = 0; n < count; n++)
					{
						// ratio roll instead of obj.Ratio*ratio/100
						roll=Random(1, totalratio);
						//if(Random(1, totalratio) <= int(limited_ratio*obj.Ratio/100))
						if(roll <= int(limited_ratio*obj.Ratio/100))
							ncount++;
						//Log("roll/limited_Ratio= " + roll + "/" + int(limited_ratio*obj.Ratio/100));
					}
				}
				else
				{
					//ncount = 1;

					force = false;
					for(uint rc = 0; rc < encounter.Ratio; rc++)
						count += Random(group.RatioMin, group.RatioMax);

					for(uint n = 0; n < count; n++)
					{
						// ratio roll instead of obj.Ratio*ratio/100
						roll=Random(1, totalratio);
						//if(Random(1, totalratio) <= int(limited_ratio*obj.Ratio/100))
						if(roll <= int(limited_ratio*100/100))
							ncount++;
						//Log("roll/limited_Ratio= " + roll + "/" + int(limited_ratio*100/100));
					}
				}

				total_count = total_count + ncount;
				//Log("A) total_count = " + total_count);
				if(k==l-1 && total_count<=1)
				{
					total_count = Random(2,3);
					ncount = total_count;
				}

				if(total_count>5)
				{
					//total_count = 5;
					//ncount = total_count;
					//Log("BBBBB) total_count = " + total_count);
					continue;
				}

				//Log("B) total_count = " + total_count);
			}
			else  //  bez limitu lvl gracza i dla kazdej grupy enco rowniez >=135
			{
				//Log("Normalna liczba NPC w enco, GROUP ID: "  + groupNum);
				if(obj.Ratio > 0)
				{
					for(uint rc = 0; rc < encounter.Ratio; rc++)
						count += Random(group.RatioMin, group.RatioMax);

					//for(uint n = 0; n < count; n++)
					//	// ratio roll instead of obj.Ratio*ratio/100
					//	if(Random(1, totalratio) <= int(obj.Ratio))
					//		ncount++;
					for(uint n = 0; n < count; n++)
					{
						// ratio roll instead of obj.Ratio*ratio/100
						roll=Random(1, totalratio);
						//if(Random(1, totalratio) <= int(50*obj.Ratio/100))
						if(roll <= int(100*obj.Ratio/100))
							ncount++;
						//Log("roll/limited_Ratio= " + roll + "/" + int(100*obj.Ratio/100));
					}
				}
				else
					ncount = 1;
			}

            if(force && ncount == 0)
            {
                force = false;
                ncount = 1;
            }



			//Log("Group: " + groupNum + " - Critter nr (" + k + ") * " + ncount);
            DPlayerLog(leader, "Object(" + k + ") * " + ncount);
            uint16 oldPosX = startX, oldPosY = startY;
            for(uint n = 0; n < ncount; n++)
            {
                uint16 posX, posY;
                if(otherDistance > 0 || position == POSITION_NONE)
                {
                    posX = startX + Random(-5, 5);
                    posY = startY + Random(-5, 5);
                    map.MoveHexByDir(posX, posY, freeDir, otherDistance > 0 ? otherDistance : distance);
                }
                else
                {
                    uint pathIndex = dirsCount % 2;
                    posX = pointX[pathIndex] + (position == POSITION_SURROUNDING ? Random(-3, 0) : 0);
                    posY = pointY[pathIndex] + (position == POSITION_SURROUNDING ? Random(-3, 0) : 0);
                    MovePositionPoint(map, pointX[pathIndex], pointY[pathIndex], positionDirs, pathIndex, dirsCount / 2 + pathIndex, spacing);
                    dirsCount++;
                }

                map.GetHexCoord(oldPosX, oldPosY, posX, posY, 0.0f, 0);            // Check for barrier
                oldPosX = posX;
                oldPosY = posY;

                //int level = 1 + (encounter.Difficulty / 5);
				int level = 1 + (encounter.Difficulty / 6); // 24-07-2013 Cubik: zmniejszenie wyliczanego level crittera od difficulty co za tym idzie mneijsze naliczanie dodatkowej ilosci HP mobom na encounterach od levela(parameters.fos: NpcProcessLevel)
                ParseEncounterObject(obj, map, posX, posY, reversDir, crittersGroups[i], teamId, level);
            }
        }
    }

    fe.PrepareActions();

    uint idx_npc = 0;
    for(uint i = 0; i < crittersGroups.length(); ++i)
    {
        if(fe.Encounter.Groups[i] < GROUP_MAX && crittersGroups[i].length() > 2)
        {
            idx_npc = Random(0, 20);
            if(idx_npc < crittersGroups[i].length())
                MakeEncounterBoss(crittersGroups[i][idx_npc].Id, fe.Encounter.Groups[i]);
        }
    }

    DLog("Parsing " + (fe.Actions.length() / 3) + " actions.");

    if(fe.Actions.length() % 3 == 0)
    {
        for(uint i = 0, j = fe.Actions.length(); i < j; i += 3)
        {
            uint fromGroup = fe.Actions[i];
            uint toGroup = fe.Actions[i + 1];
            uint action = fe.Actions[i + 2];
            DPlayerLog(leader, "Action " + i + ": " + fromGroup + "->" + toGroup + "=" + action);
            if(fromGroup < crittersGroups.length() && toGroup < crittersGroups.length())
            {
                if(action == ACTION_FIGHTING)
                    ActionFighting(crittersGroups[fromGroup], crittersGroups[toGroup]);
            }
            else
                Log("GE: Incorrect critter group: " + fromGroup + "->" + toGroup + " / " + crittersGroups.length());
        }
    }
    else
        Log("GE: Improper actions length");

    fe.IsGenerated = true;
    string groups;
    for(int i = 0, j = crittersGroups.length(); i < j; i++)
    {
        if(fe.Encounter.Groups[i] >= GROUP_MAX)
            continue;                                             // don't log players groups
        groups += fe.Encounter.Groups[i];
        if(i + 1 < j && fe.Encounter.Groups[i + 1] < GROUP_MAX)
            groups += ",";
    }

    uint t = GetTick() - start;
    _AdminLog(leader, "Generated encounter in " + t + "ms.");
    AddEncounterContainers(map, critters);
    return map;
}

void GuideReward(Critter@ leader, Critter@ guide, int amount)
{
    guide.StatBase[ST_EXPERIENCE] += amount;
    if(leader.Id != guide.Id)
        guide.Say(SAY_NETMSG, "You've warned leader about encounter.");
}

void OnSpecialEncounterCreated(Location@ loc, array<Critter@>& group, Item@ car, uint encounterDescriptor)
{
    Critter@    leader = group[0];

    FLog(LOG_SPECIAL_ENC, "Special encounter location: " + loc.GetProtoId() +  " player: [" + leader.Id + "] " + leader.Name);

    array<Map@> maps;
    for(uint i = 0, j = loc.GetMaps(maps); i < j; i++)
        maps[i].SetData(MAP_DATA_OWNER, leader.Id);

    if(loc.GetProtoId() == LOCATION_Battleground)
    {
        SetLvar(leader, LVAR_se_bosbattleground, loc.Id);
        SetQuestGarbager(0, leader.Id, loc.Id, LVAR_se_bosbattleground, 0);
    }
    else if(loc.GetProtoId() == LOCATION_CrashedHummer)
    {
        SetLvar(leader, LVAR_se_boscrashedhummer, loc.Id);
        SetQuestGarbager(0, leader.Id, loc.Id, LVAR_se_boscrashedhummer, 0);
    }
}

#define _CheckSpecialEncounter    # (__loc, __condition, __result) if(__condition) { __result; return __loc; }
int CheckSpecialEncounter(Critter@ leader, CZone@ zone)
{
    #ifdef __DEBUG__
    // _CheckSpecialEncounter(LOCATION_SpecialEncounter_SecretBunker, (ZoneContainsFlag(zone, FLAG_SecretShelter)), SetLvar(leader, LVAR_q_secret_vault, 1));
    // _CheckSpecialEncounter(LOCATION_SpecialEncounter_SecretTreasure, (ZoneContainsFlag(zone, FLAG_SecretTreasure1)), SetLvar(leader, LVAR_q_secret_treasure1, 1));
    // _CheckSpecialEncounter(LOCATION_SpecialEncounter_Howitzer, (ZoneContainsFlag(zone, FLAG_SecretHowitzer)), SetLvar(leader, LVAR_q_secret_howitzer, 1));
    // _CheckSpecialEncounter(LOCATION_SpecialEncounter_OldWarehouse, (zone.Terrain==TERRAIN_City || zone.Terrain==TERRAIN_Citycoast || zone.Terrain==TERRAIN_Citybig), SetLvar(leader, LVAR_q_secret_warehouse, 1));
    // _CheckSpecialEncounter(LOCATION_SpecialEncounter_BusStop, (zone.Terrain==TERRAIN_Desert), SetLvar(leader, LVAR_q_secret_bus_stop, ELAPSED_TIME+REAL_HOUR(10))); // 1 roll in 10h

    // This is a quest based encounter.
    //_CheckSpecialEncounter(LOCATION_Ambush, (ZoneContainsFlag(zone, FLAG_CaesarAmbush) && (GetLvar(leader, LVAR_q_la_train_caesar_ambush) == 1) && (leader.Skill[SK_OUTDOORSMAN] < Random(75, 299))), SetLvar(leader, LVAR_q_la_train_caesar_ambush, 2));
    //_CheckSpecialEncounter(LOCATION_CrashedHummer, (ZoneContainsFlag(zone, FLAG_CrashedHummer)), SetLvar(leader, LVAR_se_boscrashedhummer, 1));
    //_CheckSpecialEncounter(LOCATION_Battleground, (ZoneContainsFlag(zone, FLAG_BattleGround)), SetLvar(leader, LVAR_se_bosbattleground, 1));
    #endif

    #ifndef __DEBUG__
    // Not quest related

    // 1 roll in 10h
    _CheckSpecialEncounter(LOCATION_SpecialEncounter_SecretBunker, (zone.Terrain == TERRAIN_Desert && (uint(GetLvar(leader, LVAR_q_secret_vault)) <= ELAPSED_TIME) && (Random(1, 1) == 1 && leader.Stat[ST_LEVEL] > Random(0, 23))), SetLvar(leader, LVAR_q_secret_vault, ELAPSED_TIME + REAL_HOUR(1)));
	//_CheckSpecialEncounter(LOCATION_SpecialEncounter_SecretBunker, (zone.Terrain == TERRAIN_Desert), SetLvar(leader, LVAR_q_secret_vault, ELAPSED_TIME + REAL_HOUR(10)));  // TEST

    // 1 roll in 10h
    _CheckSpecialEncounter(LOCATION_SpecialEncounter_SecretTreasure, (zone.Terrain == TERRAIN_Mountain && (uint(GetLvar(leader, LVAR_q_secret_treasure1)) <= ELAPSED_TIME) && (Random(1, 1) == 1 && leader.Stat[ST_LEVEL] > Random(0, 5))), SetLvar(leader, LVAR_q_secret_treasure1, ELAPSED_TIME + REAL_HOUR(1)));

    // 1 roll in 10h
    _CheckSpecialEncounter(LOCATION_SpecialEncounter_Howitzer, (zone.Terrain == TERRAIN_Desert && (uint(GetLvar(leader, LVAR_q_secret_howitzer)) <= ELAPSED_TIME) && (Random(1, 1) == 1 && leader.Stat[ST_LEVEL] > Random(4, 23))), SetLvar(leader, LVAR_q_secret_howitzer, ELAPSED_TIME + REAL_HOUR(1)));

    // 1 roll in 10h for characters with level > 9
    _CheckSpecialEncounter(LOCATION_SpecialEncounter_OldWarehouse, ((zone.Terrain == TERRAIN_City || zone.Terrain == TERRAIN_Citycoast || zone.Terrain == TERRAIN_Citybig) && (uint(GetLvar(leader, LVAR_q_secret_warehouse)) <= ELAPSED_TIME) && (Random(1, 1800) == 1 && leader.Stat[ST_LEVEL] > Random(14, 49))), SetLvar(leader, LVAR_q_secret_warehouse, ELAPSED_TIME + REAL_HOUR(1)));

    // 1 roll in 10h for characters with level > 9
    _CheckSpecialEncounter(LOCATION_SpecialEncounter_OldFactory, ((zone.Terrain == TERRAIN_City || zone.Terrain == TERRAIN_Citycoast || zone.Terrain == TERRAIN_Citybig) && (uint(GetLvar(leader, LVAR_q_secret_factory)) <= ELAPSED_TIME) && (Random(1, 1) == 1 && leader.Stat[ST_LEVEL] > Random(5, 14))), SetLvar(leader, LVAR_q_secret_factory, ELAPSED_TIME + REAL_HOUR(1)));

    // 1 roll in 10h for characters with level > 9
    _CheckSpecialEncounter(LOCATION_SpecialEncounter_Hospital, ((zone.Terrain == TERRAIN_City || zone.Terrain == TERRAIN_Citycoast || zone.Terrain == TERRAIN_Citybig) && (uint(GetLvar(leader, LVAR_q_secret_hospital)) <= ELAPSED_TIME) && (Random(1, 1) == 1 && leader.Stat[ST_LEVEL] > Random(5, 14))), SetLvar(leader, LVAR_q_secret_hospital, ELAPSED_TIME + REAL_HOUR(1)));

    // 1 roll in 10h
    _CheckSpecialEncounter(LOCATION_SpecialEncounter_BusStop, (zone.Terrain == TERRAIN_Desert && (uint(GetLvar(leader, LVAR_q_secret_bus_stop)) <= ELAPSED_TIME) && (Random(1, 1) == 1 && leader.Stat[ST_LEVEL] > Random(2, 5))), SetLvar(leader, LVAR_q_secret_bus_stop, ELAPSED_TIME + REAL_HOUR(1)));

    // Sha-Enin //
    // Attacked by bandits
    // _CheckSpecialEncounter(LOCATION_ShaEnin,		(ZoneContainsFlag(zone, FLAG_ShaEnin) && (GetLvar(leader, LVAR_q_enc_rovering_trader)==1)) );
    // Trading
    // _CheckSpecialEncounter(LOCATION_ShaEnin2,		(ZoneContainsFlag(zone, FLAG_ShaEnin) && (GetLvar(leader, LVAR_q_enc_rovering_trader)==2)) );


    // Quests
    /*&& ZoneContainsFlag(zone, FLAG_Q_Ruined_Militarybase)*/
/*TEST*/	//_CheckSpecialEncounter(LOCATION_SpecialEncounter_DeadBody, ((zone.Terrain == TERRAIN_Desert || zone.Terrain == TERRAIN_Mountain) && ((GetLvar(leader, LVAR_q_mb_location_known)==0) && (uint(GetLvar(leader, LVAR_q_mb)) <= ELAPSED_TIME) && Random(1, 1) == 1 && (leader.Stat[ST_LEVEL] > Random(1, 1)) && (leader.Skill[SK_OUTDOORSMAN]< Random(25,299)))), SetLvar(leader, LVAR_q_mb, ELAPSED_TIME + REAL_HOUR(0)));

	_CheckSpecialEncounter(LOCATION_SpecialEncounter_DeadBody, ((zone.Terrain == TERRAIN_Desert || zone.Terrain == TERRAIN_Mountain) && ((GetLvar(leader, LVAR_q_mb_location_known)==0) && (uint(GetLvar(leader, LVAR_q_mb)) <= ELAPSED_TIME) && Random(1, 1) == 1 && (leader.Stat[ST_LEVEL] > Random(23, 23)) && (leader.Skill[SK_OUTDOORSMAN]> Random(24,299)))), SetLvar(leader, LVAR_q_mb, ELAPSED_TIME + REAL_HOUR(1)));

	_CheckSpecialEncounter(LOCATION_Ambush, (ZoneContainsFlag(zone, FLAG_CaesarAmbush) && (GetLvar(leader, LVAR_q_la_train_caesar_ambush) == 1) && (leader.Skill[SK_OUTDOORSMAN] < Random(75, 299))), SetLvar(leader, LVAR_q_la_train_caesar_ambush, 2));

    _CheckSpecialEncounter(LOCATION_Battleground, (ZoneContainsFlag(zone, FLAG_BattleGround) && (GetLvar(leader, LVAR_se_bosbattleground) == 0) && (GetLvar(leader, LVAR_q_bos_initiate_start) == 21) && Random(0, 1) == 0), false);

    _CheckSpecialEncounter(LOCATION_CrashedHummer, (ZoneContainsFlag(zone, FLAG_CrashedHummer) && (GetLvar(leader, LVAR_se_boscrashedhummer) == 0) && (GetLvar(leader, LVAR_q_bos_initiate_start) == 21) && Random(0, 8) == 0), false);

    #endif

    return 0;
}



void FindEncounter(array<Critter@>& group, Item@ car, uint x, uint y, uint& encounterDescriptor, bool& waitForAnswer, bool empty)
{
    //if(group[0].IsPlayer()) Log("FindEncounter: START.");
	DPlayerLog(group[0], "FindEncounter tick");
    uint start = GetTick();
    encounterDescriptor = 0;
    waitForAnswer = false;

    uint zx = x / ZONE_LENGTH;
    uint zy = y / ZONE_LENGTH;
    if(zx >= ZONE_COUNT_X || zy >= ZONE_COUNT_Y)
    {
        // Log("Invalid zones coordinates."); in faction mod size is greather than ZONE_COUNT_X, ZONE_COUNT_Y.
        return;
    }
    DLog("Going through: " + zx + ", " + zy);
    CZone@ zone = Worldmap[zy * ZONE_COUNT_X + zx];

    if(!valid(zone))
    {
        Log("ERR: Zone: " + zx + ", " + zy + " not valid.");
        return;
    }
    Critter@         leader = group[0];
    Critter@         guide = GetMostSkilled(group, SK_OUTDOORSMAN);

    uint             seLocPid = CheckSpecialEncounter(leader, zone);

    array<Location@> locations;
    uint             locCount = GetVisibleLocations(x, y, 0, leader, locations);

    // find closest free spot
    if(locCount != 0)
    {
        uint rad = 0;
        uint maxInd = 0;
        for(uint i = 0; i < locCount; i++)
        {
            if(locations[i].Radius > rad)
            {
                rad = locations[i].Radius;
                maxInd = i;
            }
        }
        int newX = locations[maxInd].WorldX;
        int newY = locations[maxInd].WorldY;

        if(newX == int(x) && newY == int(y))
            x += 1;
        rad += 2;

        float dist = sqrt((newX - int(x)) * (newX - int(x)) + (newY - int(y)) * (newY - int(y)));
        x = uint(newX + float(int(x) - newX) * (rad / dist));
        y = uint(newY + float(int(y) - newY) * (rad / dist));
    }

    if(!empty && seLocPid > 0 && int(zone.GetChance())>0) //Cubik 30.03.2014 : poprawka wylaczajaca pojawianie sie SE w kratkach z zielonymi kropami (kratki te nie zawieraja zјadncyh enco i GetChance=0 w nich)
    {
        CEncounter@ enc = CEncounter();
        enc.LocationPid = seLocPid;
        enc.Special = true;
        CFoundedEncounter@ fe = CreateFoundedEncounter(x, y, @enc, zone, leader.Id, group.length() > 1);
        if(!valid(fe))
            return;
        waitForAnswer = false;
        encounterDescriptor = fe.Index;
        return;
    }

    bool giveReward = false; // reward for averting encounter
    bool caravan = false;
	bool playerCaravan = valid(car) && _IsCaravanCar(car.GetProtoId());

    // Check chance
    DPlayerLog(leader, "Zone' chance: " + zone.GetChance());

    int roll = Random(1, 100);
	for(uint i = 0, j = group.length(); i < j; i++)
	{
		_AdminLog(group[i], "Zone [" + zx + "," + zy + "] chance/roll: " + zone.GetChance() + " / " + roll);
	}

    if((playerCaravan && int(zone.GetChance())>0) || ((roll <= 5 || roll <= int(zone.GetChance()) / (empty ? 2 : 1)) && roll < 95))        // smaller chance with force-entering
	//if((roll <= 5 || roll <= int(4*zone.GetChance()) / (empty ? 2 : 1)) && roll < 95)        // smaller chance with force-entering // TYLKO DO TESTOW!!!!!!!!!!!!!!!!!!!!!!
    {
        // Try find already founded encounter
        //Log("Try find already founded encounter... " + zone.GetChance());
        CFoundedEncounter@ feAlready = GetNearFoundedEncounter(group, x, y, ZONE_LENGTH / 2);

        //Log("valid(feAlready): " + valid(feAlready));
        if(valid(feAlready) && !playerCaravan && !(caravan && feAlready.TurnBased))
        {
            //Log("valid(feAlready): in");

            /* REMOVED NOOB PROTECTION
            Critter@ owner_player = GetCritter(feAlready.OwnerId);
            int owner_level =  1;
            if(valid(owner_player))
                owner_level = owner_player.Stat[ST_LEVEL];

            int noob_protection_chance = 100-10*owner_level;
            noob_protection_chance=CLAMP(noob_protection_chance, 0, 100);
            if (noob_protection_chance<Random(1,100))
            */
            //if(
            //  (owner_player.IsPlayer() && owner_player.Stat[ST_LEVEL]>NOOB_FRIENDLY_LEVEL && leader.Stat[ST_LEVEL] > NOOB_FRIENDLY_LEVEL) ||
            //  (owner_player.IsPlayer() && owner_player.Stat[ST_LEVEL]>NOOB_FRIENDLY_LEVEL && (leader.Stat[ST_LEVEL] <= NOOB_FRIENDLY_LEVEL && group.length()>4 && sredni_lvl_grupy > NOOB_FRIENDLY_LEVEL)))
            //{
                //Log("FindEncounter: Istniejace enco, z zaawansowanym graczem lvl > 15.");
                int outdoorsman = guide.Skill[SK_OUTDOORSMAN] - zone.Difficulty;
                outdoorsman = CLAMP(outdoorsman, 5, 95);

                if(!caravan && outdoorsman >= Random(1, 100))
                {
                    uint8 say = feAlready.TurnBased ? SAY_ENCOUNTER_TB : SAY_ENCOUNTER_RT;

                    if(valid(feAlready.Encounter))
                    {
                        //Log("valid(feAlready.Encounter)");

                        feAlready.Encounter.Ask(say, leader, feAlready.TurnBased);
                        /*
                        if(!feAlready.TurnBased)
                        {
                            if(!caravan && outdoorsman >= Random(1, 100))
                            {
                                //Log("istniejace enco i wywolanie okna dialogowego Ask() w trybie RT");
                                feAlready.Encounter.Ask(say, leader, false);
                            }
                        }
                        else
                        {
                            //Log("istniejace enco i wywolanie okna dialogowego Ask() w trybie TB");
                            feAlready.Encounter.Ask(say, leader, true);
                        }
                        */
                    }
                    else
                    {

                        if(feAlready.TurnBased)
                        {
                            //Log("istniejace enco i wywolanie okna dialogowego SayMsg() w trybie TB");
                            leader.SayMsg(say, TEXTMSG_GM, feAlready.OwnerGroup ? STR_QUESTION_ONLY_PLAYERS_IN_TB : STR_QUESTION_ONLY_PLAYER_IN_TB, "$player" + "|0xffff0000 " + GetSafePlayerName(feAlready.OwnerId) + "$str1" + "\n\n" + "$str2"  + "|0xffff5500 " + "Encounter is in TURN-BASED mode.");
                        }
                        else
                        {
                            //Log("istniejace enco i wywolanie okna dialogowego SayMsg() w trybie RT");
                            leader.SayMsg(say, TEXTMSG_GM, feAlready.OwnerGroup ? STR_QUESTION_ONLY_PLAYERS : STR_QUESTION_ONLY_PLAYER, "$player" + "|0xffff0000 " + GetSafePlayerName(feAlready.OwnerId));
                        }
                    }

                    waitForAnswer = true;
                    if(guide.Skill[SK_OUTDOORSMAN] <= 95)
                        GuideReward(leader, guide, 100 - guide.Skill[SK_OUTDOORSMAN] + zone.Difficulty);
                    else
                        GuideReward(leader, guide, 5 + zone.Difficulty);
                }


                for(uint i = 0, j = group.length(); i < j; i++)
                    if(group[i].IsPlayer())
                    {
                        group[i].Say(SAY_FLASH_WINDOW, "");
                        group[i].PlaySound("encoalert.ogg", true);
                    }
                encounterDescriptor = feAlready.Index;
                return;
            //}
            //else
            //{
            //  encounterDescriptor = 0;
            //  return;
            //}
        }


        //
        // Try find new encounter
        // Creates new encounters on the fly
        //
        DPlayerLog(leader, "Creating new encounters on the fly...");
		//Log("Try find new encounter:");

        CEncounter@ enc = CEncounter();
        // count number of players/mercs within group
        uint        len = 0;
        int         followers = 0;
        for(uint i = 0, j = group.length(); i < j; i++)
        {
            if(group[i].IsNpc())
            {
                if(_CritHasExtMode(group[i], MODE_EXT_SLAVE))
                    continue;
                else                 // if(_CritHasExtMode(group[i], MODE_EXT_FOLLOWER))
                    followers++;
            }
            else
                len++;
        }

        if(followers - __EncountersFreeFollowers > 0)
            len += (followers - __EncountersFreeFollowers) / (caravan ? 2 : 1);

        enc.Ratio = MAX(1, len / 2);
        enc.Difficulty = zone.Difficulty;


		//05-02-2014 Cubik: obliczenie liczby graczy w grupie enco
		uint players_count=0;
		int max_level_gracza=0;
		int min_level_gracza=9999;
        for(uint i = 0, j = group.length(); i < j; i++)
        {
            if(group[i].IsPlayer())
			{
				players_count++;

				if(max_level_gracza < group[i].Stat[ST_LEVEL])
					max_level_gracza=group[i].Stat[ST_LEVEL];

				if(min_level_gracza > group[i].Stat[ST_LEVEL])
					min_level_gracza=group[i].Stat[ST_LEVEL];
			}
		}


        //zone.ChooseGroups(leader, enc);

		//05-02-2014 Cubik: if the caravan is without a player it will not fall into enco
		if(players_count>0)
		{
			//Log("=====START ChooseGroups======");
			//Log("players_count: " + players_count);
			//Log("min_level_gracza: " + min_level_gracza);
			//Log("max_level_gracza: " + max_level_gracza);
			//Log("caravan: " + caravan);
			//Log("len: " + len);
			//Log("followers: " + followers);
			//Log("Wielkosc grupy (enc.Groups.length()): " + enc.Groups.length() );
			//Log("ChooseGroups2()");
			//zone.ChooseGroups(leader, enc);
			zone.ChooseGroups2(leader, enc, max_level_gracza, caravan, players_count, min_level_gracza, playerCaravan);
			//Log("Wielkosc grupy (enc.Groups.length()) po ChooseGroups2(): " + enc.Groups.length() );
			//Log("=====END ChooseGroups======");
		}
		else
		{
			//Log("=====START bez wyboru grupy======");
			//Log("PUSTA KARAWANA,  players_count: " + players_count);
			//Log("players_count: " + players_count);
			//Log("len: " + len);
			//Log("followers: " + followers);
			//Log("Wielkosc grupy (enc.Groups.length()): " + enc.Groups.length() );
			//Log("=====END bez wyboru grupy======");
		}



        // found something
        if(enc.Groups.length() > 0)
        {
			//Log("Creating FoundedEncounter...");
			DPlayerLog(leader, "Creating FoundedEncounter...");
            CFoundedEncounter@ fe = CreateFoundedEncounter(x, y, @enc, zone, leader.Id, group.length() > 1);

            if(!valid(fe))
                return;

            DPlayerLog(leader, "Created FoundedEncounter...");

            if(valid(car))
            {
                //if(95 >= Random(1, 100))
                //{
					//if(!fe.TurnBased)
					//{
						if(!playerCaravan && 95 >= Random(1, 100))
						{
							enc.Ask(SAY_ENCOUNTER_ANY, leader, false);
							waitForAnswer = true;
						}
					//}
					//else
					//{
					//	enc.Ask(SAY_ENCOUNTER_ANY, leader, true);
					//	waitForAnswer = true;
					//}

                //}
            }
            else
            {
                int outdoorsman = guide.Skill[SK_OUTDOORSMAN] - zone.Difficulty;
                outdoorsman = CLAMP(outdoorsman, 6, 95);
                //if(!IsCaravanLeader(leader) && outdoorsman >= Random(1, 100))
                //{
					//if(!fe.TurnBased)
					//{
						////Log("!fe.TurnBased= " + fe.TurnBased);
						if(!IsCaravanLeader(leader) && outdoorsman >= Random(1, 100))
						{
							enc.Ask(SAY_ENCOUNTER_ANY, leader, false);
							waitForAnswer = true;
							giveReward = true;
						}
					//}
					//else
					//{
						////Log("fe.TurnBased= " + fe.TurnBased);
						//if(!IsCaravanLeader(leader))
						//{
						//	enc.Ask(SAY_ENCOUNTER_ANY, leader, true);
						//	waitForAnswer = true;
						//}
					//}

                    //waitForAnswer = true;

                //}
            }

            for(uint i = 0, j = group.length(); i < j; i++)
			{
				group[i].Say(SAY_FLASH_WINDOW, "");
				group[i].PlaySound("encoalert.ogg", true);
			}

            encounterDescriptor = fe.Index;
			//Log("FoundedEncounter DONE...");
        }
		else
		{
			for(uint i = 0, j = group.length(); i < j; i++)
			{
				_AdminLog(group[i], "NOT Creating FoundedEncounter...!   players_count= " + players_count);
			}
		}


    }

    if(empty && encounterDescriptor == 0)
    {
        CFoundedEncounter@ fe = CreateFoundedEncounter(x, y, null, zone, leader.Id, group.length() > 1);
        if(!valid(fe))
            return;
        waitForAnswer = false;
        encounterDescriptor = fe.Index;
        return;
    }

    if(giveReward)       // here, because creation of encounter might fail
    {
        if(guide.Skill[SK_OUTDOORSMAN] <= 95)
            GuideReward(leader, guide, 100 - guide.Skill[SK_OUTDOORSMAN] + zone.Difficulty);
        else
            GuideReward(leader, guide, 5 + zone.Difficulty);
    }
    uint t = GetTick() - start;
    _AdminLog(leader, "FindEncounter: " + t + "ms.");
	//if(group[0].IsPlayer()) Log("FindEncounter: END.");
}


void InviteToEncounter(array<Critter@>& group, Item@ car, uint encounterDescriptor, int combatMode, uint& mapId, uint16& hexX, uint16& hexY, uint8& dir)
{
    //if(group[0].IsPlayer()) Log("InviteToEncounter: START.");
	uint start = GetTick();
    mapId = 0;

    CFoundedEncounter@ fe = GetFoundedEncounter(encounterDescriptor);
    if(!valid(fe))
    {
        Log("GetFoundedEncounter fail.");
        return;
    }

    bool isGenerated = fe.IsGenerated;
    Map@ map = null;
    if(isGenerated)
    {
        Location@ location = GetLocation(fe.LocationId);
        if(!valid(location))
        {
            Log("Location not found.");
            return;
        }

        @map = location.GetMapByIndex(0);
    }
    else
    {
        @map = GenerateEncounter(fe, group);
    }

    if(!valid(map))
    {
        Log("Map not found.");
        return;
    }
    Location@ loc = map.GetLocation();

    // set turnbased for all maps in location (if appies)
    if(!isGenerated && combatMode == COMBAT_MODE_TURN_BASED)     // || (combatMode==COMBAT_MODE_ANY && Random(0,1)==0)))
    {
        for(uint i = 0, j = loc.GetMapCount(); i < j; i++)
            loc.GetMapByIndex(i).SetTurnBasedAvailability(true);
        fe.TurnBased = true;
    }

    Critter@ leader = group[0];

    mapId = map.Id;
    hexX = fe.StartHexX;
    hexY = fe.StartHexY;

    if((!valid(fe.Encounter) || (!fe.Encounter.Special)) && !valid(car))
    {
        dir = GetFreeDir(fe.DirBusy, fe.FirstDirIdx);
        DPlayerLog(leader, "Your dir: " + dir);
        map.MoveHexByDir(hexX, hexY, dir, 5 + leader.Stat[ST_PERCEPTION] + leader.Perk[PE_CAUTIOUS_NATURE] * 3);
        dir += 3;
        if(dir > 5)
            dir -= 6;
    }

    if(valid(car))
    {
        hexX = uint16(-1);
        hexY = uint16(-1);
        OnCarGroupEnterLocation(group, car, map.GetLocation().Id);
		if (_IsCaravanCar(car.GetProtoId()) && valid(fe.Encounter))
			OnPlayerCaravanEnterLocation(group, car, map.GetLocation().Id, fe.Encounter.Special);

    }

    if(valid(fe.Encounter))
    {
        // add player group if new
        if(leader.Id != fe.OwnerId)
            fe.Encounter.AddPlayer(leader);
        for(uint i = 0, j = group.length(); i < j; i++)
            fe.Encounter.Say(leader, group[i]);

        if(fe.Encounter.Special)
            OnSpecialEncounterCreated(loc, group, car, encounterDescriptor);
    }



    // if(valid(fe.Encounter)) AssignChecks(fe.Encounter.Checks,group);
    // if(valid(fe.Encounter)) fe.Encounter.SetTimeout(group); // sets timeout for encountergroups in that encounter
    uint t = GetTick() - start;
    _AdminLog(leader, "InviteToEncounter: " + t + "ms.");
	//if(group[0].IsPlayer()) Log("InviteToEncounter: END.");
}

uint e_UnlockEncounterCaravan(array<uint>@ values)
{
    Item@ car = GetItem(values[0]);
    if (!valid(car))
        return 0;

    car.Val4 = 0;

    return 0;
}

void OnPlayerCaravanEnterLocation(array<Critter@>& group, Item& car, uint locId, bool special)
{
	car.Val4 = 1;

	// sneaker fuckers
	for (uint i = 0, j = group.length(); i < j; ++i)
	{
		if (group[i].IsPlayer() && group[i].GetAccess() < ACCESS_TESTER)
		{
			if (group[i].Mode[MODE_HIDE] != 0)
				group[i].ModeBase[MODE_HIDE] = 0;
			_SetTimeout(group[i], TO_SNEAK, REAL_SECOND(15));
		}
	}

	array<uint> data = { car.Id, locId };
	CreateTimeEvent(AFTER(REAL_SECOND(15)), "e_UnlockEncounterCaravan", data, true);

	if (!special)
	{
		Location@ loc = GetLocation(locId);
		if (loc.Visible != true)
        {
			loc.Visible = true;
    		loc.Color = COLOR_WM_PLAYER_CARAVAN;
            loc.Update();
        }
	}
}

void OnCarGroupEnterLocation(array<Critter@>& group, Item& car, uint locId)
{
    for(uint i = 0, j = group.length(); i < j; i++)
        if(group[i].IsPlayer())
        {
            // group[i].Say(SAY_NETMSG,"You will see this location after leaving");
            group[i].SetKnownLoc(true, locId);
        }
}

void dumpencountergroups(Critter&, int, int, int)
{
    DumpEncounterGroups();
}

void DumpEncounterGroups()
{
    file f;
    f.open("groups.fowm", "a");
    for(uint i = 0; i < GROUP_MAX; i++)
    {
        string           line;
        CEncounterGroup@ group;
        @group = @EncounterGroups[i];

        line = i + "," + group.Position + "," + group.Spacing + "," + group.RatioMin + "," + group.RatioMax + "," + (group.TeamNum / 100) + "," + (group.TeamNum % 10) + "|||";

        for(uint j = 0; j < group.Objects.length(); j++)
        {
            if(group.Objects[j].ObjectType != ENCOUNTER_OBJECT_CRITTER)
                continue;

            line += group.Objects[j].Pid + "," + group.Objects[j].Dialog + "," + group.Objects[j].Script + "," + group.Objects[j].Ratio + "," + (group.Objects[j].Dead ? 1 : 0);
            Log("in npc");

            if(group.Objects[j].Childs.length() > 0)
            {
                line += "|";
                for(uint k = 0, l = group.Objects[j].Childs.length(); k < l; k++)
                {
                    Log("in items");
                    CEncounterObject@ child = group.Objects[j].Childs[k];

                    // if (child.ObjectType!=ENCOUNTER_OBJECT_ITEM)
                    //    continue;


                    line += (child.Pid + "," + child.Minimum + "," + child.Maximum + "," + child.Slot);
                    Log("item: " + (child.Pid + "," + child.Minimum + "," + child.Maximum + "," + child.Slot));
                    if(k < (group.Objects[j].Childs.length() - 1))
                    {
                        Log("k:" + k);
                        Log("length:" + group.Objects[j].Childs.length());
                        line += "|";
                    }
                }

            }
            line += "||";
        }
        f.writeString(line + "\n");
    }
    f.close();
}

#define GROUP_NPC_DATA_ITEM    ("0")
#define GROUP_NPC_DATA_PERK    ("1")

void LoadWorldmapGroups(string@ fileName)
{
    CEncounterGroup@ group;
    // initialize indices for encounter groups
    for(uint i = 0, j = EncounterGroups.length(); i < j; i++)
        EncounterGroups[i].Index = i;

    file f;
    DLog("Reading Groups");
    if(f.open(fileName, "r") >= 0)
    {
        // Read the whole file into the string buffer
        string str;
        int    l = f.readString(f.getSize(), str);
        f.close();

        // now we need to process that whole string
        array<string@>@ lines = split(str, "\n");
        DLog("Read " + lines.length() + " lines");

        /*

                Example string:
                GROUP_Raiders,1,5,2,3,0,0,1.00,1.00,7,15
         *,36,63,mob@critter_init,50,0,-1,-1,0|0,122,1,1,1|0,121,10,25,0|0,40,0,1,0|1,PE_ACTION_BOY,327,1,100
         *,33,63,mob@critter_init,45,0,-1,-1,0|0,7,1,1,1

         */

        int GroupIndex = -1;
        for(uint i = 0; i < lines.length(); i++)
        {
            // Log("i:"+i);

            if(lines[i].length() < 5)
            {
                continue;
            }

            if(substring(lines[i], 0, 1) == "*")             // Npc data
            {
                // DLog("parsing npc @ " + i);
                array<string@>@ parts = split(lines[i], "|");
                array<string@>@ param = split(parts[0], ",");

                CEncounterObject@ cr;
                int               crpid = 0;
                int               dialog = 0;
                int               ratio = 0;
                int               armor = 0;
                int               helmet = 0;
                int               overridecrtype = 0;
                StrToInt(param[1], crpid);
                StrToInt(param[2], dialog);
                string script = param[3];
                StrToInt(param[4], ratio);
                string dead = param[5];
                StrToInt(param[6], armor);
                StrToInt(param[7], helmet);
                StrToInt(param[8], overridecrtype);

                @cr = group.AddCritter(crpid).SetRatio(ratio).SetDialog(dialog).SetScript(script);
                cr.Armor = armor;
                cr.Helmet = helmet;
                cr.OverrideCrtype = overridecrtype;
                if(dead == "1")
                    @cr.SetDead(true);



                for(uint y = 1; y < parts.length(); y++)
                {
                    array<string@>@ itemData = split(parts[y], ",");
                    if(itemData.length < 1)
                        continue;

                    if(itemData[0] == GROUP_NPC_DATA_ITEM)
                    {
                        // Log("parsing item @ " + i);
                        int pid = 0;
                        int min = 0;
                        int max = 0;
                        int slot = 0;
                        StrToInt(itemData[1], pid);
                        StrToInt(itemData[2], min);
                        StrToInt(itemData[3], max);
                        StrToInt(itemData[4], slot);
                        cr.AddItem(pid, min, max, slot);
                    }
                    else if(itemData[0] == GROUP_NPC_DATA_PERK)
                    {
                        // Log("parsing perk @ " + i);
                        int index  = 0;
                        int level  = 0;
                        int chance = 0;
                        // itemData[1] contains define, used only by WE
                        StrToInt(itemData[2], index);
                        StrToInt(itemData[3], level);
                        StrToInt(itemData[4], chance);
                        cr.AddPerk(index, level, chance);
                    }
                }
            }
            else             // Group data
            {
                array<string@>@ params = split(lines[i], ",");

                int   position = 0;
                int   spacing = 0;
                int   ratiomin = 0;
                int   ratiomax = 0;
                int   factionid = 0;
                int   teammode = 0;

                float quantityday = 0.0;
                float quantitynight = 0.0;

                int   distmin = 0;
                int   distmax = 0;

                StrToInt(params[1], position);
                StrToInt(params[2], spacing);

                StrToInt(params[3], ratiomin);
                StrToInt(params[4], ratiomax);
                StrToInt(params[5], factionid);
                StrToInt(params[6], teammode);
                StrToFloat(params[7], quantityday);
                StrToFloat(params[8], quantitynight);
                StrToInt(params[9], distmin);
                StrToInt(params[10], distmax);

                // DLog("day: " + quantityday);
                // DLog("night: " + quantitynight);

                @group = @EncounterGroups[++GroupIndex];
                group.Position = position;
                group.Spacing = spacing;
                group.RatioMin = ratiomin;
                group.RatioMax = ratiomax;
                group.QuantityDay = quantityday;
                group.QuantityNight = quantitynight;
                group.DistMin = distmin;
                group.DistMax = distmax;

                if(factionid == -1)
                    group.TeamNum = TEAM_Neutral;
                else if(factionid > 0)
                    group.TeamNum = _TeamIdPack(factionid, 1, teammode);
                else
                    group.TeamNum = 0;                   // just mob
            }
        }
    }
}

void WorldmapInit()
{
    LoadImage(IMAGE_RELIEF, "wm.png", 1, PATH_SERVER_MAPS);

    for(uint i = 0, j = Worldmap.length(); i < j; i++)
        @Worldmap[i] = CZone(i % ZONE_COUNT_X, i / ZONE_COUNT_X);

    // Groups be here
    LoadWorldmapGroups("maps/groups.fowm");
    Log("Encounter groups loaded.");

    // DumpEncounterGroups();

    InitGroupsCost(); // this must be here, after all groups definitions

    LoadWorldmapTables("maps/worldmap.focwm");
    Log("Worldmap loaded.");
    LoadGroupsQuantities();

    #define SAVE_INTERVAL    (REAL_MINUTE(10))
    // spawn 'saving'/updating event
    // CreateTimeEvent(__FullMinute + SAVE_INTERVAL, "e_WorldmapUpdate", false);
}

uint GetGlobalMapRelief(uint x, uint y)
{
    // Used low four bits of image
    // Zero is water
    return GetImageColor(IMAGE_RELIEF, x, y) & 0xF;
}

void InitGroupsCost() // this must be called after all groups are defined
{
    for(uint i = 0; i < GROUP_MAX; i++)
        EncounterGroups[i].SetAverageCost();
}

/**
 * Saves the groups/quantities from the worldmap zones.
 * Format: number of groups, [group index, quantity], [,]...
 */
void SaveGroupsQuantities()
{
    array<uint> data;
    for(uint i = 0, j = Worldmap.length(); i < j; i++)
    {
        data.insertLast(Worldmap[i].Groups.length());
        for(uint k = 0, l = Worldmap[i].Groups.length(); k < l; k++)
        {
            data.insertLast(Worldmap[i].Groups[k]);
            data.insertLast(Worldmap[i].Quantities[k]);
        }
    }
    SetAnyData("WorldmapGroups", data);
}
/**
 * Loads the groups/quantities into the worldmap zones.
 */
void LoadGroupsQuantities()
{
    array<uint> data;
    if(!IsAnyData("WorldmapGroups"))
        return;
    GetAnyData("WorldmapGroups", data);
    uint idx = 0;     // zone idx
    uint cur = 0;     // array position
    uint len = data.length();
    do
    {
        Worldmap[idx].Groups.resize(0);
        Worldmap[idx].Quantities.resize(0);
        for(uint i = 0, j = data[cur++]; i < j; i++)
        {
            Worldmap[idx].Groups.insertLast(data[cur++]);
            Worldmap[idx].Quantities.insertLast(data[cur++]);
        }
        idx++;
    }
    while(cur < len);
}

uint e_WorldmapUpdate(array<uint>@ values)
{
    _TIMEBEGIN;
    SaveGroupsQuantities();
    _TIMEEND;
    return SAVE_INTERVAL;
}

void setquantity(Critter& cr, int group, int mod, int direct)
{
    IZone@ zone = GetZone(cr.WorldX, cr.WorldY);
    if(direct != 0)
        zone.SetQuantity(group, direct);
    else
        zone.ChangeQuantity(group, mod);
}

void listgroups(Critter& cr, int, int, int)
{
    uint   zx = ZONE_X(cr.WorldX);
    uint   zy = ZONE_Y(cr.WorldY);
    CZone@ zone = Worldmap[ZONE_IDX(zx, zy)];
    for(uint i = 0, j = zone.Groups.length(); i < j; i++)
        cr.Say(SAY_NETMSG, "" + zone.Groups[i] + ": " + EncounterGroups[zone.Groups[i]].GetModifiedQuantity(zone.Quantities[i]));
}

void savezones(Critter& cr, int, int, int)
{
    SaveGroupsQuantities();
}
void loadzones(Critter& cr, int, int, int)
{
    LoadGroupsQuantities();
}

void MakeEncounterBoss(uint npcId, uint groupNum)
{
    Critter@ npc = GetCritter(npcId);

    if(!valid(npc))
        return;

    //SetLexem(npc, LEXEM_CRITTER_HEAD, "Boss");

    Item@ armor = npc.GetItem(0, SLOT_ARMOR);
    if(valid(armor))
    {
        if(IsItemCraftable(armor.GetProtoId()))
            AddSpecialBonusEncounterBoss(armor);
        uint wear = Random(0, 10);
        SetMinWear(armor, wear);
        SetWear(armor, wear+Random(5, 15));
    }

    @armor = npc.GetItem(0, SLOT_HEAD);
    if(valid(armor))
    {
        if(IsItemCraftable(armor.GetProtoId()))
            AddSpecialBonusEncounterBoss(armor);
        uint wear = Random(0, 15);
        SetMinWear(armor, wear);
        SetWear(armor, wear+Random(5, 15));
    }

    Item@ weapon = npc.GetItem(0, SLOT_HAND1);

    if(valid(weapon) && weapon.GetType() == ITEM_TYPE_WEAPON)
    {
        if(IsItemCraftable(weapon.GetProtoId()))
            AddSpecialBonusEncounterBoss(weapon);
        uint wear = Random(5, 15);
        SetMinWear(weapon, wear);
        SetWear(weapon, wear+Random(5, 20));
    }

    npc.StatBase[ST_KILL_EXPERIENCE] = int(npc.StatBase[ST_KILL_EXPERIENCE] * 1.5);

    npc.StatBase[ST_MELEE_DAMAGE] *= Random(1, 2);
    npc.StatBase[ST_ACTION_POINTS] *= Random(1, 2);
    npc.StatBase[ST_CURRENT_AP] = npc.Stat[ST_ACTION_POINTS];
    npc.StatBase[ST_SEQUENCE] *= Random(1, 2);
    npc.StatBase[ST_CRITICAL_CHANCE] *= Random(1, 2);

    npc.StatBase[ST_NORMAL_ABSORB] *= Random(1, 2);
    npc.StatBase[ST_LASER_ABSORB] *= Random(1, 2);
    npc.StatBase[ST_FIRE_ABSORB] *= Random(1, 2);
    npc.StatBase[ST_PLASMA_ABSORB] *= Random(1, 2);
    npc.StatBase[ST_ELECTRO_ABSORB] *= Random(1, 2);
    npc.StatBase[ST_EMP_ABSORB] *= Random(1, 2);
    npc.StatBase[ST_EXPLODE_ABSORB] *= Random(1, 2);

    npc.StatBase[ST_NORMAL_RESIST] *= Random(1, 2);
    npc.StatBase[ST_LASER_RESIST] *= Random(1, 2);
    npc.StatBase[ST_FIRE_RESIST] *= Random(1, 2);
    npc.StatBase[ST_PLASMA_RESIST] *= Random(1, 2);
    npc.StatBase[ST_ELECTRO_RESIST] *= Random(1, 2);
    npc.StatBase[ST_EMP_RESIST] *= Random(1, 2);
    npc.StatBase[ST_EXPLODE_RESIST] *= Random(1, 2);

    npc.SkillBase[SK_SMALL_GUNS] *= Random(1, 2);
    npc.SkillBase[SK_BIG_GUNS] *= Random(1, 2);
    npc.SkillBase[SK_ENERGY_WEAPONS] *= Random(1, 2);
    npc.SkillBase[SK_UNARMED] *= Random(1, 2);
    npc.SkillBase[SK_THROWING] *= Random(1, 2);

    npc.PerkBase[PE_TOUGHNESS] = 1;
    npc.PerkBase[PE_BONUS_RATE_OF_ATTACK] = 1;
    npc.PerkBase[PE_CLOSE_COMBAT_MASTER] = 1;
    npc.PerkBase[PE_BONUS_RANGED_DAMAGE] = 1;
    npc.PerkBase[PE_HEAVE_HO] = 1;
    npc.PerkBase[PE_ADRENALINE_RUSH] = 1;
    npc.PerkBase[PE_PYROMANIAC] = 1;
    npc.PerkBase[PE_QUICK_RECOVERY] = 1;
    npc.PerkBase[PE_STONEWALL] = 1;
    npc.PerkBase[PE_WEAPON_HANDLING] = 1;

    int pid = 0;
    switch(groupNum)
    {
        case GROUP_BOS_PATROL_LOW   :
        case GROUP_BOS_Patrol       :
             pid = PID_BOS_DOG_TAGS;
             break;
        case GROUP_NAV_Enclave_Patrol :
             pid = PID_ENCLAVE_DOG_TAGS;
             break;

        case GROUP_NCR_Army:
             pid = PID_NCR_ARMY_DOG_TAGS;
             break;

        case GROUP_Raiders          :
        case GROUP_KLA_Bandits      :
        case GROUP_Modoc_Raiders    :
        case GROUP_Klamath_Raiders  :
        case GROUP_Den_Raiders      :
        case GROUP_VC_Raiders       :
        case GROUP_Redding_Raiders  :
        case GROUP_BH_Raiders       :
        case GROUP_Reno_Raiders     :
        case GROUP_NCR_Raiders      :
        case GROUP_Hub_Raiders      :
        case GROUP_Junktown_Raiders :
        case GROUP_80s_Raiders      :
        case GROUP_RDRC_Raiders     :
             pid = PID_RAIDERS_DOG_TAGS;
             break;

        case GROUP_VPAT_Patrol :
             pid = PID_VAULT_CITY_PATROL_DOG_TAGS;
             break;

        case GROUP_BROK_Unity_Patrol :
             pid = PID_UNITY_PATROL_DOG_TAGS;
             break;

        default:
             pid = 0;
             break;
    }

    if(pid!=0)
        npc.AddItem(pid, 1);
}
